From d0d48283b3489513c46292b6e0cd37607bbf5f37 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Wed, 18 Feb 2015 12:56:05 -0800
Subject: [PATCH] Refactor CSSAgent to use wrapper views, and assorted other
 fixes.

Tighten unique/pointer/reference types and modernize some enums.
---
 Source/JavaScriptCore/inspector/protocol/CSS.json  |   15 +-
 Source/WebCore/WebCore.xcodeproj/project.pbxproj   |   68 +-
 Source/WebCore/css/CSSComputedStyleDeclaration.h   |    4 +-
 Source/WebCore/css/CSSStyleSheet.h                 |    1 +
 Source/WebCore/inspector/InspectorCSSAgent.cpp     | 1056 +++++++++++----
 Source/WebCore/inspector/InspectorCSSAgent.h       |   63 +-
 Source/WebCore/inspector/InspectorCSSId.h          |   79 ++
 .../inspector/InspectorInlineStyleRuleSet.cpp      |  108 ++
 .../inspector/InspectorInlineStyleRuleSet.h        |   96 ++
 .../WebCore/inspector/InspectorInstrumentation.h   |    2 +-
 Source/WebCore/inspector/InspectorRuleSelector.cpp |   83 ++
 Source/WebCore/inspector/InspectorRuleSelector.h   |   65 +
 .../inspector/InspectorStyleDeclaration.cpp        |  135 ++
 .../WebCore/inspector/InspectorStyleDeclaration.h  |   94 ++
 .../WebCore/inspector/InspectorStyleProperty.cpp   |  117 ++
 Source/WebCore/inspector/InspectorStyleProperty.h  |   72 ++
 Source/WebCore/inspector/InspectorStyleRule.cpp    |  125 ++
 Source/WebCore/inspector/InspectorStyleRule.h      |   98 ++
 Source/WebCore/inspector/InspectorStyleRuleSet.cpp |  223 ++++
 Source/WebCore/inspector/InspectorStyleRuleSet.h   |  127 ++
 Source/WebCore/inspector/InspectorStyleSheet.cpp   | 1354 --------------------
 Source/WebCore/inspector/InspectorStyleSheet.h     |  277 ----
 .../inspector/InspectorStylesheetRuleSet.cpp       |  339 +++++
 .../WebCore/inspector/InspectorStylesheetRuleSet.h |  179 +++
 24 files changed, 2819 insertions(+), 1961 deletions(-)
 create mode 100644 Source/WebCore/inspector/InspectorCSSId.h
 create mode 100644 Source/WebCore/inspector/InspectorInlineStyleRuleSet.cpp
 create mode 100644 Source/WebCore/inspector/InspectorInlineStyleRuleSet.h
 create mode 100644 Source/WebCore/inspector/InspectorRuleSelector.cpp
 create mode 100644 Source/WebCore/inspector/InspectorRuleSelector.h
 create mode 100644 Source/WebCore/inspector/InspectorStyleDeclaration.cpp
 create mode 100644 Source/WebCore/inspector/InspectorStyleDeclaration.h
 create mode 100644 Source/WebCore/inspector/InspectorStyleProperty.cpp
 create mode 100644 Source/WebCore/inspector/InspectorStyleProperty.h
 create mode 100644 Source/WebCore/inspector/InspectorStyleRule.cpp
 create mode 100644 Source/WebCore/inspector/InspectorStyleRule.h
 create mode 100644 Source/WebCore/inspector/InspectorStyleRuleSet.cpp
 create mode 100644 Source/WebCore/inspector/InspectorStyleRuleSet.h
 delete mode 100644 Source/WebCore/inspector/InspectorStyleSheet.cpp
 delete mode 100644 Source/WebCore/inspector/InspectorStyleSheet.h
 create mode 100644 Source/WebCore/inspector/InspectorStylesheetRuleSet.cpp
 create mode 100644 Source/WebCore/inspector/InspectorStylesheetRuleSet.h

diff --git a/Source/JavaScriptCore/inspector/protocol/CSS.json b/Source/JavaScriptCore/inspector/protocol/CSS.json
index f02216d..aef4a02 100644
--- a/Source/JavaScriptCore/inspector/protocol/CSS.json
+++ b/Source/JavaScriptCore/inspector/protocol/CSS.json
@@ -1,25 +1,26 @@
 {
     "domain": "CSS",
     "description": "This domain exposes CSS read/write operations. All CSS objects, like stylesheets, rules, and styles, have an associated <code>id</code> used in subsequent operations on the related object. Each object type has a specific <code>id</code> structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the <code>get*ForNode()</code> calls (which accept a DOM node id). Alternatively, a client can discover all the existing stylesheets with the <code>getAllStyleSheets()</code> method and subsequently load the required stylesheet contents using the <code>getStyleSheet[Text]()</code> methods.",
     "availability": "web",
     "types": [
         {
             "id": "StyleSheetId",
-            "type": "string"
+            "type": "integer",
+            "description": "Unique identifier for a stylesheet or element inline style."
         },
         {
             "id": "CSSStyleId",
             "type": "object",
             "properties": [
                 { "name": "styleSheetId", "$ref": "StyleSheetId", "description": "Enclosing stylesheet identifier." },
-                { "name": "ordinal", "type": "integer", "description": "The style ordinal within the stylesheet." }
+                { "name": "ordinal", "type": "integer", "description": "The style ordinal within the stylesheet (if inline style, ordinal is 0)." }
             ],
             "description": "This object identifies a CSS style in a unique way."
         },
         {
             "id": "StyleSheetOrigin",
             "type": "string",
             "enum": ["user", "user-agent", "inspector", "regular"],
             "description": "Stylesheet type: \"user\" for user stylesheets, \"user-agent\" for user-agent stylesheets, \"inspector\" for stylesheets created by the inspector (i.e. those holding the \"via inspector\" rules), \"regular\" for regular stylesheets."
         },
         {
@@ -37,24 +38,24 @@
             "properties": [
                 { "name": "pseudoId", "type": "integer", "description": "Pseudo style identifier (see <code>enum PseudoId</code> in <code>RenderStyleConstants.h</code>)."},
                 { "name": "matches", "type": "array", "items": { "$ref": "RuleMatch" }, "description": "Matches of CSS rules applicable to the pseudo style."}
             ],
             "description": "CSS rule collection for a single pseudo style."
         },
         {
             "id": "InheritedStyleEntry",
             "type": "object",
             "properties": [
-                { "name": "inlineStyle", "$ref": "CSSStyle", "optional": true, "description": "The ancestor node's inline style, if any, in the style inheritance chain." },
+                { "name": "inlineStyle", "$ref": "CSSStyle", "optional": true, "description": "The ancestor element's inline style, if any, in the style inheritance chain." },
                 { "name": "matchedCSSRules", "type": "array", "items": { "$ref": "RuleMatch" }, "description": "Matches of CSS rules matching the ancestor node in the style inheritance chain." }
             ],
-            "description": "CSS rule collection for a single pseudo style."
+            "description": "Inline styles and matched rules for an ancestor element that contributes inherited style properties."
         },
         {
             "id": "RuleMatch",
             "type": "object",
             "properties": [
                 { "name": "rule", "$ref": "CSSRule", "description": "CSS rule in the match." },
                 { "name": "matchingSelectors", "type": "array", "items": { "type": "integer" }, "description": "Matching selector indices in the rule's selectorList selectors (0-based)." }
             ],
             "description": "Match data for a CSS rule."
         },
@@ -169,23 +170,23 @@
                 { "name": "shorthandEntries", "type": "array", "items": { "$ref": "ShorthandEntry" }, "description": "Computed values for all shorthands found in the style." },
                 { "name": "cssText", "type": "string", "optional": true, "description": "Style declaration text (if available)." },
                 { "name": "range", "$ref": "SourceRange", "optional": true, "description": "Style declaration range in the enclosing stylesheet (if available)." },
                 { "name": "width", "type": "string", "optional": true, "description": "The effective \"width\" property value from this style." },
                 { "name": "height", "type": "string", "optional": true, "description": "The effective \"height\" property value from this style." }
             ],
             "description": "CSS style representation."
         },
         {
             "id": "CSSPropertyStatus",
-	    "type": "string",
-            "enum": ["active", "inactive", "disabled", "style"],
-            "description": "The property status: \"active\" if the property is effective in the style, \"inactive\" if the property is overridden by a same-named property in this style later on, \"disabled\" if the property is disabled by the user, \"style\" (implied if absent) if the property is reported by the browser rather than by the CSS source parser."
+            "type": "string",
+            "enum": ["active", "inactive", "style"],
+            "description": "The property status: \"active\" if the property is effective in the style, \"inactive\" if the property is overridden by a same-named property in this style later on, \"style\" (implied if absent) if the property is reported by the browser rather than by the CSS source parser."
         },
         {
             "id": "CSSProperty",
             "type": "object",
             "properties": [
                 { "name": "name", "type": "string", "description": "The property name." },
                 { "name": "value", "type": "string", "description": "The property value." },
                 { "name": "priority", "type": "string", "optional": true, "description": "The property priority (implies \"\" if absent)." },
                 { "name": "implicit", "type": "boolean", "optional": true, "description": "Whether the property is implicit (implies <code>false</code> if absent)." },
                 { "name": "text", "type": "string", "optional": true, "description": "The full property text as specified in the style." },
diff --git a/Source/WebCore/WebCore.xcodeproj/project.pbxproj b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
index 9315617..b1141dc 100644
--- a/Source/WebCore/WebCore.xcodeproj/project.pbxproj
+++ b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
@@ -2559,22 +2559,20 @@
 		7EE6847112D26E3800E79415 /* ResourceResponseCFNet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7EE6845E12D26E3800E79415 /* ResourceResponseCFNet.cpp */; };
 		7EE6847512D26E7000E79415 /* ResourceLoaderCFNet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7EE6847412D26E7000E79415 /* ResourceLoaderCFNet.cpp */; };
 		8102C5881325BB1100DDE67A /* StringCallback.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 8102C5871325BB1100DDE67A /* StringCallback.cpp */; };
 		81AC5999131636E60009A7E0 /* DataTransferItem.h in Headers */ = {isa = PBXBuildFile; fileRef = 81AC5997131636E60009A7E0 /* DataTransferItem.h */; };
 		81AC599A131636E60009A7E0 /* DataTransferItemList.h in Headers */ = {isa = PBXBuildFile; fileRef = 81AC5998131636E60009A7E0 /* DataTransferItemList.h */; };
 		81AC6C36131C57D30009A7E0 /* StringCallback.h in Headers */ = {isa = PBXBuildFile; fileRef = 81AC6C35131C57D30009A7E0 /* StringCallback.h */; };
 		81BE20D311F4BC3200915DFA /* JSIDBCursor.h in Headers */ = {isa = PBXBuildFile; fileRef = 81BE20A811F4B66F00915DFA /* JSIDBCursor.h */; };
 		81F65FF613788FAA00FF6F2D /* DragState.h in Headers */ = {isa = PBXBuildFile; fileRef = 81F65FF513788FAA00FF6F2D /* DragState.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		82AB1743124B99EC00C5069D /* InspectorCSSAgent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 82AB1741124B99EC00C5069D /* InspectorCSSAgent.cpp */; };
 		82AB1744124B99EC00C5069D /* InspectorCSSAgent.h in Headers */ = {isa = PBXBuildFile; fileRef = 82AB1742124B99EC00C5069D /* InspectorCSSAgent.h */; };
-		82AB1773125C826700C5069D /* InspectorStyleSheet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 82AB176F125C826700C5069D /* InspectorStyleSheet.cpp */; };
-		82AB1774125C826700C5069D /* InspectorStyleSheet.h in Headers */ = {isa = PBXBuildFile; fileRef = 82AB1770125C826700C5069D /* InspectorStyleSheet.h */; };
 		82AB1775125C826700C5069D /* InspectorResourceAgent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 82AB1771125C826700C5069D /* InspectorResourceAgent.cpp */; };
 		82AB1776125C826700C5069D /* InspectorResourceAgent.h in Headers */ = {isa = PBXBuildFile; fileRef = 82AB1772125C826700C5069D /* InspectorResourceAgent.h */; };
 		82E3D8DE122EA0D1003AE5BC /* CSSPropertySourceData.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 82E3D8DC122EA0D1003AE5BC /* CSSPropertySourceData.cpp */; };
 		82E3D8DF122EA0D1003AE5BC /* CSSPropertySourceData.h in Headers */ = {isa = PBXBuildFile; fileRef = 82E3D8DD122EA0D1003AE5BC /* CSSPropertySourceData.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		832B843419D8E55100B26055 /* SVGAnimateElementBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 832B843319D8E55100B26055 /* SVGAnimateElementBase.h */; };
 		832B843619D8E57400B26055 /* SVGAnimateElementBase.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 832B843519D8E57400B26055 /* SVGAnimateElementBase.cpp */; };
 		83520C7E1A71BFCC006BD2AA /* CSSFontFamily.h in Headers */ = {isa = PBXBuildFile; fileRef = 83520C7D1A71BFCC006BD2AA /* CSSFontFamily.h */; };
 		835D363719FF6193004C93AB /* StyleBuilderCustom.h in Headers */ = {isa = PBXBuildFile; fileRef = 835D363619FF6193004C93AB /* StyleBuilderCustom.h */; };
 		836FBCEA178C113200B21A15 /* SVGAnimatedTypeAnimator.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 836FBCE9178C113200B21A15 /* SVGAnimatedTypeAnimator.cpp */; };
 		836FBCEC178C117F00B21A15 /* SVGAnimatedProperty.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 836FBCEB178C117F00B21A15 /* SVGAnimatedProperty.cpp */; };
@@ -5562,20 +5560,35 @@
 		C375D7FD16639519006184AB /* TypeAhead.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C375D7FB16639519006184AB /* TypeAhead.cpp */; };
 		C375D7FE16639519006184AB /* TypeAhead.h in Headers */ = {isa = PBXBuildFile; fileRef = C375D7FC16639519006184AB /* TypeAhead.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C37CDEBD149EF2030042090D /* ColorChooserClient.h in Headers */ = {isa = PBXBuildFile; fileRef = C37CDEBC149EF2030042090D /* ColorChooserClient.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C3CF17A415B0063F00276D39 /* IdTargetObserver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C3CF17A015B0063F00276D39 /* IdTargetObserver.cpp */; };
 		C3CF17A515B0063F00276D39 /* IdTargetObserver.h in Headers */ = {isa = PBXBuildFile; fileRef = C3CF17A115B0063F00276D39 /* IdTargetObserver.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C3CF17A615B0063F00276D39 /* IdTargetObserverRegistry.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C3CF17A215B0063F00276D39 /* IdTargetObserverRegistry.cpp */; };
 		C3CF17A715B0063F00276D39 /* IdTargetObserverRegistry.h in Headers */ = {isa = PBXBuildFile; fileRef = C3CF17A315B0063F00276D39 /* IdTargetObserverRegistry.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C400D10918F1C8F60090D863 /* EventLoopInput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C400D10818F1C8F60090D863 /* EventLoopInput.cpp */; };
 		C4CD629A18383766007EBAF1 /* FrameSnapshotting.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4CD629818383766007EBAF1 /* FrameSnapshotting.cpp */; };
 		C4CD629B18383766007EBAF1 /* FrameSnapshotting.h in Headers */ = {isa = PBXBuildFile; fileRef = C4CD629918383766007EBAF1 /* FrameSnapshotting.h */; settings = {ATTRIBUTES = (Private, ); }; };
+		C4E657F21A97F7A700479C15 /* InspectorCSSId.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F11A97F7A700479C15 /* InspectorCSSId.h */; };
+		C4E657FA1A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E657F31A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp */; };
+		C4E657FB1A97FBED00479C15 /* InspectorInlineStyleRuleSet.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F41A97FBED00479C15 /* InspectorInlineStyleRuleSet.h */; };
+		C4E657FC1A97FBED00479C15 /* InspectorStyleRule.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F51A97FBED00479C15 /* InspectorStyleRule.h */; };
+		C4E657FD1A97FBED00479C15 /* InspectorStyleProperty.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F61A97FBED00479C15 /* InspectorStyleProperty.h */; };
+		C4E657FE1A97FBED00479C15 /* InspectorStyleRuleSet.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F71A97FBED00479C15 /* InspectorStyleRuleSet.h */; };
+		C4E657FF1A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E657F81A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp */; };
+		C4E658001A97FBED00479C15 /* InspectorStylesheetRuleSet.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F91A97FBED00479C15 /* InspectorStylesheetRuleSet.h */; };
+		C4E658021A98016800479C15 /* InspectorStyleRule.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E658011A98016800479C15 /* InspectorStyleRule.cpp */; };
+		C4E658041A984B5200479C15 /* InspectorStyleRuleSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E658031A984B5200479C15 /* InspectorStyleRuleSet.cpp */; };
+		C4E658091A9CCE6D00479C15 /* InspectorStyleDeclaration.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E658071A9CCE6D00479C15 /* InspectorStyleDeclaration.cpp */; };
+		C4E6580A1A9CCE6D00479C15 /* InspectorStyleDeclaration.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E658081A9CCE6D00479C15 /* InspectorStyleDeclaration.h */; };
+		C4E6580C1A9CCED500479C15 /* InspectorStyleProperty.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E6580B1A9CCED500479C15 /* InspectorStyleProperty.cpp */; };
+		C4E6580F1A9D0D6900479C15 /* InspectorRuleSelector.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E6580D1A9D0D6900479C15 /* InspectorRuleSelector.cpp */; };
+		C4E658101A9D0D6900479C15 /* InspectorRuleSelector.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E6580E1A9D0D6900479C15 /* InspectorRuleSelector.h */; };
 		C50D0E830FF4272900AC2644 /* StorageNamespace.h in Headers */ = {isa = PBXBuildFile; fileRef = C50D0E810FF4272900AC2644 /* StorageNamespace.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C5137CF211A58378004ADB99 /* JSDOMStringList.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C5137CF011A58378004ADB99 /* JSDOMStringList.cpp */; };
 		C5137CF311A58378004ADB99 /* JSDOMStringList.h in Headers */ = {isa = PBXBuildFile; fileRef = C5137CF111A58378004ADB99 /* JSDOMStringList.h */; };
 		C5278B0C17F212EA003A2998 /* PlatformPasteboardIOS.mm in Sources */ = {isa = PBXBuildFile; fileRef = C5278B0B17F212EA003A2998 /* PlatformPasteboardIOS.mm */; };
 		C544274B11A57E7A0063A749 /* DOMStringList.h in Headers */ = {isa = PBXBuildFile; fileRef = C544274911A57E7A0063A749 /* DOMStringList.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C55610F111A704EB00B82D27 /* DOMStringList.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C55610F011A704EB00B82D27 /* DOMStringList.cpp */; };
 		C5592F781A92AA28001F8862 /* CharacterProperties.h in Headers */ = {isa = PBXBuildFile; fileRef = C5592F771A92AA28001F8862 /* CharacterProperties.h */; };
 		C55C7BA11718AFBA001327E4 /* RenderThemeIOS.mm in Sources */ = {isa = PBXBuildFile; fileRef = C55C7BA01718AFBA001327E4 /* RenderThemeIOS.mm */; };
 		C572EE1F1201C9BC007D8F82 /* JSIDBIndex.h in Headers */ = {isa = PBXBuildFile; fileRef = C572EE1D1201C9BC007D8F82 /* JSIDBIndex.h */; };
 		C57FEDE11212EE9C0097BE65 /* FileSystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C57FEDE01212EE9C0097BE65 /* FileSystem.cpp */; };
@@ -9768,22 +9781,20 @@
 		81AC5998131636E60009A7E0 /* DataTransferItemList.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DataTransferItemList.h; sourceTree = "<group>"; };
 		81AC5AE81316392E0009A7E0 /* DataTransferItem.idl */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = DataTransferItem.idl; sourceTree = "<group>"; };
 		81AC5AE91316392E0009A7E0 /* DataTransferItemList.idl */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = DataTransferItemList.idl; sourceTree = "<group>"; };
 		81AC6C34131C57C20009A7E0 /* StringCallback.idl */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = StringCallback.idl; sourceTree = "<group>"; };
 		81AC6C35131C57D30009A7E0 /* StringCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StringCallback.h; sourceTree = "<group>"; };
 		81BE20A811F4B66F00915DFA /* JSIDBCursor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JSIDBCursor.h; sourceTree = "<group>"; };
 		81F65FF513788FAA00FF6F2D /* DragState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DragState.h; sourceTree = "<group>"; };
 		8225432CA9D4B4CF4628EC7F /* JSBeforeUnloadEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JSBeforeUnloadEvent.cpp; sourceTree = "<group>"; };
 		82AB1741124B99EC00C5069D /* InspectorCSSAgent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorCSSAgent.cpp; sourceTree = "<group>"; };
 		82AB1742124B99EC00C5069D /* InspectorCSSAgent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorCSSAgent.h; sourceTree = "<group>"; };
-		82AB176F125C826700C5069D /* InspectorStyleSheet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStyleSheet.cpp; sourceTree = "<group>"; };
-		82AB1770125C826700C5069D /* InspectorStyleSheet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleSheet.h; sourceTree = "<group>"; };
 		82AB1771125C826700C5069D /* InspectorResourceAgent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorResourceAgent.cpp; sourceTree = "<group>"; };
 		82AB1772125C826700C5069D /* InspectorResourceAgent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorResourceAgent.h; sourceTree = "<group>"; };
 		82E3D8DC122EA0D1003AE5BC /* CSSPropertySourceData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CSSPropertySourceData.cpp; sourceTree = "<group>"; };
 		82E3D8DD122EA0D1003AE5BC /* CSSPropertySourceData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CSSPropertySourceData.h; sourceTree = "<group>"; };
 		832B843319D8E55100B26055 /* SVGAnimateElementBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SVGAnimateElementBase.h; sourceTree = "<group>"; };
 		832B843519D8E57400B26055 /* SVGAnimateElementBase.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SVGAnimateElementBase.cpp; sourceTree = "<group>"; };
 		83520C7D1A71BFCC006BD2AA /* CSSFontFamily.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CSSFontFamily.h; sourceTree = "<group>"; };
 		835D363619FF6193004C93AB /* StyleBuilderCustom.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StyleBuilderCustom.h; sourceTree = "<group>"; };
 		836FBCE9178C113200B21A15 /* SVGAnimatedTypeAnimator.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SVGAnimatedTypeAnimator.cpp; sourceTree = "<group>"; };
 		836FBCEB178C117F00B21A15 /* SVGAnimatedProperty.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SVGAnimatedProperty.cpp; sourceTree = "<group>"; };
@@ -13025,20 +13036,35 @@
 		C375D7FC16639519006184AB /* TypeAhead.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TypeAhead.h; sourceTree = "<group>"; };
 		C37CDEBC149EF2030042090D /* ColorChooserClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ColorChooserClient.h; sourceTree = "<group>"; };
 		C3CF17A015B0063F00276D39 /* IdTargetObserver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = IdTargetObserver.cpp; sourceTree = "<group>"; };
 		C3CF17A115B0063F00276D39 /* IdTargetObserver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IdTargetObserver.h; sourceTree = "<group>"; };
 		C3CF17A215B0063F00276D39 /* IdTargetObserverRegistry.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = IdTargetObserverRegistry.cpp; sourceTree = "<group>"; };
 		C3CF17A315B0063F00276D39 /* IdTargetObserverRegistry.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IdTargetObserverRegistry.h; sourceTree = "<group>"; };
 		C3E61C653A64807A83E76FB8 /* MathMLMencloseElement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MathMLMencloseElement.cpp; sourceTree = "<group>"; };
 		C400D10818F1C8F60090D863 /* EventLoopInput.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = EventLoopInput.cpp; sourceTree = "<group>"; };
 		C4CD629818383766007EBAF1 /* FrameSnapshotting.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FrameSnapshotting.cpp; sourceTree = "<group>"; };
 		C4CD629918383766007EBAF1 /* FrameSnapshotting.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FrameSnapshotting.h; sourceTree = "<group>"; };
+		C4E657F11A97F7A700479C15 /* InspectorCSSId.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorCSSId.h; sourceTree = "<group>"; };
+		C4E657F31A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorInlineStyleRuleSet.cpp; sourceTree = "<group>"; };
+		C4E657F41A97FBED00479C15 /* InspectorInlineStyleRuleSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorInlineStyleRuleSet.h; sourceTree = "<group>"; };
+		C4E657F51A97FBED00479C15 /* InspectorStyleRule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleRule.h; sourceTree = "<group>"; };
+		C4E657F61A97FBED00479C15 /* InspectorStyleProperty.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleProperty.h; sourceTree = "<group>"; };
+		C4E657F71A97FBED00479C15 /* InspectorStyleRuleSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleRuleSet.h; sourceTree = "<group>"; };
+		C4E657F81A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStylesheetRuleSet.cpp; sourceTree = "<group>"; };
+		C4E657F91A97FBED00479C15 /* InspectorStylesheetRuleSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStylesheetRuleSet.h; sourceTree = "<group>"; };
+		C4E658011A98016800479C15 /* InspectorStyleRule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStyleRule.cpp; sourceTree = "<group>"; };
+		C4E658031A984B5200479C15 /* InspectorStyleRuleSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStyleRuleSet.cpp; sourceTree = "<group>"; };
+		C4E658071A9CCE6D00479C15 /* InspectorStyleDeclaration.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStyleDeclaration.cpp; sourceTree = "<group>"; };
+		C4E658081A9CCE6D00479C15 /* InspectorStyleDeclaration.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleDeclaration.h; sourceTree = "<group>"; };
+		C4E6580B1A9CCED500479C15 /* InspectorStyleProperty.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStyleProperty.cpp; sourceTree = "<group>"; };
+		C4E6580D1A9D0D6900479C15 /* InspectorRuleSelector.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorRuleSelector.cpp; sourceTree = "<group>"; };
+		C4E6580E1A9D0D6900479C15 /* InspectorRuleSelector.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorRuleSelector.h; sourceTree = "<group>"; };
 		C50D0E810FF4272900AC2644 /* StorageNamespace.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StorageNamespace.h; sourceTree = "<group>"; };
 		C5137CF011A58378004ADB99 /* JSDOMStringList.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JSDOMStringList.cpp; sourceTree = "<group>"; };
 		C5137CF111A58378004ADB99 /* JSDOMStringList.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JSDOMStringList.h; sourceTree = "<group>"; };
 		C5278B0B17F212EA003A2998 /* PlatformPasteboardIOS.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = PlatformPasteboardIOS.mm; path = ios/PlatformPasteboardIOS.mm; sourceTree = "<group>"; };
 		C544274911A57E7A0063A749 /* DOMStringList.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOMStringList.h; sourceTree = "<group>"; };
 		C544274A11A57E7A0063A749 /* DOMStringList.idl */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = DOMStringList.idl; sourceTree = "<group>"; };
 		C55610F011A704EB00B82D27 /* DOMStringList.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DOMStringList.cpp; sourceTree = "<group>"; };
 		C5592F771A92AA28001F8862 /* CharacterProperties.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CharacterProperties.h; sourceTree = "<group>"; };
 		C55C7BA01718AFBA001327E4 /* RenderThemeIOS.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = RenderThemeIOS.mm; sourceTree = "<group>"; };
 		C572EE1D1201C9BC007D8F82 /* JSIDBIndex.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JSIDBIndex.h; sourceTree = "<group>"; };
@@ -15263,20 +15289,21 @@
 				7A54881514E432A1006AE05A /* DOMPatchSupport.h */,
 				B885E8D211E06DD2009FFBF4 /* InspectorApplicationCacheAgent.cpp */,
 				B885E8D311E06DD2009FFBF4 /* InspectorApplicationCacheAgent.h */,
 				7A1F2B51126C61B20006A7E6 /* InspectorClient.cpp */,
 				1C81B9580E97330800266E07 /* InspectorClient.h */,
 				F3F5CF1012ED81A80084C569 /* InspectorConsoleInstrumentation.h */,
 				1C81B9570E97330800266E07 /* InspectorController.cpp */,
 				1C81B9560E97330800266E07 /* InspectorController.h */,
 				82AB1741124B99EC00C5069D /* InspectorCSSAgent.cpp */,
 				82AB1742124B99EC00C5069D /* InspectorCSSAgent.h */,
+				C4E657F11A97F7A700479C15 /* InspectorCSSId.h */,
 				7AB0B1BE1211A62200A76940 /* InspectorDatabaseAgent.cpp */,
 				7AB0B1BF1211A62200A76940 /* InspectorDatabaseAgent.h */,
 				F3F5CF1212ED81B30084C569 /* InspectorDatabaseInstrumentation.h */,
 				41F062130F5F192600A07EAC /* InspectorDatabaseResource.cpp */,
 				41F062120F5F192600A07EAC /* InspectorDatabaseResource.h */,
 				7A2458791021EAF4000A00AA /* InspectorDOMAgent.cpp */,
 				7A24587A1021EAF4000A00AA /* InspectorDOMAgent.h */,
 				F3D4C47612E07663003DA150 /* InspectorDOMDebuggerAgent.cpp */,
 				F3D4C47712E07663003DA150 /* InspectorDOMDebuggerAgent.h */,
 				7A74ECB8101839A500BF939E /* InspectorDOMStorageAgent.cpp */,
@@ -15285,41 +15312,53 @@
 				F344C7121125B82C00F26EEE /* InspectorFrontendClient.h */,
 				F344C75711294FF600F26EEE /* InspectorFrontendClientLocal.cpp */,
 				F344C75211294D9D00F26EEE /* InspectorFrontendClientLocal.h */,
 				7A0E770B10C00A8800A0276E /* InspectorFrontendHost.cpp */,
 				7A0E770C10C00A8800A0276E /* InspectorFrontendHost.h */,
 				7A0E770D10C00A8800A0276E /* InspectorFrontendHost.idl */,
 				7A54857D14E02D51006AE05A /* InspectorHistory.cpp */,
 				7A54857E14E02D51006AE05A /* InspectorHistory.h */,
 				7ACD88D114C08BD60084EDD2 /* InspectorIndexedDBAgent.cpp */,
 				7ACD88D214C08BD60084EDD2 /* InspectorIndexedDBAgent.h */,
+				C4E657F31A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp */,
+				C4E657F41A97FBED00479C15 /* InspectorInlineStyleRuleSet.h */,
 				20D629241253690B00081543 /* InspectorInstrumentation.cpp */,
 				20D629251253690B00081543 /* InspectorInstrumentation.h */,
 				A5840E1A187B74D500843B10 /* InspectorInstrumentationCookie.cpp */,
 				A5840E1B187B74D500843B10 /* InspectorInstrumentationCookie.h */,
 				71B1E123164048CC00B1880A /* InspectorLayerTreeAgent.cpp */,
 				71B1E124164048CC00B1880A /* InspectorLayerTreeAgent.h */,
 				504AACCB1834455900E3D9BC /* InspectorNodeFinder.cpp */,
 				504AACCC1834455900E3D9BC /* InspectorNodeFinder.h */,
 				7C522D4915B477E8009B7C95 /* InspectorOverlay.cpp */,
 				7C522D4A15B478B2009B7C95 /* InspectorOverlay.h */,
 				A518225417E2A0D400A9BA1D /* InspectorOverlayPage.css */,
 				7A7256B915EB9F5B007323A7 /* InspectorOverlayPage.html */,
 				A518225517E2A0D400A9BA1D /* InspectorOverlayPage.js */,
 				4F6FDD621341DEDD001F8EE3 /* InspectorPageAgent.cpp */,
 				4F6FDD631341DEDD001F8EE3 /* InspectorPageAgent.h */,
 				99CC0B6418BE9F15006CEBCC /* InspectorReplayAgent.cpp */,
 				99CC0B6518BE9F15006CEBCC /* InspectorReplayAgent.h */,
 				82AB1771125C826700C5069D /* InspectorResourceAgent.cpp */,
 				82AB1772125C826700C5069D /* InspectorResourceAgent.h */,
-				82AB176F125C826700C5069D /* InspectorStyleSheet.cpp */,
-				82AB1770125C826700C5069D /* InspectorStyleSheet.h */,
+				C4E6580D1A9D0D6900479C15 /* InspectorRuleSelector.cpp */,
+				C4E6580E1A9D0D6900479C15 /* InspectorRuleSelector.h */,
+				C4E658071A9CCE6D00479C15 /* InspectorStyleDeclaration.cpp */,
+				C4E658081A9CCE6D00479C15 /* InspectorStyleDeclaration.h */,
+				C4E658011A98016800479C15 /* InspectorStyleRule.cpp */,
+				C4E657F51A97FBED00479C15 /* InspectorStyleRule.h */,
+				C4E6580B1A9CCED500479C15 /* InspectorStyleProperty.cpp */,
+				C4E657F61A97FBED00479C15 /* InspectorStyleProperty.h */,
+				C4E658031A984B5200479C15 /* InspectorStyleRuleSet.cpp */,
+				C4E657F71A97FBED00479C15 /* InspectorStyleRuleSet.h */,
+				C4E657F81A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp */,
+				C4E657F91A97FBED00479C15 /* InspectorStylesheetRuleSet.h */,
 				754133A9102E00F400075D00 /* InspectorTimelineAgent.cpp */,
 				754133A7102E00E800075D00 /* InspectorTimelineAgent.h */,
 				A593CF8A1840535200BFCE27 /* InspectorWebAgentBase.h */,
 				F3810C191365A49600ED6E33 /* InspectorWorkerAgent.cpp */,
 				F3810C1A1365A49600ED6E33 /* InspectorWorkerAgent.h */,
 				F375CC061150D300008DDB81 /* InspectorWorkerResource.h */,
 				F350B73413F1377D00880C43 /* InstrumentingAgents.cpp */,
 				F3ABFE0B130E9DA000E7F7D1 /* InstrumentingAgents.h */,
 				59C27F04138D28C10079B7E2 /* NetworkResourcesData.cpp */,
 				59C27F06138D28CF0079B7E2 /* NetworkResourcesData.h */,
@@ -24803,29 +24842,31 @@
 				41F062140F5F192600A07EAC /* InspectorDatabaseResource.h in Headers */,
 				7A24587C1021EAF4000A00AA /* InspectorDOMAgent.h in Headers */,
 				F3D4C47912E07663003DA150 /* InspectorDOMDebuggerAgent.h in Headers */,
 				7A74ECBB101839A600BF939E /* InspectorDOMStorageAgent.h in Headers */,
 				227777601345DEA9008EA455 /* InspectorForwarding.h in Headers */,
 				F344C7141125B82C00F26EEE /* InspectorFrontendClient.h in Headers */,
 				F344C75311294D9D00F26EEE /* InspectorFrontendClientLocal.h in Headers */,
 				7A0E770F10C00A8800A0276E /* InspectorFrontendHost.h in Headers */,
 				7A54858014E02D51006AE05A /* InspectorHistory.h in Headers */,
 				7ACD88D414C08BD60084EDD2 /* InspectorIndexedDBAgent.h in Headers */,
+				C4E657FB1A97FBED00479C15 /* InspectorInlineStyleRuleSet.h in Headers */,
 				20D629271253690B00081543 /* InspectorInstrumentation.h in Headers */,
 				A5840E1D187B74D500843B10 /* InspectorInstrumentationCookie.h in Headers */,
 				71B1E125164048F700B1880A /* InspectorLayerTreeAgent.h in Headers */,
 				504AACCE1834455900E3D9BC /* InspectorNodeFinder.h in Headers */,
 				0F03C0751884805500A5F8CA /* InspectorOverlay.h in Headers */,
 				4F6FDD651341DEDD001F8EE3 /* InspectorPageAgent.h in Headers */,
 				99CC0B6718BE9F15006CEBCC /* InspectorReplayAgent.h in Headers */,
 				82AB1776125C826700C5069D /* InspectorResourceAgent.h in Headers */,
-				82AB1774125C826700C5069D /* InspectorStyleSheet.h in Headers */,
+				C4E6580A1A9CCE6D00479C15 /* InspectorStyleDeclaration.h in Headers */,
+				C4E657FE1A97FBED00479C15 /* InspectorStyleRuleSet.h in Headers */,
 				754133A8102E00E800075D00 /* InspectorTimelineAgent.h in Headers */,
 				A593CF8B1840535200BFCE27 /* InspectorWebAgentBase.h in Headers */,
 				F3810C1C1365A49600ED6E33 /* InspectorWorkerAgent.h in Headers */,
 				F375CC071150D300008DDB81 /* InspectorWorkerResource.h in Headers */,
 				F3ABFE0C130E9DA000E7F7D1 /* InstrumentingAgents.h in Headers */,
 				B27535720B053814002CE64F /* IntPoint.h in Headers */,
 				E462A4A1113E71BE004A4220 /* IntPointHash.h in Headers */,
 				B27535740B053814002CE64F /* IntRect.h in Headers */,
 				A2B9217316C5CC420041DCD9 /* IntRectExtent.h in Headers */,
 				E134F5AB12EE343F004EC58D /* IntRectHash.h in Headers */,
@@ -24967,20 +25008,21 @@
 				BC00F0150E0A189500FD04E3 /* JSFile.h in Headers */,
 				2E3BC0CB117D3E0800B9409A /* JSFileError.h in Headers */,
 				898785F1122E1E87003AABDA /* JSFileException.h in Headers */,
 				BC00F0170E0A189500FD04E3 /* JSFileList.h in Headers */,
 				2E94F43C119207DA00B7F75D /* JSFileReader.h in Headers */,
 				898785F5122E1EAC003AABDA /* JSFileReaderSync.h in Headers */,
 				B6D9D27B14EAC0860090D75E /* JSFocusEvent.h in Headers */,
 				409EBDC016B7F38E00CBA3FC /* JSFontLoader.h in Headers */,
 				FDA15EAC12B03EE1003A583A /* JSGainNode.h in Headers */,
 				518F5002194CAC3A0081BAAE /* JSGamepad.h in Headers */,
+				C4E658101A9D0D6900479C15 /* InspectorRuleSelector.h in Headers */,
 				518F5004194CAC3A0081BAAE /* JSGamepadButton.h in Headers */,
 				FE80DA640E9C4703000D6F75 /* JSGeolocation.h in Headers */,
 				FE80DA660E9C4703000D6F75 /* JSGeoposition.h in Headers */,
 				0FDA7C1F188322FC00C954B5 /* JSGestureEvent.h in Headers */,
 				8482B7521198CB6B00BFB005 /* JSHashChangeEvent.h in Headers */,
 				BC94D14F0C275C68006BC617 /* JSHistory.h in Headers */,
 				BC97E413109154FA0010D361 /* JSHTMLAllCollection.h in Headers */,
 				1A4A2DF00A1B852A00C807F8 /* JSHTMLAnchorElement.h in Headers */,
 				1A4A2DF20A1B852A00C807F8 /* JSHTMLAppletElement.h in Headers */,
 				1AE2AA1F0A1CDAB400B42B25 /* JSHTMLAreaElement.h in Headers */,
@@ -25386,20 +25428,21 @@
 				49EED1471051969400099FAB /* JSWebGLRenderingContext.h in Headers */,
 				49C7B9A31042D2D30009D447 /* JSWebGLShader.h in Headers */,
 				A07D3356152B630E001B6393 /* JSWebGLShaderPrecisionFormat.h in Headers */,
 				49C7B9A51042D2D30009D447 /* JSWebGLTexture.h in Headers */,
 				0C45342810CDBBFA00869157 /* JSWebGLUniformLocation.h in Headers */,
 				77EF62F412F9DB7400C77BD2 /* JSWebGLVertexArrayObjectOES.h in Headers */,
 				31C0FF3E0E4CEFAC007D6FE5 /* JSWebKitAnimationEvent.h in Headers */,
 				310603751432819C00ABF4BA /* JSWebKitCSSFilterValue.h in Headers */,
 				316FE0720E6CCBEE00BF6088 /* JSCSSKeyframeRule.h in Headers */,
 				316FE0740E6CCBEE00BF6088 /* JSCSSKeyframesRule.h in Headers */,
+				C4E657FD1A97FBED00479C15 /* InspectorStyleProperty.h in Headers */,
 				498391400F1E767500C23782 /* JSWebKitCSSMatrix.h in Headers */,
 				8AD0A59514C88336000D83C5 /* JSWebKitCSSRegionRule.h in Headers */,
 				31611E5B0E1C4DE000F6A579 /* JSWebKitCSSTransformValue.h in Headers */,
 				3F2B33EF165AF15600E3987C /* JSWebKitCSSViewportRule.h in Headers */,
 				7CC69941191EC5F500AF2270 /* JSWebKitNamespace.h in Headers */,
 				0FDA7C271883333200C954B5 /* JSWebKitPlaybackTargetAvailabilityEvent.h in Headers */,
 				494BD79E0F55C94C00747828 /* JSWebKitPoint.h in Headers */,
 				31C0FF400E4CEFAC007D6FE5 /* JSWebKitTransitionEvent.h in Headers */,
 				5DA5E0FD102B953800088CF9 /* JSWebSocket.h in Headers */,
 				65DF320609D1CC60000BE325 /* JSWheelEvent.h in Headers */,
@@ -25442,20 +25485,21 @@
 				A12538D413F9B60A00024754 /* LayoutRepainter.h in Headers */,
 				141DC054164834B900371E5A /* LayoutSize.h in Headers */,
 				2D9066070BE141D400956998 /* LayoutState.h in Headers */,
 				141DC0481648348F00371E5A /* LayoutUnit.h in Headers */,
 				E4C3B1FA0F0E4161009693F6 /* LegacyTileCache.h in Headers */,
 				E4B65A58132FA8E70070E7BE /* LegacyTileGrid.h in Headers */,
 				E424A39E1330DF0100CF6DC9 /* LegacyTileGridTile.h in Headers */,
 				E4B65A5C132FACB00070E7BE /* LegacyTileLayer.h in Headers */,
 				E4E39AFB1330EFA8003AB274 /* LegacyTileLayerPool.h in Headers */,
 				512DD8F50D91E6AF000F89EE /* LegacyWebArchive.h in Headers */,
+				C4E657FC1A97FBED00479C15 /* InspectorStyleRule.h in Headers */,
 				BCE65BEB0EACDF16007E4533 /* Length.h in Headers */,
 				BCFF64910EAD15C200C1D6F7 /* LengthBox.h in Headers */,
 				E5BA7D63151437CA00FE1E3F /* LengthFunctions.h in Headers */,
 				F42FFB461984B71600F6837F /* LengthRepeat.h in Headers */,
 				BCFF64920EAD15C200C1D6F7 /* LengthSize.h in Headers */,
 				84730D911248F0B300D3A9C9 /* LightSource.h in Headers */,
 				B22279650D00BF220071B782 /* LinearGradientAttributes.h in Headers */,
 				A5ABB78713B904BC00F197E3 /* LineBreakIteratorPoolICU.h in Headers */,
 				AB31C91E10AE1B8E000C7B92 /* LineClampValue.h in Headers */,
 				89B5EAA211E8003D00F2367E /* LineEnding.h in Headers */,
@@ -26514,20 +26558,21 @@
 				436708FA12D9CA4B00044234 /* SVGResourcesCycleSolver.h in Headers */,
 				0854B0231255E4E600B9CDD0 /* SVGRootInlineBox.h in Headers */,
 				B2227AA30D00BF220071B782 /* SVGScriptElement.h in Headers */,
 				B2227AA60D00BF220071B782 /* SVGSetElement.h in Headers */,
 				E4AFD0100DAF335500F5F55C /* SVGSMILElement.h in Headers */,
 				0880F70E1282B46D00948505 /* SVGStaticListPropertyTearOff.h in Headers */,
 				0813A4EA1284132600992511 /* SVGStaticPropertyTearOff.h in Headers */,
 				B2227AA90D00BF220071B782 /* SVGStopElement.h in Headers */,
 				B2227AAC0D00BF220071B782 /* SVGStringList.h in Headers */,
 				B2227AB80D00BF220071B782 /* SVGStyleElement.h in Headers */,
+				C4E657F21A97F7A700479C15 /* InspectorCSSId.h in Headers */,
 				B2227ABB0D00BF220071B782 /* SVGSVGElement.h in Headers */,
 				D3F3D3681A69B1A50059FC2B /* JSWebGLRenderingContextBase.h in Headers */,
 				B2227ABE0D00BF220071B782 /* SVGSwitchElement.h in Headers */,
 				B2227AC10D00BF220071B782 /* SVGSymbolElement.h in Headers */,
 				B2227AC50D00BF220071B782 /* SVGTests.h in Headers */,
 				08F0BFC31255C53C00075185 /* SVGTextChunk.h in Headers */,
 				081668D4125603BF006F25DE /* SVGTextChunkBuilder.h in Headers */,
 				B2227AC80D00BF220071B782 /* SVGTextContentElement.h in Headers */,
 				B2227ACB0D00BF220071B782 /* SVGTextElement.h in Headers */,
 				08F0BFC41255C53C00075185 /* SVGTextFragment.h in Headers */,
@@ -26917,20 +26962,21 @@
 				BC772C470C4EB2C60083285F /* XMLHttpRequest.h in Headers */,
 				BC60D9C90D2A29E500B9918F /* XMLHttpRequestException.h in Headers */,
 				F9F0ED7A0DB50CA200D16DB9 /* XMLHttpRequestProgressEvent.h in Headers */,
 				A136A00D1134DBD200CC8D50 /* XMLHttpRequestProgressEventThrottle.h in Headers */,
 				BCDFD48E0E305290009D10AD /* XMLHttpRequestUpload.h in Headers */,
 				A833C80D0A2CF25600D57664 /* XMLNames.h in Headers */,
 				E15A36D71104572000B7B639 /* XMLNSNames.h in Headers */,
 				1ACE53EB0A8D18E70022947D /* XMLSerializer.h in Headers */,
 				5905ADC01302F3CE00F116DF /* XMLTreeViewer.h in Headers */,
 				1AB7FC690A8B92EC00D9D37B /* XPathEvaluator.h in Headers */,
+				C4E658001A97FBED00479C15 /* InspectorStylesheetRuleSet.h in Headers */,
 				BC60DA5B0D2A31F700B9918F /* XPathException.h in Headers */,
 				1AB7FC6C0A8B92EC00D9D37B /* XPathExpression.h in Headers */,
 				1AB7FC6F0A8B92EC00D9D37B /* XPathExpressionNode.h in Headers */,
 				1AB7FC710A8B92EC00D9D37B /* XPathFunctions.h in Headers */,
 				1A7629D60A07425100989F5B /* XPathGrammar.h in Headers */,
 				E1EC29A00BB04C6B00EA187B /* XPathNodeSet.h in Headers */,
 				1AB7FC760A8B92EC00D9D37B /* XPathNSResolver.h in Headers */,
 				1AB7FC790A8B92EC00D9D37B /* XPathParser.h in Headers */,
 				1AB7FC7B0A8B92EC00D9D37B /* XPathPath.h in Headers */,
 				1AB7FC7D0A8B92EC00D9D37B /* XPathPredicate.h in Headers */,
@@ -28085,20 +28131,21 @@
 				A8EA79FC0A1916DF00A8EF5F /* HTMLLIElement.cpp in Sources */,
 				A871DC210A15205700B12A68 /* HTMLLinkElement.cpp in Sources */,
 				A8EA7D320A19385500A8EF5F /* HTMLMapElement.cpp in Sources */,
 				A8EA7CAC0A192B9C00A8EF5F /* HTMLMarqueeElement.cpp in Sources */,
 				E44613A40CD6331000FADA75 /* HTMLMediaElement.cpp in Sources */,
 				0779BF0D18453168000B6AE7 /* HTMLMediaElementMediaStream.cpp in Sources */,
 				07FE99DC18807A7D00256648 /* HTMLMediaSession.cpp in Sources */,
 				A8EA79F80A1916DF00A8EF5F /* HTMLMenuElement.cpp in Sources */,
 				2BE8E2C912A58A0100FAD550 /* HTMLMetaCharsetParser.cpp in Sources */,
 				A871DC270A15205700B12A68 /* HTMLMetaElement.cpp in Sources */,
+				C4E658021A98016800479C15 /* InspectorStyleRule.cpp in Sources */,
 				A454424A119B3661009BE912 /* HTMLMeterElement.cpp in Sources */,
 				A8CFF7A90A156978000A4234 /* HTMLModElement.cpp in Sources */,
 				A8DF3FD5097FA0FC0052981B /* HTMLNameCollection.cpp in Sources */,
 				A8D06B3A0A265DCD005E7203 /* HTMLNames.cpp in Sources */,
 				A871D45B0A127CBC00B12A68 /* HTMLObjectElement.cpp in Sources */,
 				A8EA79FB0A1916DF00A8EF5F /* HTMLOListElement.cpp in Sources */,
 				A81369DF097374F600D74463 /* HTMLOptGroupElement.cpp in Sources */,
 				A81369DD097374F600D74463 /* HTMLOptionElement.cpp in Sources */,
 				9327A94209968D1A0068A546 /* HTMLOptionsCollection.cpp in Sources */,
 				4AD01008127E642A0015035F /* HTMLOutputElement.cpp in Sources */,
@@ -28247,21 +28294,20 @@
 				6F995A211A7078B100A735F4 /* WebGLSampler.cpp in Sources */,
 				20D629261253690B00081543 /* InspectorInstrumentation.cpp in Sources */,
 				A5840E1C187B74D500843B10 /* InspectorInstrumentationCookie.cpp in Sources */,
 				71B1E1261640491A00B1880A /* InspectorLayerTreeAgent.cpp in Sources */,
 				504AACCD1834455900E3D9BC /* InspectorNodeFinder.cpp in Sources */,
 				26F0C89B1A2EC110002794F8 /* ContentExtensionRule.cpp in Sources */,
 				7C522D4B15B477E8009B7C95 /* InspectorOverlay.cpp in Sources */,
 				4F6FDD641341DEDD001F8EE3 /* InspectorPageAgent.cpp in Sources */,
 				99CC0B6618BE9F15006CEBCC /* InspectorReplayAgent.cpp in Sources */,
 				82AB1775125C826700C5069D /* InspectorResourceAgent.cpp in Sources */,
-				82AB1773125C826700C5069D /* InspectorStyleSheet.cpp in Sources */,
 				754133AA102E00F400075D00 /* InspectorTimelineAgent.cpp in Sources */,
 				F3810C1B1365A49600ED6E33 /* InspectorWorkerAgent.cpp in Sources */,
 				F350B73513F1377D00880C43 /* InstrumentingAgents.cpp in Sources */,
 				2D46F04E17B96FBD005647F0 /* IntPoint.cpp in Sources */,
 				B27535600B053814002CE64F /* IntPointCG.cpp in Sources */,
 				B275357C0B053814002CE64F /* IntPointMac.mm in Sources */,
 				B27535730B053814002CE64F /* IntRect.cpp in Sources */,
 				B27535610B053814002CE64F /* IntRectCG.cpp in Sources */,
 				B275357D0B053814002CE64F /* IntRectMac.mm in Sources */,
 				2D46F05017B96FD2005647F0 /* IntSize.cpp in Sources */,
@@ -28562,20 +28608,21 @@
 				A7D0318E0E93540300E24ACD /* JSImageDataCustom.cpp in Sources */,
 				7A0E771E10C00DB100A0276E /* JSInspectorFrontendHost.cpp in Sources */,
 				7A74ECBD101839DA00BF939E /* JSInspectorFrontendHostCustom.cpp in Sources */,
 				A86629D409DA2B48009633A5 /* JSKeyboardEvent.cpp in Sources */,
 				935F45420F7C3B5F00D7C1FB /* JSLazyEventListener.cpp in Sources */,
 				BCE1C43B0D9830D3003B02F2 /* JSLocation.cpp in Sources */,
 				BCE1C4400D9830F4003B02F2 /* JSLocationCustom.cpp in Sources */,
 				8FAC774D119872CB0015AE94 /* JSMainThreadExecState.cpp in Sources */,
 				CD27F6E51457685A0078207D /* JSMediaController.cpp in Sources */,
 				CDAB6D2D17C814EE00C60B34 /* JSMediaControlsHost.cpp in Sources */,
+				C4E6580C1A9CCED500479C15 /* InspectorStyleProperty.cpp in Sources */,
 				FD23A12513F5FA5900F67001 /* JSMediaElementAudioSourceNode.cpp in Sources */,
 				E44614180CD6826900FADA75 /* JSMediaError.cpp in Sources */,
 				CDA98DA31601464100FEA3B1 /* JSMediaKeyError.cpp in Sources */,
 				CDB859FA160D494900E5B07F /* JSMediaKeyEvent.cpp in Sources */,
 				CDA98DDF16026A3700FEA3B1 /* JSMediaKeyMessageEvent.cpp in Sources */,
 				CDA98DE016026A3700FEA3B1 /* JSMediaKeyNeededEvent.cpp in Sources */,
 				CDA98E0416039E1A00FEA3B1 /* JSMediaKeys.cpp in Sources */,
 				CDA98E0616039E1F00FEA3B1 /* JSMediaKeySession.cpp in Sources */,
 				BC3C39B60C0D3D8D005F4D7A /* JSMediaList.cpp in Sources */,
 				D3A94A46122DC40F00A37BBC /* JSMediaQueryList.cpp in Sources */,
@@ -28931,20 +28978,21 @@
 				49C7B9A21042D2D30009D447 /* JSWebGLShader.cpp in Sources */,
 				A07D3355152B630E001B6393 /* JSWebGLShaderPrecisionFormat.cpp in Sources */,
 				49C7B9A41042D2D30009D447 /* JSWebGLTexture.cpp in Sources */,
 				0C45342710CDBBFA00869157 /* JSWebGLUniformLocation.cpp in Sources */,
 				77EF62F312F9DB7400C77BD2 /* JSWebGLVertexArrayObjectOES.cpp in Sources */,
 				31C0FF3D0E4CEFAC007D6FE5 /* JSWebKitAnimationEvent.cpp in Sources */,
 				310603741432819C00ABF4BA /* JSWebKitCSSFilterValue.cpp in Sources */,
 				316FE0710E6CCBEE00BF6088 /* JSCSSKeyframeRule.cpp in Sources */,
 				316FE0730E6CCBEE00BF6088 /* JSCSSKeyframesRule.cpp in Sources */,
 				4983913F0F1E767500C23782 /* JSWebKitCSSMatrix.cpp in Sources */,
+				C4E657FA1A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp in Sources */,
 				8AD0A59414C88336000D83C5 /* JSWebKitCSSRegionRule.cpp in Sources */,
 				31611E5A0E1C4DE000F6A579 /* JSWebKitCSSTransformValue.cpp in Sources */,
 				3F2B33EE165AF15600E3987C /* JSWebKitCSSViewportRule.cpp in Sources */,
 				D7613AC414753E5600DB8606 /* JSWebKitNamedFlow.cpp in Sources */,
 				7CC69940191EC5F500AF2270 /* JSWebKitNamespace.cpp in Sources */,
 				0FDA7C261883333200C954B5 /* JSWebKitPlaybackTargetAvailabilityEvent.cpp in Sources */,
 				494BD79D0F55C94C00747828 /* JSWebKitPoint.cpp in Sources */,
 				BC275B7911C5D1C300C9206C /* JSWebKitPointCustom.cpp in Sources */,
 				31C0FF3F0E4CEFAC007D6FE5 /* JSWebKitTransitionEvent.cpp in Sources */,
 				5DA5E0FC102B953800088CF9 /* JSWebSocket.cpp in Sources */,
@@ -29311,20 +29359,21 @@
 				BCEA486D097D93020094C9E4 /* RenderDeprecatedFlexibleBox.cpp in Sources */,
 				D302754912A5FE84004BD828 /* RenderDetailsMarker.cpp in Sources */,
 				9B32CDAA13DF7FA900F34D13 /* RenderedPosition.cpp in Sources */,
 				E43A023D17EB3713004CDD25 /* RenderElement.cpp in Sources */,
 				0F5B7A5410F65D7A00376302 /* RenderEmbeddedObject.cpp in Sources */,
 				A8EA73C30A1900E300A8EF5F /* RenderFieldset.cpp in Sources */,
 				066C77300AB603FD00238CC4 /* RenderFileUploadControl.cpp in Sources */,
 				53C8298D13D8D92700DE2DEB /* RenderFlexibleBox.cpp in Sources */,
 				508CCA5013CF106B003151F3 /* RenderFlowThread.cpp in Sources */,
 				A871DED40A1530C700B12A68 /* RenderFrame.cpp in Sources */,
+				C4E657FF1A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp in Sources */,
 				0FD3080E117CF7E700A791F7 /* RenderFrameBase.cpp in Sources */,
 				A871DED20A1530C700B12A68 /* RenderFrameSet.cpp in Sources */,
 				CDEA7C851276230400B846DD /* RenderFullScreen.cpp in Sources */,
 				0F3F0E59157030C3006DA57F /* RenderGeometryMap.cpp in Sources */,
 				BC128B01137C8D4600CAC845 /* RenderGrid.cpp in Sources */,
 				BCEA4869097D93020094C9E4 /* RenderHTMLCanvas.cpp in Sources */,
 				0FD308D5117D168500A791F7 /* RenderIFrame.cpp in Sources */,
 				BCEA4875097D93020094C9E4 /* RenderImage.cpp in Sources */,
 				08F2F0091213E61700DCEC48 /* RenderImageResource.cpp in Sources */,
 				08641D4712142F7D008DE9F6 /* RenderImageResourceStyleImage.cpp in Sources */,
@@ -29503,20 +29552,21 @@
 				0F09087F1444FDB200028917 /* ScrollbarTheme.cpp in Sources */,
 				BC14028A0E83680800319717 /* ScrollbarThemeComposite.cpp in Sources */,
 				44C991820F3D1E0D00586670 /* ScrollbarThemeIOS.mm in Sources */,
 				BCEF869F0E844E9D00A85CD5 /* ScrollbarThemeMac.mm in Sources */,
 				0FE71405142170B800DB33BA /* ScrollbarThemeMock.cpp in Sources */,
 				5D925B670F64D4DD00B847F0 /* ScrollBehavior.cpp in Sources */,
 				1AA84F04143BA7BD0051D153 /* ScrollController.mm in Sources */,
 				0F605AEC15F94848004DF0C0 /* ScrollingConstraints.cpp in Sources */,
 				1AF62EE714DA22A70041556C /* ScrollingCoordinator.cpp in Sources */,
 				0FC4E40E187F82E10045882C /* ScrollingCoordinatorIOS.mm in Sources */,
+				C4E6580F1A9D0D6900479C15 /* InspectorRuleSelector.cpp in Sources */,
 				1AF62EE614DA22A70041556C /* ScrollingCoordinatorMac.mm in Sources */,
 				93C38BFE164473C700091EB2 /* ScrollingStateFixedNode.cpp in Sources */,
 				0FEA3E7C191B2FC5000F1B55 /* ScrollingStateFrameScrollingNode.cpp in Sources */,
 				0FA88EBD16A8D1BD00F99984 /* ScrollingStateFrameScrollingNodeMac.mm in Sources */,
 				931CBD0C161A44E900E4C874 /* ScrollingStateNode.cpp in Sources */,
 				93EF7D551954F13900DFB71D /* ScrollingStateNode.mm in Sources */,
 				0FEA3E83191B31BF000F1B55 /* ScrollingStateOverflowScrollingNode.cpp in Sources */,
 				931CBD0E161A44E900E4C874 /* ScrollingStateScrollingNode.cpp in Sources */,
 				0FB8890E167D30160010CDA5 /* ScrollingStateStickyNode.cpp in Sources */,
 				931CBD10161A44E900E4C874 /* ScrollingStateTree.cpp in Sources */,
@@ -29655,20 +29705,21 @@
 				E4D58EB817B4ED8900CBDCA8 /* StyleFontSizeFunctions.cpp in Sources */,
 				BCEF447D0E674806001C1287 /* StyleGeneratedImage.cpp in Sources */,
 				A10DC76A14747BAB005E2471 /* StyleGridData.cpp in Sources */,
 				A110DB9D14F5DF8700A03B93 /* StyleGridItemData.cpp in Sources */,
 				BC2273030E82F1E600E7F975 /* StyleInheritedData.cpp in Sources */,
 				E47127CA163438A100ED6F5A /* StyleInvalidationAnalysis.cpp in Sources */,
 				BC5EB7290E81DE8100B25965 /* StyleMarqueeData.cpp in Sources */,
 				0FF50271102BA96A0066F39A /* StyleMedia.cpp in Sources */,
 				7C4EDD741A7B607800198C4D /* FontCocoa.mm in Sources */,
 				BC5EB74D0E81E06700B25965 /* StyleMultiColData.cpp in Sources */,
+				C4E658091A9CCE6D00479C15 /* InspectorStyleDeclaration.cpp in Sources */,
 				A80E6DFB0A199067007FB8C5 /* StyleProperties.cpp in Sources */,
 				E1B25106152A0BAF0069B779 /* StylePropertyShorthand.cpp in Sources */,
 				BC2272E30E82EE9B00E7F975 /* StyleRareInheritedData.cpp in Sources */,
 				BC2272BC0E82EAAE00E7F975 /* StyleRareNonInheritedData.cpp in Sources */,
 				E4D58EB417B4DBDC00CBDCA8 /* StyleResolveForDocument.cpp in Sources */,
 				E139866315478474001E3F65 /* StyleResolver.cpp in Sources */,
 				E4DEAA1717A93DC3000E0430 /* StyleResolveTree.cpp in Sources */,
 				E4BBED4C14FCDBA1003F0B98 /* StyleRule.cpp in Sources */,
 				E4946EAE156E64DD00D3297F /* StyleRuleImport.cpp in Sources */,
 				F47A5E3F195B8E4800483100 /* StyleScrollSnapPoints.cpp in Sources */,
@@ -29946,20 +29997,21 @@
 				FFAC30FF184FB145008C4F1E /* TrailingObjects.cpp in Sources */,
 				49E911C30EF86D47009D0CAF /* TransformationMatrix.cpp in Sources */,
 				494BC40D12AEDD9E00743BD2 /* TransformationMatrixCA.cpp in Sources */,
 				B27535580B053814002CE64F /* TransformationMatrixCG.cpp in Sources */,
 				FB484F4C171F821E00040755 /* TransformFunctions.cpp in Sources */,
 				49E911CF0EF86D47009D0CAF /* TransformOperations.cpp in Sources */,
 				5DB1BC6B10715A6400EFAA49 /* TransformSourceLibxslt.cpp in Sources */,
 				4198BDF01A81142200B22FB5 /* ReadableStreamJSSource.cpp in Sources */,
 				4945BFD313CF809000CC3B38 /* TransformState.cpp in Sources */,
 				E17B491516A9B094001C8839 /* TransitionEvent.cpp in Sources */,
+				C4E658041A984B5200479C15 /* InspectorStyleRuleSet.cpp in Sources */,
 				49E911D10EF86D47009D0CAF /* TranslateTransformOperation.cpp in Sources */,
 				854FE7360A2297BE0058D7AD /* Traversal.cpp in Sources */,
 				14D64B5C134A5B6B00E58FDA /* TreeScope.cpp in Sources */,
 				A77E1FEF14AACB6E005B7CB6 /* TreeScopeAdopter.cpp in Sources */,
 				854FE7380A2297BE0058D7AD /* TreeWalker.cpp in Sources */,
 				C375D7FD16639519006184AB /* TypeAhead.cpp in Sources */,
 				93309E19099E64920056E581 /* TypingCommand.cpp in Sources */,
 				85031B4D0A44EFC700F992E0 /* UIEvent.cpp in Sources */,
 				93354A3C0B24F8C9003F6DEA /* UIEventWithKeyState.cpp in Sources */,
 				AA4739D11757AFEC00E76767 /* UIRequestEvent.cpp in Sources */,
diff --git a/Source/WebCore/css/CSSComputedStyleDeclaration.h b/Source/WebCore/css/CSSComputedStyleDeclaration.h
index efdc157..42f291a 100644
--- a/Source/WebCore/css/CSSComputedStyleDeclaration.h
+++ b/Source/WebCore/css/CSSComputedStyleDeclaration.h
@@ -78,23 +78,23 @@ private:
     PassRefPtr<CSSValueList> getBackgroundShorthandValue() const;
     PassRefPtr<CSSValueList> getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&) const;
 
     RefPtr<Node> m_node;
     PseudoId m_pseudoElementSpecifier;
     bool m_allowVisitedStyle;
 };
 
 class CSSComputedStyleDeclaration final : public CSSStyleDeclaration {
 public:
-    static PassRefPtr<CSSComputedStyleDeclaration> create(PassRefPtr<Node> node, bool allowVisitedStyle = false, const String& pseudoElementName = String())
+    static Ref<CSSComputedStyleDeclaration> create(PassRefPtr<Node> node, bool allowVisitedStyle = false, const String& pseudoElementName = String())
     {
-        return adoptRef(new CSSComputedStyleDeclaration(node, allowVisitedStyle, pseudoElementName));
+        return adoptRef(*new CSSComputedStyleDeclaration(node, allowVisitedStyle, pseudoElementName));
     }
     virtual ~CSSComputedStyleDeclaration();
 
     WEBCORE_EXPORT virtual void ref() override;
     WEBCORE_EXPORT virtual void deref() override;
 
     String getPropertyValue(CSSPropertyID) const;
 
 private:
     WEBCORE_EXPORT CSSComputedStyleDeclaration(PassRefPtr<Node>, bool allowVisitedStyle, const String&);
diff --git a/Source/WebCore/css/CSSStyleSheet.h b/Source/WebCore/css/CSSStyleSheet.h
index d312eec..0daf21a 100644
--- a/Source/WebCore/css/CSSStyleSheet.h
+++ b/Source/WebCore/css/CSSStyleSheet.h
@@ -110,20 +110,21 @@ public:
 
     WhetherContentsWereClonedForMutation willMutateRules();
     void didMutateRules(RuleMutationType, WhetherContentsWereClonedForMutation, StyleRuleKeyframes* insertedKeyframesRule);
     void didMutateRuleFromCSSStyleDeclaration();
     void didMutate();
     
     void clearChildRuleCSSOMWrappers();
     void reattachChildRuleCSSOMWrappers();
 
     StyleSheetContents& contents() { return m_contents; }
+    const StyleSheetContents& contents() const { return m_contents; }
 
     void detachFromDocument() { m_ownerNode = nullptr; }
 
 private:
     CSSStyleSheet(Ref<StyleSheetContents>&&, CSSImportRule* ownerRule);
     CSSStyleSheet(Ref<StyleSheetContents>&&, Node* ownerNode, bool isInlineStylesheet);
 
     virtual bool isCSSStyleSheet() const override { return true; }
     virtual String type() const override { return ASCIILiteral("text/css"); }
 
diff --git a/Source/WebCore/inspector/InspectorCSSAgent.cpp b/Source/WebCore/inspector/InspectorCSSAgent.cpp
index 85321dd..a752f79 100644
--- a/Source/WebCore/inspector/InspectorCSSAgent.cpp
+++ b/Source/WebCore/inspector/InspectorCSSAgent.cpp
@@ -20,52 +20,61 @@
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "InspectorCSSAgent.h"
 
 #include "CSSComputedStyleDeclaration.h"
 #include "CSSImportRule.h"
+#include "CSSMediaRule.h"
+#include "CSSParser.h"
 #include "CSSPropertyNames.h"
 #include "CSSPropertySourceData.h"
 #include "CSSRule.h"
 #include "CSSRuleList.h"
 #include "CSSStyleRule.h"
 #include "CSSStyleSheet.h"
 #include "ContentSecurityPolicy.h"
 #include "DOMWindow.h"
 #include "ExceptionCodePlaceholder.h"
 #include "HTMLHeadElement.h"
 #include "HTMLStyleElement.h"
 #include "InspectorDOMAgent.h"
+#include "InspectorPageAgent.h"
 #include "InspectorHistory.h"
+#include "InspectorInlineStyleRuleSet.h"
+#include "InspectorInstrumentation.h"
+#include "InspectorStyleRule.h"
+#include "InspectorStyleProperty.h"
 #include "InstrumentingAgents.h"
 #include "NamedFlowCollection.h"
 #include "Node.h"
 #include "NodeList.h"
 #include "RenderNamedFlowFragment.h"
 #include "SVGStyleElement.h"
 #include "SelectorChecker.h"
 #include "StyleProperties.h"
 #include "StylePropertyShorthand.h"
 #include "StyleResolver.h"
 #include "StyleRule.h"
 #include "StyleSheetList.h"
+#include "StyleSheetContents.h"
 #include "WebKitNamedFlow.h"
+#include <inspector/ContentSearchUtilities.h>
 #include <inspector/InspectorProtocolObjects.h>
-#include <wtf/HashSet.h>
 #include <wtf/Ref.h>
 #include <wtf/Vector.h>
 #include <wtf/text/CString.h>
 #include <wtf/text/StringConcatenate.h>
+#include <wtf/NeverDestroyed.h>
 
 using namespace Inspector;
 
 namespace WebCore {
 
 enum ForcePseudoClassFlags {
     PseudoClassNone = 0,
     PseudoClassHover = 1 << 0,
     PseudoClassFocus = 1 << 1,
     PseudoClassActive = 1 << 2,
@@ -94,20 +103,31 @@ static unsigned computePseudoClassMask(InspectorArray* pseudoClassArray)
             result |= PseudoClassHover;
         else if (pseudoClass == focus)
             result |= PseudoClassFocus;
         else if (pseudoClass == visited)
             result |= PseudoClassVisited;
     }
 
     return result;
 }
 
+static Inspector::Protocol::CSS::StyleSheetOrigin stylesheetOriginToProtocolEnum(Inspector::StyleSheetOrigin origin);
+static Inspector::Protocol::CSS::CSSMedia::Source mediaListSourceToProtocolEnum(Inspector::MediaListSource source);
+
+static RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> buildObjectForStyleSheet(Inspector::StylesheetRuleSet&);
+static RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForStyleRule(Inspector::StyleRule& rule, Element* element);
+static Ref<Inspector::Protocol::CSS::SelectorList> buildObjectForSelectorList(Inspector::StyleRule&, WebCore::Element*);
+static RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyleWithProperties(Inspector::StyleDeclaration&);
+static Ref<Inspector::Protocol::CSS::CSSMedia> buildMediaObject(const MediaList& media, Inspector::MediaListSource mediaListSource, const String& sourceURL);
+static void fillMediaListChain(CSSRule& rule, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSMedia>& mediaArray);
+
+
 class ChangeRegionOversetTask {
 public:
     ChangeRegionOversetTask(InspectorCSSAgent*);
     void scheduleFor(WebKitNamedFlow*, int documentNodeId);
     void unschedule(WebKitNamedFlow*);
     void reset();
     void timerFired();
 
 private:
     InspectorCSSAgent* m_cssAgent;
@@ -142,212 +162,231 @@ void ChangeRegionOversetTask::reset()
 
 void ChangeRegionOversetTask::timerFired()
 {
     // The timer is stopped on m_cssAgent destruction, so this method will never be called after m_cssAgent has been destroyed.
     for (HashMap<WebKitNamedFlow*, int>::iterator it = m_namedFlows.begin(), end = m_namedFlows.end(); it != end; ++it)
         m_cssAgent->regionOversetChanged(it->key, it->value);
 
     m_namedFlows.clear();
 }
 
-class InspectorCSSAgent::StyleSheetAction : public InspectorHistory::Action {
-    WTF_MAKE_NONCOPYABLE(StyleSheetAction);
+class InspectorCSSAgent::StyleRuleSetAction : public InspectorHistory::Action {
+    WTF_MAKE_NONCOPYABLE(StyleRuleSetAction);
 public:
-    StyleSheetAction(const String& name, InspectorStyleSheet* styleSheet)
+    StyleRuleSetAction(const String& name, Ref<StyleRuleSet>&& ruleSet)
         : InspectorHistory::Action(name)
-        , m_styleSheet(styleSheet)
+        , m_ruleSet(WTF::move(ruleSet))
     {
     }
 
 protected:
-    RefPtr<InspectorStyleSheet> m_styleSheet;
+    Ref<StyleRuleSet> m_ruleSet;
 };
 
-class InspectorCSSAgent::SetStyleSheetTextAction final : public InspectorCSSAgent::StyleSheetAction {
+class InspectorCSSAgent::SetStyleSheetTextAction final : public InspectorCSSAgent::StyleRuleSetAction {
     WTF_MAKE_NONCOPYABLE(SetStyleSheetTextAction);
 public:
-    SetStyleSheetTextAction(InspectorStyleSheet* styleSheet, const String& text)
-        : InspectorCSSAgent::StyleSheetAction(ASCIILiteral("SetStyleSheetText"), styleSheet)
+    SetStyleSheetTextAction(Ref<StyleRuleSet>&& ruleSet, const String& text)
+        : InspectorCSSAgent::StyleRuleSetAction(ASCIILiteral("SetStyleSheetText"), WTF::move(ruleSet))
         , m_text(text)
     {
     }
 
     virtual bool perform(ExceptionCode& ec) override
     {
-        if (!m_styleSheet->getText(&m_oldText))
-            return false;
+        m_oldText = m_ruleSet->getText();
         return redo(ec);
     }
 
-    virtual bool undo(ExceptionCode& ec) override
+    virtual bool undo(ExceptionCode&) override
     {
-        if (m_styleSheet->setText(m_oldText, ec)) {
-            m_styleSheet->reparseStyleSheet(m_oldText);
-            return true;
-        }
-        return false;
+        m_ruleSet->replaceText(m_oldText);
+        return true;
     }
 
-    virtual bool redo(ExceptionCode& ec) override
+    virtual bool redo(ExceptionCode&) override
     {
-        if (m_styleSheet->setText(m_text, ec)) {
-            m_styleSheet->reparseStyleSheet(m_text);
-            return true;
-        }
-        return false;
+        m_ruleSet->replaceText(m_text);
+        return true;
     }
 
     virtual String mergeId() override
     {
-        return String::format("SetStyleSheetText %s", m_styleSheet->id().utf8().data());
+        return String::format("SetStyleSheetText %" PRIu64, m_ruleSet->identifier());
     }
 
-    virtual void merge(std::unique_ptr<Action> action) override
+    virtual void merge(std::unique_ptr<InspectorHistory::Action> action) override
     {
         ASSERT(action->mergeId() == mergeId());
 
         SetStyleSheetTextAction* other = static_cast<SetStyleSheetTextAction*>(action.get());
         m_text = other->m_text;
     }
 
 private:
     String m_text;
     String m_oldText;
 };
 
-class InspectorCSSAgent::SetStyleTextAction final : public InspectorCSSAgent::StyleSheetAction {
+class InspectorCSSAgent::SetStyleTextAction final : public InspectorCSSAgent::StyleRuleSetAction {
     WTF_MAKE_NONCOPYABLE(SetStyleTextAction);
 public:
-    SetStyleTextAction(InspectorStyleSheet* styleSheet, const InspectorCSSId& cssId, const String& text)
-        : InspectorCSSAgent::StyleSheetAction(ASCIILiteral("SetStyleText"), styleSheet)
+    SetStyleTextAction(Ref<StyleRuleSet>&& ruleSet, const CSSId& cssId, const String& text)
+        : InspectorCSSAgent::StyleRuleSetAction(ASCIILiteral("SetStyleText"), WTF::move(ruleSet))
         , m_cssId(cssId)
         , m_text(text)
     {
     }
 
     virtual bool perform(ExceptionCode& ec) override
     {
         return redo(ec);
     }
 
-    virtual bool undo(ExceptionCode& ec) override
+    virtual bool undo(ExceptionCode&) override
     {
-        return m_styleSheet->setStyleText(m_cssId, m_oldText, nullptr, ec);
+        bool success = true;
+        auto handler = [&] (StyleDeclaration& style) {
+            success &= style.setStyleText(m_oldText);
+        };
+        if (is<StylesheetRuleSet>(m_ruleSet))
+            downcast<StylesheetRuleSet>(m_ruleSet.get()).withStyleForId(m_cssId, handler);
+        if (is<InlineStyleRuleSet>(m_ruleSet))
+            downcast<InlineStyleRuleSet>(m_ruleSet.get()).withInlineStyle(handler);
+
+        return success;
     }
 
-    virtual bool redo(ExceptionCode& ec) override
+    virtual bool redo(ExceptionCode&) override
     {
-        return m_styleSheet->setStyleText(m_cssId, m_text, &m_oldText, ec);
+        bool success = true;
+        auto handler = [&] (StyleDeclaration& style) {
+            success &= style.getStyleText(m_oldText);
+            success &= style.setStyleText(m_text);
+        };
+        if (is<StylesheetRuleSet>(m_ruleSet))
+            downcast<StylesheetRuleSet>(m_ruleSet.get()).withStyleForId(m_cssId, handler);
+        if (is<InlineStyleRuleSet>(m_ruleSet))
+            downcast<InlineStyleRuleSet>(m_ruleSet.get()).withInlineStyle(handler);
+
+        return success;
     }
 
     virtual String mergeId() override
     {
-        ASSERT(m_styleSheet->id() == m_cssId.styleSheetId());
-        return String::format("SetStyleText %s:%u", m_styleSheet->id().utf8().data(), m_cssId.ordinal());
+        ASSERT(m_ruleSet->identifier() == m_cssId.stylesheetId());
+        return String::format("SetStyleText %llu:%llu", m_ruleSet->identifier(), m_cssId.ruleOrdinal());
     }
 
     virtual void merge(std::unique_ptr<Action> action) override
     {
         ASSERT(action->mergeId() == mergeId());
 
         SetStyleTextAction* other = static_cast<SetStyleTextAction*>(action.get());
         m_text = other->m_text;
     }
 
 private:
-    InspectorCSSId m_cssId;
+    CSSId m_cssId;
     String m_text;
     String m_oldText;
 };
 
-class InspectorCSSAgent::SetRuleSelectorAction final : public InspectorCSSAgent::StyleSheetAction {
+class InspectorCSSAgent::SetRuleSelectorAction final : public InspectorCSSAgent::StyleRuleSetAction {
     WTF_MAKE_NONCOPYABLE(SetRuleSelectorAction);
 public:
-    SetRuleSelectorAction(InspectorStyleSheet* styleSheet, const InspectorCSSId& cssId, const String& selector)
-        : InspectorCSSAgent::StyleSheetAction(ASCIILiteral("SetRuleSelector"), styleSheet)
+    SetRuleSelectorAction(Ref<StyleRuleSet>&& ruleSet, const CSSId& cssId, const String& selectorText)
+        : InspectorCSSAgent::StyleRuleSetAction(ASCIILiteral("SetRuleSelector"), WTF::move(ruleSet))
         , m_cssId(cssId)
-        , m_selector(selector)
+        , m_selectorText(selectorText)
     {
     }
 
     virtual bool perform(ExceptionCode& ec) override
     {
-        m_oldSelector = m_styleSheet->ruleSelector(m_cssId, ec);
-        if (ec)
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+
+        if (!downcast<StylesheetRuleSet>(m_ruleSet.get()).selectorTextForRule(m_cssId, m_oldSelectorText))
             return false;
+
         return redo(ec);
     }
 
-    virtual bool undo(ExceptionCode& ec) override
+    virtual bool undo(ExceptionCode&) override
     {
-        return m_styleSheet->setRuleSelector(m_cssId, m_oldSelector, ec);
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+
+        return downcast<StylesheetRuleSet>(m_ruleSet.get()).setSelectorTextForRule(m_cssId, m_oldSelectorText);
     }
 
-    virtual bool redo(ExceptionCode& ec) override
+    virtual bool redo(ExceptionCode&) override
     {
-        return m_styleSheet->setRuleSelector(m_cssId, m_selector, ec);
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+
+        return downcast<StylesheetRuleSet>(m_ruleSet.get()).setSelectorTextForRule(m_cssId, m_selectorText);
     }
 
 private:
-    InspectorCSSId m_cssId;
-    String m_selector;
-    String m_oldSelector;
+    CSSId m_cssId;
+    String m_selectorText;
+    String m_oldSelectorText;
 };
 
-class InspectorCSSAgent::AddRuleAction final : public InspectorCSSAgent::StyleSheetAction {
+class InspectorCSSAgent::AddRuleAction final : public InspectorCSSAgent::StyleRuleSetAction {
     WTF_MAKE_NONCOPYABLE(AddRuleAction);
 public:
-    AddRuleAction(InspectorStyleSheet* styleSheet, const String& selector)
-        : InspectorCSSAgent::StyleSheetAction(ASCIILiteral("AddRule"), styleSheet)
+    AddRuleAction(Ref<StyleRuleSet>&& ruleSet, const String& selector)
+        : InspectorCSSAgent::StyleRuleSetAction(ASCIILiteral("AddRule"), WTF::move(ruleSet))
         , m_selector(selector)
     {
     }
 
     virtual bool perform(ExceptionCode& ec) override
     {
         return redo(ec);
     }
 
     virtual bool undo(ExceptionCode& ec) override
     {
-        return m_styleSheet->deleteRule(m_newId, ec);
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+
+        return downcast<StylesheetRuleSet>(m_ruleSet.get()).deleteRule(m_newId, ec);
     }
 
     virtual bool redo(ExceptionCode& ec) override
     {
-        CSSStyleRule* cssStyleRule = m_styleSheet->addRule(m_selector, ec);
-        if (ec)
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+
+        StylesheetRuleSet& stylesheet = downcast<StylesheetRuleSet>(m_ruleSet.get());
+        CSSStyleRule* cssStyleRule = stylesheet.addRule(m_selector, ec);
+        if (ec || !cssStyleRule)
             return false;
-        m_newId = m_styleSheet->ruleId(cssStyleRule);
+        m_newId = stylesheet.idForStyle(cssStyleRule->style());
         return true;
     }
 
-    InspectorCSSId newRuleId() { return m_newId; }
+    CSSId newRuleId() { return m_newId; }
 
 private:
-    InspectorCSSId m_newId;
+    CSSId m_newId;
     String m_selector;
     String m_oldSelector;
 };
 
-// static
-CSSStyleRule* InspectorCSSAgent::asCSSStyleRule(CSSRule& rule)
-{
-    if (!is<CSSStyleRule>(rule))
-        return nullptr;
-    return downcast<CSSStyleRule>(&rule);
-}
-
 InspectorCSSAgent::InspectorCSSAgent(InstrumentingAgents* instrumentingAgents, InspectorDOMAgent* domAgent)
     : InspectorAgentBase(ASCIILiteral("CSS"), instrumentingAgents)
     , m_domAgent(domAgent)
-    , m_lastStyleSheetId(1)
 {
     m_domAgent->setDOMListener(this);
 }
 
 InspectorCSSAgent::~InspectorCSSAgent()
 {
     ASSERT(!m_domAgent);
     reset();
 }
 
@@ -366,24 +405,24 @@ void InspectorCSSAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReaso
 }
 
 void InspectorCSSAgent::discardAgent()
 {
     m_domAgent->setDOMListener(nullptr);
     m_domAgent = nullptr;
 }
 
 void InspectorCSSAgent::reset()
 {
-    m_idToInspectorStyleSheet.clear();
-    m_cssStyleSheetToInspectorStyleSheet.clear();
-    m_nodeToInspectorStyleSheet.clear();
-    m_documentToInspectorStyleSheet.clear();
+    m_identifierToRuleSetMap.clear();
+    m_cssStyleSheetToRuleSetMap.clear();
+    m_nodeToInlineRuleSetMap.clear();
+    m_documentToInspectorRuleSetMap.clear();
     resetNonPersistentData();
 }
 
 void InspectorCSSAgent::resetNonPersistentData()
 {
     m_namedFlowCollectionsRequested.clear();
     if (m_changeRegionOversetTask)
         m_changeRegionOversetTask->reset();
     resetPseudoStates();
 }
@@ -505,189 +544,235 @@ bool InspectorCSSAgent::forcePseudoState(Element& element, CSSSelector::PseudoCl
 
 void InspectorCSSAgent::getMatchedStylesForNode(ErrorString& errorString, int nodeId, const bool* includePseudo, const bool* includeInherited, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>>& matchedCSSRules, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::PseudoIdMatches>>& pseudoIdMatches, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::InheritedStyleEntry>>& inheritedEntries)
 {
     Element* element = elementForId(errorString, nodeId);
     if (!element)
         return;
 
     // Matched rules.
     StyleResolver& styleResolver = element->document().ensureStyleResolver();
     auto matchedRules = styleResolver.styleRulesForElement(element, StyleResolver::AllCSSRules);
-    matchedCSSRules = buildArrayForMatchedRuleList(matchedRules, styleResolver, element);
+    matchedCSSRules = buildArrayForMatchedRuleList(matchedRules, *element);
 
     // Pseudo elements.
     if (!includePseudo || *includePseudo) {
         auto pseudoElements = Inspector::Protocol::Array<Inspector::Protocol::CSS::PseudoIdMatches>::create();
         for (PseudoId pseudoId = FIRST_PUBLIC_PSEUDOID; pseudoId < AFTER_LAST_INTERNAL_PSEUDOID; pseudoId = static_cast<PseudoId>(pseudoId + 1)) {
             auto matchedRules = styleResolver.pseudoStyleRulesForElement(element, pseudoId, StyleResolver::AllCSSRules);
             if (!matchedRules.isEmpty()) {
                 auto matches = Inspector::Protocol::CSS::PseudoIdMatches::create()
                     .setPseudoId(static_cast<int>(pseudoId))
-                    .setMatches(buildArrayForMatchedRuleList(matchedRules, styleResolver, element))
+                    .setMatches(buildArrayForMatchedRuleList(matchedRules, *element))
                     .release();
                 pseudoElements->addItem(WTF::move(matches));
             }
         }
 
         pseudoIdMatches = WTF::move(pseudoElements);
     }
 
     // Inherited styles.
     if (!includeInherited || *includeInherited) {
         auto entries = Inspector::Protocol::Array<Inspector::Protocol::CSS::InheritedStyleEntry>::create();
         Element* parentElement = element->parentElement();
         while (parentElement) {
             StyleResolver& parentStyleResolver = parentElement->document().ensureStyleResolver();
             auto parentMatchedRules = parentStyleResolver.styleRulesForElement(parentElement, StyleResolver::AllCSSRules);
             auto entry = Inspector::Protocol::CSS::InheritedStyleEntry::create()
-                .setMatchedCSSRules(buildArrayForMatchedRuleList(parentMatchedRules, styleResolver, parentElement))
+                .setMatchedCSSRules(buildArrayForMatchedRuleList(parentMatchedRules, *parentElement))
                 .release();
-            if (parentElement->style() && parentElement->style()->length()) {
-                InspectorStyleSheetForInlineStyle* styleSheet = asInspectorStyleSheet(parentElement);
-                if (styleSheet)
-                    entry->setInlineStyle(styleSheet->buildObjectForStyle(styleSheet->styleForId(InspectorCSSId(styleSheet->id(), 0))));
+
+            if (is<StyledElement>(parentElement)) {
+                InlineStyleRuleSet& ruleSet = ruleSetForInlineStyle(downcast<StyledElement>(*parentElement));
+                ruleSet.withInlineStyle([&] (Inspector::StyleDeclaration& style) {
+                    entry->setInlineStyle(buildObjectForStyle(style));
+                });
             }
 
             entries->addItem(WTF::move(entry));
             parentElement = parentElement->parentElement();
         }
 
         inheritedEntries = WTF::move(entries);
     }
 }
 
-void InspectorCSSAgent::getInlineStylesForNode(ErrorString& errorString, int nodeId, RefPtr<Inspector::Protocol::CSS::CSSStyle>& inlineStyle, RefPtr<Inspector::Protocol::CSS::CSSStyle>& attributesStyle)
+void InspectorCSSAgent::getInlineStylesForNode(ErrorString& errorString, int nodeId, RefPtr<Inspector::Protocol::CSS::CSSStyle>& inlineStyleObject, RefPtr<Inspector::Protocol::CSS::CSSStyle>& attributesStyleObject)
 {
     Element* element = elementForId(errorString, nodeId);
-    if (!element)
+    if (!is<StyledElement>(element))
         return;
 
-    InspectorStyleSheetForInlineStyle* styleSheet = asInspectorStyleSheet(element);
-    if (!styleSheet)
-        return;
+    InlineStyleRuleSet& ruleSet = ruleSetForInlineStyle(downcast<StyledElement>(*element));
+    ruleSet.withInlineStyle([&] (Inspector::StyleDeclaration& style) {
+        inlineStyleObject = buildObjectForStyle(style);
+    });
 
-    inlineStyle = styleSheet->buildObjectForStyle(element->style());
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> attributes = buildObjectForAttributesStyle(element);
-    attributesStyle = attributes ? attributes.release() : nullptr;
+    ruleSet.withAttributeStyle([&] (Inspector::StyleDeclaration& style) {
+        attributesStyleObject = buildObjectForStyle(style);
+    });
 }
 
-void InspectorCSSAgent::getComputedStyleForNode(ErrorString& errorString, int nodeId, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>>& style)
+struct CollectComputedStylePropertiesFunctor {
+    typedef RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> ReturnType;
+
+    CollectComputedStylePropertiesFunctor()
+    : m_propertiesArray(Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>::create())
+    {
+    }
+
+    void operator()(const StyleProperty& property)
+    {
+        auto propertyObject = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
+        .setName(property.propertyName())
+        .setValue(property.propertyValue())
+        .release();
+
+        m_propertiesArray->addItem(WTF::move(propertyObject));
+    }
+
+    ReturnType returnValue() { return WTF::move(m_propertiesArray); }
+private:
+    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> m_propertiesArray;
+};
+
+void InspectorCSSAgent::getComputedStyleForNode(ErrorString& errorString, int nodeId, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>>& result)
 {
     Element* element = elementForId(errorString, nodeId);
     if (!element)
         return;
 
-    RefPtr<CSSComputedStyleDeclaration> computedStyleInfo = CSSComputedStyleDeclaration::create(element, true);
-    Ref<InspectorStyle> inspectorStyle = InspectorStyle::create(InspectorCSSId(), computedStyleInfo, nullptr);
-    style = inspectorStyle->buildArrayForComputedStyle();
+    Ref<CSSComputedStyleDeclaration> computedStyle = CSSComputedStyleDeclaration::create(element, true);
+    Inspector::StyleDeclaration style(CSSId(), computedStyle.get(), nullptr);
+
+    CollectComputedStylePropertiesFunctor collectComputedProperties;
+    result = style.forEachProperty(collectComputedProperties);
 }
 
 void InspectorCSSAgent::getAllStyleSheets(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>>& styleInfos)
 {
     styleInfos = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>::create();
     Vector<Document*> documents = m_domAgent->documents();
     for (Vector<Document*>::iterator it = documents.begin(); it != documents.end(); ++it) {
         StyleSheetList& list = (*it)->styleSheets();
         for (unsigned i = 0; i < list.length(); ++i) {
             StyleSheet& styleSheet = *list.item(i);
             if (is<CSSStyleSheet>(styleSheet))
-                collectStyleSheets(&downcast<CSSStyleSheet>(styleSheet), styleInfos.get());
+                collectStyleSheets(downcast<CSSStyleSheet>(styleSheet), *styleInfos);
         }
     }
 }
 
-void InspectorCSSAgent::getStyleSheet(ErrorString& errorString, const String& styleSheetId, RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody>& styleSheetObject)
+void InspectorCSSAgent::getStyleSheet(ErrorString& errorString, Inspector::Protocol::CSS::StyleSheetId stylesheetId, RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody>& styleSheetObject)
 {
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, stylesheetId);
+    if (!is<StylesheetRuleSet>(ruleSet))
         return;
 
-    styleSheetObject = inspectorStyleSheet->buildObjectForStyleSheet();
+    styleSheetObject = buildObjectForStyleSheet(downcast<StylesheetRuleSet>(*ruleSet));
 }
 
-void InspectorCSSAgent::getStyleSheetText(ErrorString& errorString, const String& styleSheetId, String* result)
+void InspectorCSSAgent::getStyleSheetText(ErrorString& errorString, Inspector::Protocol::CSS::StyleSheetId stylesheetId, String* result)
 {
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, stylesheetId);
+    if (!is<StylesheetRuleSet>(ruleSet))
         return;
 
-    inspectorStyleSheet->getText(result);
+    *result = ruleSet->getText();
 }
 
-void InspectorCSSAgent::setStyleSheetText(ErrorString& errorString, const String& styleSheetId, const String& text)
+void InspectorCSSAgent::setStyleSheetText(ErrorString& errorString, Inspector::Protocol::CSS::StyleSheetId stylesheetId, const String& text)
 {
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, stylesheetId);
+    if (!ruleSet)
         return;
 
     ExceptionCode ec = 0;
-    m_domAgent->history()->perform(std::make_unique<SetStyleSheetTextAction>(inspectorStyleSheet, text), ec);
+    m_domAgent->history()->perform(std::make_unique<SetStyleSheetTextAction>(*ruleSet, text), ec);
     errorString = InspectorDOMAgent::toErrorString(ec);
 }
 
-void InspectorCSSAgent::setStyleText(ErrorString& errorString, const RefPtr<InspectorObject>&& fullStyleId, const String& text, RefPtr<Inspector::Protocol::CSS::CSSStyle>& result)
+void InspectorCSSAgent::setStyleText(ErrorString& errorString, const RefPtr<InspectorObject>&& styleIdObject, const String& text, RefPtr<Inspector::Protocol::CSS::CSSStyle>& result)
 {
-    InspectorCSSId compoundId(fullStyleId.copyRef());
-    ASSERT(!compoundId.isEmpty());
+    CSSId styleId(styleIdObject.copyRef());
+    ASSERT(!styleId.isEmpty());
 
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, compoundId.styleSheetId());
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, styleId.stylesheetId());
+    if (!ruleSet)
         return;
 
     ExceptionCode ec = 0;
-    bool success = m_domAgent->history()->perform(std::make_unique<SetStyleTextAction>(inspectorStyleSheet, compoundId, text), ec);
-    if (success)
-        result = inspectorStyleSheet->buildObjectForStyle(inspectorStyleSheet->styleForId(compoundId));
-    errorString = InspectorDOMAgent::toErrorString(ec);
+    bool success = m_domAgent->history()->perform(std::make_unique<SetStyleTextAction>(*ruleSet, styleId, text), ec);
+    if (!success) {
+        errorString = InspectorDOMAgent::toErrorString(ec);
+        return;
+    }
+    if (is<StylesheetRuleSet>(ruleSet)) {
+        downcast<StylesheetRuleSet>(ruleSet)->withStyleForId(styleId, [&result] (StyleDeclaration& style) {
+            result = buildObjectForStyle(style);
+        });
+    }
+
+    if (is<InlineStyleRuleSet>(ruleSet)) {
+        downcast<InlineStyleRuleSet>(ruleSet)->withInlineStyle([&result] (StyleDeclaration& style) {
+            result = buildObjectForStyle(style);
+        });
+    }
 }
 
-void InspectorCSSAgent::setRuleSelector(ErrorString& errorString, const RefPtr<InspectorObject>&& fullRuleId, const String& selector, RefPtr<Inspector::Protocol::CSS::CSSRule>& result)
+void InspectorCSSAgent::setRuleSelector(ErrorString& errorString, const RefPtr<InspectorObject>&& ruleIdObject, const String& selectorText, RefPtr<Inspector::Protocol::CSS::CSSRule>& result)
 {
-    InspectorCSSId compoundId(fullRuleId.copyRef());
-    ASSERT(!compoundId.isEmpty());
+    CSSId ruleId(ruleIdObject.copyRef());
+    ASSERT(!ruleId.isEmpty());
 
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, compoundId.styleSheetId());
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, ruleId.stylesheetId());
+    if (!is<StylesheetRuleSet>(ruleSet))
         return;
 
+    StylesheetRuleSet& stylesheet = downcast<StylesheetRuleSet>(*ruleSet);
+
     ExceptionCode ec = 0;
-    bool success = m_domAgent->history()->perform(std::make_unique<SetRuleSelectorAction>(inspectorStyleSheet, compoundId, selector), ec);
+    bool success = m_domAgent->history()->perform(std::make_unique<SetRuleSelectorAction>(stylesheet, ruleId, selectorText), ec);
+    if (!success) {
+        errorString = InspectorDOMAgent::toErrorString(ec);
+        return;
+    }
 
-    if (success)
-        result = inspectorStyleSheet->buildObjectForRule(inspectorStyleSheet->ruleForId(compoundId), nullptr);
-    errorString = InspectorDOMAgent::toErrorString(ec);
+    stylesheet.withRuleForId(ruleId, [&] (Inspector::StyleRule& rule) {
+        result = buildObjectForStyleRule(rule, nullptr);
+    });
 }
 
-void InspectorCSSAgent::addRule(ErrorString& errorString, const int contextNodeId, const String& selector, RefPtr<Inspector::Protocol::CSS::CSSRule>& result)
+void InspectorCSSAgent::addRule(ErrorString& errorString, const int contextNodeId, const String& selectorText, RefPtr<Inspector::Protocol::CSS::CSSRule>& result)
 {
     Node* node = m_domAgent->assertNode(errorString, contextNodeId);
     if (!node)
         return;
 
-    InspectorStyleSheet* inspectorStyleSheet = viaInspectorStyleSheet(&node->document(), true);
-    if (!inspectorStyleSheet) {
+    StylesheetRuleSet* stylesheet = inspectorRuleSetForDocument(node->document(), true);
+    if (!stylesheet) {
         errorString = ASCIILiteral("No target stylesheet found");
         return;
     }
 
     ExceptionCode ec = 0;
-    auto action = std::make_unique<AddRuleAction>(inspectorStyleSheet, selector);
+    auto action = std::make_unique<AddRuleAction>(*stylesheet, selectorText);
     AddRuleAction* rawAction = action.get();
     bool success = m_domAgent->history()->perform(WTF::move(action), ec);
     if (!success) {
         errorString = InspectorDOMAgent::toErrorString(ec);
         return;
     }
 
-    InspectorCSSId ruleId = rawAction->newRuleId();
-    CSSStyleRule* rule = inspectorStyleSheet->ruleForId(ruleId);
-    result = inspectorStyleSheet->buildObjectForRule(rule, nullptr);
+    stylesheet->withRuleForId(rawAction->newRuleId(), [&] (Inspector::StyleRule& rule) {
+        result = buildObjectForStyleRule(rule, nullptr);
+    });
 }
 
 void InspectorCSSAgent::getSupportedCSSProperties(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSPropertyInfo>>& cssProperties)
 {
     auto properties = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSPropertyInfo>::create();
     for (int i = firstCSSProperty; i <= lastCSSProperty; ++i) {
         CSSPropertyID id = convertToCSSPropertyID(i);
         auto property = Inspector::Protocol::CSS::CSSPropertyInfo::create()
             .setName(getPropertyNameString(id))
             .release();
@@ -738,36 +823,30 @@ void InspectorCSSAgent::getNamedFlowCollection(ErrorString& errorString, int doc
 
     Vector<RefPtr<WebKitNamedFlow>> namedFlowsVector = document->namedFlows().namedFlows();
     auto namedFlows = Inspector::Protocol::Array<Inspector::Protocol::CSS::NamedFlow>::create();
 
     for (Vector<RefPtr<WebKitNamedFlow>>::iterator it = namedFlowsVector.begin(); it != namedFlowsVector.end(); ++it)
         namedFlows->addItem(buildObjectForNamedFlow(errorString, it->get(), documentNodeId));
 
     result = WTF::move(namedFlows);
 }
 
-InspectorStyleSheetForInlineStyle* InspectorCSSAgent::asInspectorStyleSheet(Element* element)
+InlineStyleRuleSet& InspectorCSSAgent::ruleSetForInlineStyle(Element& element)
 {
-    NodeToInspectorStyleSheet::iterator it = m_nodeToInspectorStyleSheet.find(element);
-    if (it == m_nodeToInspectorStyleSheet.end()) {
-        CSSStyleDeclaration* style = element->isStyledElement() ? element->style() : nullptr;
-        if (!style)
-            return nullptr;
-
-        String newStyleSheetId = String::number(m_lastStyleSheetId++);
-        RefPtr<InspectorStyleSheetForInlineStyle> inspectorStyleSheet = InspectorStyleSheetForInlineStyle::create(m_domAgent->pageAgent(), newStyleSheetId, element, Inspector::Protocol::CSS::StyleSheetOrigin::Regular, this);
-        m_idToInspectorStyleSheet.set(newStyleSheetId, inspectorStyleSheet);
-        m_nodeToInspectorStyleSheet.set(element, inspectorStyleSheet);
-        return inspectorStyleSheet.get();
-    }
-
-    return it->value.get();
+    auto findResult = m_nodeToInlineRuleSetMap.find(&element);
+    if (findResult != m_nodeToInlineRuleSetMap.end())
+        return *findResult->value;
+
+    RefPtr<InlineStyleRuleSet> inlineStyle = InlineStyleRuleSet::create(element);
+    m_identifierToRuleSetMap.set(inlineStyle->identifier(), inlineStyle);
+    m_nodeToInlineRuleSetMap.set(&element, inlineStyle);
+    return *inlineStyle;
 }
 
 Element* InspectorCSSAgent::elementForId(ErrorString& errorString, int nodeId)
 {
     Node* node = m_domAgent->nodeForId(nodeId);
     if (!node) {
         errorString = ASCIILiteral("No node with given id found");
         return nullptr;
     }
     if (!is<Element>(*node)) {
@@ -779,195 +858,502 @@ Element* InspectorCSSAgent::elementForId(ErrorString& errorString, int nodeId)
 
 int InspectorCSSAgent::documentNodeWithRequestedFlowsId(Document* document)
 {
     int documentNodeId = m_domAgent->boundNodeId(document);
     if (!documentNodeId || !m_namedFlowCollectionsRequested.contains(documentNodeId))
         return 0;
 
     return documentNodeId;
 }
 
-void InspectorCSSAgent::collectStyleSheets(CSSStyleSheet* styleSheet, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>* result)
+static Ref<Inspector::Protocol::CSS::CSSStyleSheetHeader> buildObjectForStyleSheetInfo(StylesheetRuleSet& stylesheet)
 {
-    InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(styleSheet);
-    result->addItem(inspectorStyleSheet->buildObjectForStyleSheetInfo());
-    for (unsigned i = 0, size = styleSheet->length(); i < size; ++i) {
-        CSSRule* rule = styleSheet->item(i);
-        if (is<CSSImportRule>(*rule)) {
-            if (CSSStyleSheet* importedStyleSheet = downcast<CSSImportRule>(*rule).styleSheet())
-                collectStyleSheets(importedStyleSheet, result);
-        }
-    }
+    String frameId = ASCIILiteral("(Unknown)");
+    Document* document = stylesheet.ownerDocument();
+    Frame* frame = document ? document->frame() : nullptr;
+    if (InstrumentingAgents* instrumentingAgents = InspectorInstrumentation::instrumentingAgentsForFrame(frame))
+        if (InspectorPageAgent* pageAgent = instrumentingAgents->inspectorPageAgent())
+            frameId = pageAgent->frameId(frame);
+
+    return Inspector::Protocol::CSS::CSSStyleSheetHeader::create()
+        .setStyleSheetId(stylesheet.identifier())
+        .setOrigin(stylesheetOriginToProtocolEnum(stylesheet.origin()))
+        .setDisabled(!stylesheet.isEnabled())
+        .setSourceURL(stylesheet.finalURL())
+        .setTitle(stylesheet.title())
+        .setFrameId(frameId)
+        .release();
 }
 
-InspectorStyleSheet* InspectorCSSAgent::bindStyleSheet(CSSStyleSheet* styleSheet)
+void InspectorCSSAgent::collectStyleSheets(CSSStyleSheet& stylesheet, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>& result)
 {
-    RefPtr<InspectorStyleSheet> inspectorStyleSheet = m_cssStyleSheetToInspectorStyleSheet.get(styleSheet);
-    if (!inspectorStyleSheet) {
-        String id = String::number(m_lastStyleSheetId++);
-        Document* document = styleSheet->ownerDocument();
-        inspectorStyleSheet = InspectorStyleSheet::create(m_domAgent->pageAgent(), id, styleSheet, detectOrigin(styleSheet, document), InspectorDOMAgent::documentURLString(document), this);
-        m_idToInspectorStyleSheet.set(id, inspectorStyleSheet);
-        m_cssStyleSheetToInspectorStyleSheet.set(styleSheet, inspectorStyleSheet);
+    StylesheetRuleSet& ruleSet = ruleSetForStyleSheet(stylesheet);
+    result.addItem(buildObjectForStyleSheetInfo(ruleSet));
+
+    for (unsigned i = 0, size = stylesheet.length(); i < size; ++i) {
+        CSSRule* rule = stylesheet.item(i);
+        if (!is<CSSImportRule>(rule))
+            continue;
+
+        if (CSSStyleSheet* importedStylesheet = downcast<CSSImportRule>(*rule).styleSheet())
+            collectStyleSheets(*importedStylesheet, result);
     }
-    return inspectorStyleSheet.get();
 }
 
-InspectorStyleSheet* InspectorCSSAgent::viaInspectorStyleSheet(Document* document, bool createIfAbsent)
+StylesheetRuleSet& InspectorCSSAgent::ruleSetForStyleSheet(CSSStyleSheet& stylesheet)
 {
-    if (!document) {
-        ASSERT(!createIfAbsent);
-        return nullptr;
-    }
+    auto findResult = m_cssStyleSheetToRuleSetMap.find(&stylesheet);
+    if (findResult != m_cssStyleSheetToRuleSetMap.end())
+        return *findResult->value;
 
-    if (!document->isHTMLDocument() && !document->isSVGDocument())
+    StyleSheetOrigin origin = StyleSheetOrigin::Author;
+    Node* ownerNode = stylesheet.ownerNode();
+    if (!ownerNode && stylesheet.href().isEmpty())
+        origin = StyleSheetOrigin::UserAgent;
+
+    if (ownerNode && ownerNode->nodeName() == "#document")
+        origin = StyleSheetOrigin::User;
+
+    RefPtr<StylesheetRuleSet> ruleSet = StylesheetRuleSet::create(stylesheet, origin, InspectorDOMAgent::documentURLString(stylesheet.ownerDocument()), this);
+    m_identifierToRuleSetMap.set(ruleSet->identifier(), ruleSet);
+    m_cssStyleSheetToRuleSetMap.set(&stylesheet, ruleSet);
+
+    return *ruleSet;
+}
+
+StylesheetRuleSet* InspectorCSSAgent::inspectorRuleSetForDocument(Document& document, bool createIfAbsent)
+{
+    if (!document.isHTMLDocument() && !document.isSVGDocument())
         return nullptr;
 
-    RefPtr<InspectorStyleSheet> inspectorStyleSheet = m_documentToInspectorStyleSheet.get(document);
-    if (inspectorStyleSheet || !createIfAbsent)
-        return inspectorStyleSheet.get();
+    RefPtr<StylesheetRuleSet> ruleSet = m_documentToInspectorRuleSetMap.get(&document);
+    if (ruleSet || !createIfAbsent)
+        return ruleSet.get();
 
     ExceptionCode ec = 0;
-    RefPtr<Element> styleElement = document->createElement("style", ec);
+    RefPtr<Element> styleElement = document.createElement("style", ec);
     if (!ec)
         styleElement->setAttribute("type", "text/css", ec);
     if (!ec) {
         ContainerNode* targetNode;
         // HEAD is absent in ImageDocuments, for example.
-        if (auto* head = document->head())
+        if (auto* head = document.head())
             targetNode = head;
-        else if (auto* body = document->bodyOrFrameset())
+        else if (auto* body = document.bodyOrFrameset())
             targetNode = body;
         else
             return nullptr;
 
-        InlineStyleOverrideScope overrideScope(document);
+        InlineStyleOverrideScope overrideScope(&document);
         targetNode->appendChild(styleElement, ec);
     }
     if (ec)
         return nullptr;
 
-    CSSStyleSheet* cssStyleSheet = nullptr;
+    CSSStyleSheet* stylesheet = nullptr;
     if (styleElement->isHTMLElement())
-        cssStyleSheet = downcast<HTMLStyleElement>(*styleElement).sheet();
+        stylesheet = downcast<HTMLStyleElement>(*styleElement).sheet();
     else if (styleElement->isSVGElement())
-        cssStyleSheet = downcast<SVGStyleElement>(*styleElement).sheet();
+        stylesheet = downcast<SVGStyleElement>(*styleElement).sheet();
 
-    if (!cssStyleSheet)
+    if (!stylesheet)
         return nullptr;
 
-    String id = String::number(m_lastStyleSheetId++);
-    inspectorStyleSheet = InspectorStyleSheet::create(m_domAgent->pageAgent(), id, cssStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin::Inspector, InspectorDOMAgent::documentURLString(document), this);
-    m_idToInspectorStyleSheet.set(id, inspectorStyleSheet);
-    m_cssStyleSheetToInspectorStyleSheet.set(cssStyleSheet, inspectorStyleSheet);
-    m_documentToInspectorStyleSheet.set(document, inspectorStyleSheet);
-    return inspectorStyleSheet.get();
+    RefPtr<StylesheetRuleSet> newRuleSet = StylesheetRuleSet::create(*stylesheet, StyleSheetOrigin::Inspector, InspectorDOMAgent::documentURLString(&document), this);
+    m_identifierToRuleSetMap.set(newRuleSet->identifier(), newRuleSet);
+    m_cssStyleSheetToRuleSetMap.set(stylesheet, newRuleSet);
+    m_documentToInspectorRuleSetMap.set(&document, newRuleSet);
+    return newRuleSet.get();
 }
 
-InspectorStyleSheet* InspectorCSSAgent::assertStyleSheetForId(ErrorString& errorString, const String& styleSheetId)
+StyleRuleSet* InspectorCSSAgent::ruleSetForStylesheetId(ErrorString& errorString, Inspector::Protocol::CSS::StyleSheetId stylesheetId)
 {
-    IdToInspectorStyleSheet::iterator it = m_idToInspectorStyleSheet.find(styleSheetId);
-    if (it == m_idToInspectorStyleSheet.end()) {
-        errorString = ASCIILiteral("No style sheet with given id found");
+    if (stylesheetId <= 0) {
+        errorString = ASCIILiteral("Invalid identifier for stylesheet.");
+        return nullptr;
+    }
+
+    uint64_t key = static_cast<uint64_t>(stylesheetId);
+    auto findResult = m_identifierToRuleSetMap.find(key);
+    if (findResult == m_identifierToRuleSetMap.end()) {
+        errorString = ASCIILiteral("No stylesheet with given id found");
         return nullptr;
     }
-    return it->value.get();
+    return findResult->value.get();
 }
 
-Inspector::Protocol::CSS::StyleSheetOrigin InspectorCSSAgent::detectOrigin(CSSStyleSheet* pageStyleSheet, Document* ownerDocument)
+void InspectorCSSAgent::withWrappedRule(WebCore::StyleRule& styleRule, Document& ownerDocument, const std::function<void(Inspector::StyleRule&)>& callback)
 {
-    auto origin = Inspector::Protocol::CSS::StyleSheetOrigin::Regular;
-    if (pageStyleSheet && !pageStyleSheet->ownerNode() && pageStyleSheet->href().isEmpty())
-        origin = Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent;
-    else if (pageStyleSheet && pageStyleSheet->ownerNode() && pageStyleSheet->ownerNode()->nodeName() == "#document")
-        origin = Inspector::Protocol::CSS::StyleSheetOrigin::User;
-    else {
-        InspectorStyleSheet* viaInspectorStyleSheetForOwner = viaInspectorStyleSheet(ownerDocument, false);
-        if (viaInspectorStyleSheetForOwner && pageStyleSheet == viaInspectorStyleSheetForOwner->pageStyleSheet())
-            origin = Inspector::Protocol::CSS::StyleSheetOrigin::Inspector;
+    // Webcore::StyleRules (i.e., returned from StyleResolver::styleRulesForElement) lack parent pointers.
+    // The inspector wants to walk up the rule tree and use CSSOM, so construct the full wrappers here.
+    // NOTE: it is expensive for the style system to maintain these wrappers, so it's done lazily.
+    StyleResolver& styleResolver = ownerDocument.ensureStyleResolver();
+    CSSStyleRule* cssomWrapper = styleResolver.inspectorCSSOMWrappers().getWrapperForRuleInSheets(&styleRule, styleResolver.document().styleSheetCollection());
+    if (!cssomWrapper || !cssomWrapper->parentStyleSheet())
+        return;
+
+    // Force the stylesheet to bind so that the rule is assigned a CSSId.
+    StylesheetRuleSet& stylesheet = ruleSetForStyleSheet(*cssomWrapper->parentStyleSheet());
+    CSSId identifier = stylesheet.idForStyle(cssomWrapper->style());
+    stylesheet.withRuleForId(identifier, callback);
+}
+
+void InspectorCSSAgent::withWrappedStyle(CSSStyleDeclaration& style, const std::function<void(Inspector::StyleDeclaration&)>& callback)
+{
+    if (style.parentElement()) {
+        // Force the parent element to bind so we can use its wrapper.
+        InlineStyleRuleSet& ruleSet = ruleSetForInlineStyle(*style.parentElement());
+        ruleSet.withInlineStyle(callback);
+    } else if (style.parentStyleSheet()) {
+        // Force the parent stylesheet to bind so that the style is assigned a CSSId.
+        StylesheetRuleSet& stylesheet = ruleSetForStyleSheet(*style.parentStyleSheet());
+        CSSId identifier = stylesheet.idForStyle(style);
+        stylesheet.withStyleForId(identifier, callback);
     }
-    return origin;
 }
 
-RefPtr<Inspector::Protocol::CSS::CSSRule> InspectorCSSAgent::buildObjectForRule(StyleRule* styleRule, StyleResolver& styleResolver, Element* element)
+void InspectorCSSAgent::didRemoveDocument(Document* document)
 {
-    if (!styleRule)
-        return nullptr;
+    if (document)
+        m_documentToInspectorRuleSetMap.remove(document);
+}
 
-    // StyleRules returned by StyleResolver::styleRulesForElement lack parent pointers since that infomation is not cheaply available.
-    // Since the inspector wants to walk the parent chain, we construct the full wrappers here.
-    CSSStyleRule* cssomWrapper = styleResolver.inspectorCSSOMWrappers().getWrapperForRuleInSheets(styleRule, styleResolver.document().styleSheetCollection());
-    if (!cssomWrapper)
-        return nullptr;
-    InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(cssomWrapper->parentStyleSheet());
-    return inspectorStyleSheet ? inspectorStyleSheet->buildObjectForRule(cssomWrapper, element) : nullptr;
+void InspectorCSSAgent::didRemoveDOMNode(Node* node)
+{
+    if (!node)
+        return;
+
+    int nodeId = m_domAgent->boundNodeId(node);
+    if (nodeId)
+        m_nodeIdToForcedPseudoState.remove(nodeId);
+
+    RefPtr<InlineStyleRuleSet> foundRuleSet = m_nodeToInlineRuleSetMap.take(node);
+    if (!foundRuleSet)
+        return;
+    m_identifierToRuleSetMap.remove(foundRuleSet->identifier());
 }
 
-RefPtr<Inspector::Protocol::CSS::CSSRule> InspectorCSSAgent::buildObjectForRule(CSSStyleRule* rule)
+void InspectorCSSAgent::didModifyDOMAttr(Element* element)
 {
-    if (!rule)
-        return nullptr;
+    if (!element)
+        return;
 
-    ASSERT(rule->parentStyleSheet());
-    InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(rule->parentStyleSheet());
-    return inspectorStyleSheet ? inspectorStyleSheet->buildObjectForRule(rule, nullptr) : nullptr;
+    auto findResult = m_nodeToInlineRuleSetMap.find(element);
+    if (findResult == m_nodeToInlineRuleSetMap.end())
+        return;
+
+    findResult->value->didModifyElementAttribute();
 }
 
-RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> InspectorCSSAgent::buildArrayForMatchedRuleList(const Vector<RefPtr<StyleRule>>& matchedRules, StyleResolver& styleResolver, Element* element)
+void InspectorCSSAgent::styleSheetChanged(StylesheetRuleSet& stylesheet)
 {
-    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>::create();
+    if (m_frontendDispatcher)
+        m_frontendDispatcher->styleSheetChanged(stylesheet.identifier());
+}
 
-    SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
-    SelectorChecker selectorChecker(element->document());
+void InspectorCSSAgent::resetPseudoStates()
+{
+    HashSet<Document*> documentsToChange;
+    for (auto& nodeId : m_nodeIdToForcedPseudoState.keys()) {
+        Node* node = m_domAgent->nodeForId(nodeId);
+        if (is<Element>(node))
+            documentsToChange.add(&downcast<Element>(node)->document());
+    }
 
-    for (auto& matchedRule : matchedRules) {
-        RefPtr<Inspector::Protocol::CSS::CSSRule> ruleObject = buildObjectForRule(matchedRule.get(), styleResolver, element);
-        if (!ruleObject)
-            continue;
+    m_nodeIdToForcedPseudoState.clear();
+    for (Document* document : documentsToChange)
+        document->styleResolverChanged(RecalcStyleImmediately);
+}
+
+// Code for translating between inspector CSS wrappers and inspector protocol.
+// TODO: almost all of the build*Object and *ToProtocolEnum functions should be static.
+
+Inspector::Protocol::CSS::StyleSheetOrigin stylesheetOriginToProtocolEnum(StyleSheetOrigin origin)
+{
+    switch (origin) {
+    case StyleSheetOrigin::Inspector:
+        return Inspector::Protocol::CSS::StyleSheetOrigin::Inspector;
+    case StyleSheetOrigin::UserAgent:
+        return Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent;
+    case StyleSheetOrigin::User:
+        return Inspector::Protocol::CSS::StyleSheetOrigin::User;
+    case StyleSheetOrigin::Author:
+        return Inspector::Protocol::CSS::StyleSheetOrigin::Regular;
+    default:
+        ASSERT_NOT_REACHED();
+        return Inspector::Protocol::CSS::StyleSheetOrigin::Regular;
+    }
+}
+
+Inspector::Protocol::CSS::CSSMedia::Source mediaListSourceToProtocolEnum(MediaListSource source)
+{
+    switch (source) {
+    case MediaListSource::MediaRule:
+        return Inspector::Protocol::CSS::CSSMedia::Source::MediaRule;
+    case MediaListSource::ImportRule:
+        return Inspector::Protocol::CSS::CSSMedia::Source::ImportRule;
+        break;
+    case MediaListSource::LinkedSheet:
+        return Inspector::Protocol::CSS::CSSMedia::Source::LinkedSheet;
+        break;
+    case MediaListSource::InlineSheet:
+        return Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;
+        break;
+    default:
+        ASSERT_NOT_REACHED();
+        return Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;
+    }
+}
 
+struct CollectRuleSelectorsFunctor {
+    typedef RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> ReturnType;
+
+    CollectRuleSelectorsFunctor(Element* element)
+        : m_selectorsArray(Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>::create())
+        , m_element(element)
+    {
+    }
+
+    void operator()(RuleSelector& selector)
+    {
+        auto selectorObject = Inspector::Protocol::CSS::CSSSelector::create()
+            .setText(selector.selectorText())
+            .release();
+
+        selectorObject->setDynamic(selector.hasDynamicSpecificity());
+        unsigned specificity = 0;
+        if (m_element)
+            specificity = selector.dynamicSpecificity(*m_element);
+        else
+            specificity = selector.staticSpecificity();
+
+        auto tuple = Inspector::Protocol::Array<int>::create();
+        tuple->addItem(static_cast<int>((specificity & CSSSelector::idMask) >> 16));
+        tuple->addItem(static_cast<int>((specificity & CSSSelector::classMask) >> 8));
+        tuple->addItem(static_cast<int>(specificity & CSSSelector::elementMask));
+        selectorObject->setSpecificity(WTF::move(tuple));
+
+        m_selectorsArray->addItem(WTF::move(selectorObject));
+    }
+
+    ReturnType returnValue() { return WTF::move(m_selectorsArray); }
+
+private:
+    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> m_selectorsArray;
+    Element* m_element;
+};
+
+Ref<Inspector::Protocol::CSS::SelectorList> buildObjectForSelectorList(Inspector::StyleRule& rule, Element* element)
+{
+    // This intentionally does not rely on the source data to avoid catching the trailing comments
+    // (before the declaration starting '{').
+    CollectRuleSelectorsFunctor collectSelector(element);
+    auto result = Inspector::Protocol::CSS::SelectorList::create()
+        .setSelectors(rule.forEachSelector(collectSelector))
+        .setText(rule.selectorListText())
+        .release();
+
+    if (rule.isFromSource()) {
+        TextPosition start, end;
+        bool success = rule.getSelectorListTextRange(start, end);
+        ASSERT_UNUSED(success, success);
+        result->setRange(buildObjectForSourceRange(start, end));
+    }
+    return WTF::move(result);
+}
+
+struct CollectStylesheetRulesFunctor {
+    typedef RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> ReturnType;
+
+    CollectStylesheetRulesFunctor()
+        : m_rulesArray(Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>::create())
+    {
+    }
+
+    void operator()(Inspector::StyleRule& rule)
+    {
+        m_rulesArray->addItem(buildObjectForStyleRule(rule, nullptr));
+    }
+
+    ReturnType returnValue() { return WTF::move(m_rulesArray); }
+
+private:
+    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> m_rulesArray;
+};
+
+
+RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> buildObjectForStyleSheet(StylesheetRuleSet& stylesheet)
+{
+    CollectStylesheetRulesFunctor collectRules;
+
+    auto result = Inspector::Protocol::CSS::CSSStyleSheetBody::create()
+        .setStyleSheetId(stylesheet.identifier())
+        .setRules(stylesheet.forEachRule(collectRules))
+        .release();
+
+    result->setText(stylesheet.getText());
+
+    return WTF::move(result);
+}
+
+RefPtr<Inspector::Protocol::CSS::SourceRange> buildObjectForSourceRange(TextPosition& start, TextPosition& end)
+{
+    return Inspector::Protocol::CSS::SourceRange::create()
+        .setStartLine(start.m_line.zeroBasedInt())
+        .setStartColumn(start.m_column.zeroBasedInt())
+        .setEndLine(end.m_line.zeroBasedInt())
+        .setEndColumn(end.m_column.zeroBasedInt())
+        .release();
+}
+
+Ref<Inspector::Protocol::CSS::CSSMedia> buildMediaObject(const MediaList& media, MediaListSource mediaListSource, const String& sourceURL)
+{
+    auto mediaObject = Inspector::Protocol::CSS::CSSMedia::create()
+        .setText(media.mediaText())
+        .setSource(mediaListSourceToProtocolEnum(mediaListSource))
+        .release();
+
+    if (!sourceURL.isEmpty()) {
+        mediaObject->setSourceURL(sourceURL);
+        mediaObject->setSourceLine(media.queries()->lastLine());
+    }
+    return WTF::move(mediaObject);
+}
+
+void fillMediaListChain(CSSRule& rule, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSMedia>& mediaArray)
+{
+    MediaList* mediaList;
+    CSSRule* parentRule = &rule;
+    String sourceURL;
+    while (parentRule) {
+        CSSStyleSheet* parentStyleSheet = nullptr;
+        bool isMediaRule = true;
+        if (is<CSSMediaRule>(*parentRule)) {
+            CSSMediaRule& mediaRule = downcast<CSSMediaRule>(*parentRule);
+            mediaList = mediaRule.media();
+            parentStyleSheet = mediaRule.parentStyleSheet();
+        } else if (is<CSSImportRule>(*parentRule)) {
+            CSSImportRule& importRule = downcast<CSSImportRule>(*parentRule);
+            mediaList = &importRule.media();
+            parentStyleSheet = importRule.parentStyleSheet();
+            isMediaRule = false;
+        } else
+            mediaList = nullptr;
+
+        if (parentStyleSheet) {
+            sourceURL = parentStyleSheet->contents().baseURL();
+            if (sourceURL.isEmpty())
+                sourceURL = InspectorDOMAgent::documentURLString(parentStyleSheet->ownerDocument());
+        } else
+            sourceURL = "";
+
+        if (mediaList && mediaList->length())
+            mediaArray.addItem(buildMediaObject(*mediaList, isMediaRule ? MediaListSource::MediaRule : MediaListSource::ImportRule, sourceURL));
+
+        if (parentRule->parentRule())
+            parentRule = parentRule->parentRule();
+        else {
+            CSSStyleSheet* styleSheet = parentRule->parentStyleSheet();
+            while (styleSheet) {
+                mediaList = styleSheet->media();
+                if (mediaList && mediaList->length()) {
+                    Document* doc = styleSheet->ownerDocument();
+                    if (doc)
+                        sourceURL = doc->url();
+                    else if (!styleSheet->contents().baseURL().isEmpty())
+                        sourceURL = styleSheet->contents().baseURL();
+                    else
+                        sourceURL = "";
+                    mediaArray.addItem(buildMediaObject(*mediaList, styleSheet->ownerNode() ? MediaListSource::LinkedSheet : MediaListSource::InlineSheet, sourceURL));
+                }
+                parentRule = styleSheet->ownerRule();
+                if (parentRule)
+                    break;
+                styleSheet = styleSheet->parentStyleSheet();
+            }
+        }
+    }
+}
+
+RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForStyleRule(Inspector::StyleRule& rule, Element* element)
+{
+    RefPtr<Inspector::Protocol::CSS::CSSStyle> styleObject;
+    rule.withStyle([&styleObject] (StyleDeclaration& style) {
+        styleObject = buildObjectForStyle(style);
+    });
+    ASSERT(styleObject);
+
+    StylesheetRuleSet* stylesheet = rule.stylesheet();
+    ASSERT(stylesheet);
+
+    auto result = Inspector::Protocol::CSS::CSSRule::create()
+        .setSelectorList(buildObjectForSelectorList(rule, element))
+        .setSourceLine(rule.sourceLine())
+        .setOrigin(stylesheetOriginToProtocolEnum(stylesheet->origin()))
+        .setStyle(WTF::move(styleObject))
+        .release();
+
+    // "sourceURL" is present only for regular rules, otherwise "origin" should be used in the frontend.
+    if (stylesheet->origin() == StyleSheetOrigin::Author)
+        result->setSourceURL(stylesheet->finalURL());
+
+    if (stylesheet->canBind()) {
+        if (!rule.ruleId().isEmpty())
+            result->setRuleId(rule.ruleId().asProtocolValue<Inspector::Protocol::CSS::CSSRuleId>());
+    }
+
+    auto mediaArray = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSMedia>::create();
+
+    fillMediaListChain(rule.rule(), mediaArray.get());
+    if (mediaArray->length())
+        result->setMedia(WTF::move(mediaArray));
+
+    return WTF::move(result);
+}
+
+RefPtr<Inspector::Protocol::CSS::RuleMatch> InspectorCSSAgent::buildObjectForMatchedRule(WebCore::StyleRule& styleRule, Element& element)
+{
+    RefPtr<Inspector::Protocol::CSS::RuleMatch> result;
+    withWrappedRule(styleRule, element.document(), [&] (Inspector::StyleRule& rule) {
+        SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
+        SelectorChecker selectorChecker(element.document());
+
+        // FIXME: this is duplicated from RuleSelector, it should be calculated there.
         auto matchingSelectors = Inspector::Protocol::Array<int>::create();
-        const CSSSelectorList& selectorList = matchedRule->selectorList();
+        const CSSSelectorList& selectorList = styleRule.selectorList();
         long index = 0;
         for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector)) {
             unsigned ignoredSpecificity;
-            bool matched = selectorChecker.match(selector, element, context, ignoredSpecificity);
+            bool matched = selectorChecker.match(selector, &element, context, ignoredSpecificity);
             if (matched)
                 matchingSelectors->addItem(index);
             ++index;
         }
 
-        auto match = Inspector::Protocol::CSS::RuleMatch::create()
-            .setRule(WTF::move(ruleObject))
+        result = Inspector::Protocol::CSS::RuleMatch::create()
+            .setRule(buildObjectForStyleRule(rule, &element))
             .setMatchingSelectors(WTF::move(matchingSelectors))
             .release();
-        result->addItem(WTF::move(match));
-    }
-
+    });
     return WTF::move(result);
 }
 
-RefPtr<Inspector::Protocol::CSS::CSSStyle> InspectorCSSAgent::buildObjectForAttributesStyle(Element* element)
+// FIXME: turn this into a collector functor.
+RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> InspectorCSSAgent::buildArrayForMatchedRuleList(const Vector<RefPtr<StyleRule>>& matchedRules, Element& element)
 {
-    ASSERT(element);
-    if (!is<StyledElement>(*element))
-        return nullptr;
-
-    // FIXME: Ugliness below.
-    StyleProperties* attributeStyle = const_cast<StyleProperties*>(downcast<StyledElement>(element)->presentationAttributeStyle());
-    if (!attributeStyle)
-        return nullptr;
+    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>::create();
 
-    ASSERT_WITH_SECURITY_IMPLICATION(attributeStyle->isMutable());
-    MutableStyleProperties* mutableAttributeStyle = static_cast<MutableStyleProperties*>(attributeStyle);
+    for (auto& matchedRule : matchedRules)
+        if (auto matchObject = buildObjectForMatchedRule(*matchedRule, element))
+            result->addItem(WTF::move(matchObject));
 
-    Ref<InspectorStyle> inspectorStyle = InspectorStyle::create(InspectorCSSId(), mutableAttributeStyle->ensureCSSStyleDeclaration(), nullptr);
-    return inspectorStyle->buildObjectForStyle();
+    return WTF::move(result);
 }
 
 RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::Region>> InspectorCSSAgent::buildArrayForRegions(ErrorString& errorString, RefPtr<NodeList>&& regionList, int documentNodeId)
 {
     auto regions = Inspector::Protocol::Array<Inspector::Protocol::CSS::Region>::create();
 
     for (unsigned i = 0; i < regionList->length(); ++i) {
         Inspector::Protocol::CSS::Region::RegionOverset regionOverset;
 
         switch (downcast<Element>(regionList->item(i))->regionOversetState()) {
@@ -1011,65 +1397,169 @@ RefPtr<Inspector::Protocol::CSS::NamedFlow> InspectorCSSAgent::buildObjectForNam
 
     return Inspector::Protocol::CSS::NamedFlow::create()
         .setDocumentNodeId(documentNodeId)
         .setName(webkitNamedFlow->name().string())
         .setOverset(webkitNamedFlow->overset())
         .setContent(WTF::move(content))
         .setRegions(buildArrayForRegions(errorString, webkitNamedFlow->getRegions(), documentNodeId))
         .release();
 }
 
-void InspectorCSSAgent::didRemoveDocument(Document* document)
+RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyle(StyleDeclaration& style)
 {
-    if (document)
-        m_documentToInspectorStyleSheet.remove(document);
-}
+    if (style.styleId().isEmpty()) {
+        return Inspector::Protocol::CSS::CSSStyle::create()
+            .setCssProperties(Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSProperty>::create())
+            .setShorthandEntries(Inspector::Protocol::Array<Inspector::Protocol::CSS::ShorthandEntry>::create())
+            .release();
+    }
 
-void InspectorCSSAgent::didRemoveDOMNode(Node* node)
-{
-    if (!node)
-        return;
+    RefPtr<Inspector::Protocol::CSS::CSSStyle> result = buildObjectForStyleWithProperties(style);
+    if (!style.styleId().isEmpty())
+        result->setStyleId(style.styleId().asProtocolValue<Inspector::Protocol::CSS::CSSStyleId>());
 
-    int nodeId = m_domAgent->boundNodeId(node);
-    if (nodeId)
-        m_nodeIdToForcedPseudoState.remove(nodeId);
+    result->setWidth(style.declaration().getPropertyValue("width"));
+    result->setHeight(style.declaration().getPropertyValue("height"));
 
-    NodeToInspectorStyleSheet::iterator it = m_nodeToInspectorStyleSheet.find(node);
-    if (it == m_nodeToInspectorStyleSheet.end())
-        return;
+    if (style.isFromSource()) {
+        TextPosition start, end;
+        bool success;
+        success = style.getStyleTextRange(start, end);
+        ASSERT_UNUSED(success, success);
+        result->setRange(buildObjectForSourceRange(start, end));
+
+        String styleText;
+        success = style.getStyleText(styleText);
+        ASSERT_UNUSED(success, success);
+        result->setCssText(styleText);
+    }
 
-    m_idToInspectorStyleSheet.remove(it->value->id());
-    m_nodeToInspectorStyleSheet.remove(node);
+    return WTF::move(result);
 }
 
-void InspectorCSSAgent::didModifyDOMAttr(Element* element)
-{
-    if (!element)
-        return;
+struct CollectPropertyShorthandsFunctor {
+    typedef RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::ShorthandEntry>> ReturnType;
 
-    NodeToInspectorStyleSheet::iterator it = m_nodeToInspectorStyleSheet.find(element);
-    if (it == m_nodeToInspectorStyleSheet.end())
-        return;
+    CollectPropertyShorthandsFunctor()
+    : m_shorthandsArray(Inspector::Protocol::Array<Inspector::Protocol::CSS::ShorthandEntry>::create())
+    {
+    }
 
-    it->value->didModifyElementAttribute();
-}
+    void operator()(Inspector::StyleProperty& property)
+    {
+        // Only collect shorthands for implicitly defined properties.
+        if (property.isFromSource())
+            return;
+
+        String shorthand = property.shorthandPropertyName();
+        if (!shorthand.isEmpty()) {
+            if (!m_foundShorthands.contains(shorthand)) {
+                m_foundShorthands.add(shorthand);
+                auto result = Inspector::Protocol::CSS::ShorthandEntry::create()
+                    .setName(shorthand)
+                    .setValue(property.shorthandPropertyValue())
+                    .release();
+                m_shorthandsArray->addItem(WTF::move(result));
+            }
+        }
+    }
 
-void InspectorCSSAgent::styleSheetChanged(InspectorStyleSheet* styleSheet)
-{
-    if (m_frontendDispatcher)
-        m_frontendDispatcher->styleSheetChanged(styleSheet->id());
-}
+    ReturnType returnValue() { return WTF::move(m_shorthandsArray); }
 
-void InspectorCSSAgent::resetPseudoStates()
-{
-    HashSet<Document*> documentsToChange;
-    for (NodeIdToForcedPseudoState::iterator it = m_nodeIdToForcedPseudoState.begin(), end = m_nodeIdToForcedPseudoState.end(); it != end; ++it) {
-        if (Element* element = downcast<Element>(m_domAgent->nodeForId(it->key)))
-            documentsToChange.add(&element->document());
+private:
+    HashSet<String> m_foundShorthands;
+    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::ShorthandEntry>> m_shorthandsArray;
+};
+
+
+struct CollectPropertyDataFunctor {
+    typedef RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSProperty>> ReturnType;
+
+    CollectPropertyDataFunctor()
+        : m_propertiesArray(Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSProperty>::create())
+    {
     }
 
-    m_nodeIdToForcedPseudoState.clear();
-    for (HashSet<Document*>::iterator it = documentsToChange.begin(), end = documentsToChange.end(); it != end; ++it)
-        (*it)->styleResolverChanged(RecalcStyleImmediately);
+    void operator()(StyleProperty& property)
+    {
+        RefPtr<Inspector::Protocol::CSS::CSSProperty> propertyObject = Inspector::Protocol::CSS::CSSProperty::create()
+            .setName(property.propertyName().lower())
+            .setValue(property.propertyValue())
+            .release();
+
+        propertyObject->setParsedOk(property.parsedOk());
+        propertyObject->setImplicit(property.isImplicit());
+
+        // Default "priority" == "".
+        if (property.isImportant())
+            propertyObject->setPriority("important");
+
+        auto status = Inspector::Protocol::CSS::CSSPropertyStatus::Active;
+        if (!property.isFromSource())
+            status = Inspector::Protocol::CSS::CSSPropertyStatus::Style;
+        else {
+            propertyObject->setText(property.rawText());
+
+            TextPosition start;
+            TextPosition end;
+            property.getTextRange(start, end);
+            propertyObject->setRange(buildObjectForSourceRange(start, end));
+
+            // Parsed property overrides any property with the same name. Non-parsed property overrides
+            // previous non-parsed property with the same name (if any).
+            bool shouldInactivate = false;
+            CSSPropertyID propertyId = cssPropertyID(property.propertyName());
+            // Canonicalize property names to treat non-prefixed and vendor-prefixed property names the same (opacity vs. -webkit-opacity).
+            String canonicalPropertyName = propertyId ? getPropertyNameString(propertyId) : property.propertyName();
+            auto findResult = m_propertyNameToPreviousActiveProperty.find(canonicalPropertyName);
+            if (findResult != m_propertyNameToPreviousActiveProperty.end()) {
+                if (property.parsedOk()) {
+                    bool successPriority = findResult->value->getString(Inspector::Protocol::CSS::CSSProperty::Priority, m_previousPriority);
+                    bool successStatus = findResult->value->getString(Inspector::Protocol::CSS::CSSProperty::Status, m_previousStatus);
+                    if (successStatus && m_previousStatus != "inactive") {
+                        if (property.isImportant() || !successPriority) // Priority not set == "not important".
+                            shouldInactivate = true;
+                        else if (status == Inspector::Protocol::CSS::CSSPropertyStatus::Active) {
+                            // Inactivate a non-important property following the same-named important property.
+                            status = Inspector::Protocol::CSS::CSSPropertyStatus::Inactive;
+                        }
+                    }
+                } else {
+                    bool previousParsedOk;
+                    bool success = findResult->value->getBoolean(Inspector::Protocol::CSS::CSSProperty::ParsedOk, previousParsedOk);
+                    if (success && !previousParsedOk)
+                        shouldInactivate = true;
+                }
+            } else
+                m_propertyNameToPreviousActiveProperty.set(canonicalPropertyName, propertyObject.get());
+
+            if (shouldInactivate) {
+                findResult->value->setStatus(Inspector::Protocol::CSS::CSSPropertyStatus::Inactive);
+                m_propertyNameToPreviousActiveProperty.set(canonicalPropertyName, propertyObject.get());
+            }
+        }
+
+        propertyObject->setStatus(status);
+        m_propertiesArray->addItem(WTF::move(propertyObject));
+    }
+
+    ReturnType returnValue() { return WTF::move(m_propertiesArray); }
+
+private:
+    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSProperty>> m_propertiesArray;
+    HashMap<String, Inspector::Protocol::CSS::CSSProperty*> m_propertyNameToPreviousActiveProperty;
+    String m_previousPriority;
+    String m_previousStatus;
+};
+
+RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyleWithProperties(StyleDeclaration& style)
+{
+    CollectPropertyDataFunctor collectPropertyData;
+    CollectPropertyShorthandsFunctor collectShorthands;
+
+    return Inspector::Protocol::CSS::CSSStyle::create()
+        .setCssProperties(style.forEachProperty(collectPropertyData))
+        .setShorthandEntries(style.forEachProperty(collectShorthands))
+        .release();
 }
 
 } // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorCSSAgent.h b/Source/WebCore/inspector/InspectorCSSAgent.h
index e4a60379..7ef6b53 100644
--- a/Source/WebCore/inspector/InspectorCSSAgent.h
+++ b/Source/WebCore/inspector/InspectorCSSAgent.h
@@ -21,32 +21,33 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef InspectorCSSAgent_h
 #define InspectorCSSAgent_h
 
 #include "CSSSelector.h"
 #include "ContentSecurityPolicy.h"
 #include "InspectorDOMAgent.h"
-#include "InspectorStyleSheet.h"
+#include "InspectorStylesheetRuleSet.h"
 #include "InspectorWebAgentBase.h"
 #include "SecurityContext.h"
 #include <inspector/InspectorBackendDispatchers.h>
 #include <inspector/InspectorValues.h>
 #include <wtf/HashMap.h>
 #include <wtf/HashSet.h>
 #include <wtf/RefPtr.h>
 #include <wtf/text/WTFString.h>
 
 namespace Inspector {
 class CSSFrontendDispatcher;
+class InlineStyleRuleSet;
 }
 
 namespace WebCore {
 
 class CSSRule;
 class CSSRuleList;
 class CSSStyleDeclaration;
 class CSSStyleRule;
 class CSSStyleSheet;
 class Document;
@@ -58,21 +59,21 @@ class NameNodeMap;
 class Node;
 class NodeList;
 class StyleResolver;
 class StyleRule;
 class ChangeRegionOversetTask;
 
 class InspectorCSSAgent final
     : public InspectorAgentBase
     , public InspectorDOMAgent::DOMListener
     , public Inspector::CSSBackendDispatcherHandler
-    , public InspectorStyleSheet::Listener {
+    , public Inspector::StylesheetRuleSet::Listener {
     WTF_MAKE_NONCOPYABLE(InspectorCSSAgent);
     WTF_MAKE_FAST_ALLOCATED;
 public:
     class InlineStyleOverrideScope {
     public:
         InlineStyleOverrideScope(SecurityContext* context)
             : m_contentSecurityPolicy(context->contentSecurityPolicy())
         {
             m_contentSecurityPolicy->setOverrideAllowInlineStyle(true);
         }
@@ -82,22 +83,20 @@ public:
             m_contentSecurityPolicy->setOverrideAllowInlineStyle(false);
         }
 
     private:
         ContentSecurityPolicy* m_contentSecurityPolicy;
     };
 
     InspectorCSSAgent(InstrumentingAgents*, InspectorDOMAgent*);
     virtual ~InspectorCSSAgent();
 
-    static CSSStyleRule* asCSSStyleRule(CSSRule&);
-
     virtual void didCreateFrontendAndBackend(Inspector::FrontendChannel*, Inspector::BackendDispatcher*) override;
     virtual void willDestroyFrontendAndBackend(Inspector::DisconnectReason) override;
     virtual void discardAgent() override;
     virtual void enable(ErrorString&) override;
     virtual void disable(ErrorString&) override;
     void regionOversetChanged(WebKitNamedFlow*, int documentNodeId);
     void reset();
 
     // InspectorInstrumentation callbacks.
     void mediaQueryResultChanged();
@@ -105,79 +104,85 @@ public:
     void willRemoveNamedFlow(Document&, WebKitNamedFlow&);
     void didChangeRegionOverset(Document&, WebKitNamedFlow&);
     void didRegisterNamedFlowContentElement(Document&, WebKitNamedFlow&, Node& contentElement, Node* nextContentElement = nullptr);
     void didUnregisterNamedFlowContentElement(Document&, WebKitNamedFlow&, Node& contentElement);
     bool forcePseudoState(Element&, CSSSelector::PseudoClassType);
 
     virtual void getComputedStyleForNode(ErrorString&, int nodeId, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>>&) override;
     virtual void getInlineStylesForNode(ErrorString&, int nodeId, RefPtr<Inspector::Protocol::CSS::CSSStyle>& inlineStyle, RefPtr<Inspector::Protocol::CSS::CSSStyle>& attributes) override;
     virtual void getMatchedStylesForNode(ErrorString&, int nodeId, const bool* includePseudo, const bool* includeInherited, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>>& matchedCSSRules, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::PseudoIdMatches>>& pseudoIdMatches, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::InheritedStyleEntry>>& inheritedEntries) override;
     virtual void getAllStyleSheets(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>>& styleSheetInfos) override;
-    virtual void getStyleSheet(ErrorString&, const String& styleSheetId, RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody>& result) override;
-    virtual void getStyleSheetText(ErrorString&, const String& styleSheetId, String* result) override;
-    virtual void setStyleSheetText(ErrorString&, const String& styleSheetId, const String& text) override;
+    virtual void getStyleSheet(ErrorString&, Inspector::Protocol::CSS::StyleSheetId styleSheetId, RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody>& result) override;
+    virtual void getStyleSheetText(ErrorString&, Inspector::Protocol::CSS::StyleSheetId styleSheetId, String* result) override;
+    virtual void setStyleSheetText(ErrorString&, Inspector::Protocol::CSS::StyleSheetId styleSheetId, const String& text) override;
     virtual void setStyleText(ErrorString&, const RefPtr<Inspector::InspectorObject>&& styleId, const String& text, RefPtr<Inspector::Protocol::CSS::CSSStyle>& result) override;
     virtual void setRuleSelector(ErrorString&, const RefPtr<Inspector::InspectorObject>&& ruleId, const String& selector, RefPtr<Inspector::Protocol::CSS::CSSRule>& result) override;
     virtual void addRule(ErrorString&, int contextNodeId, const String& selector, RefPtr<Inspector::Protocol::CSS::CSSRule>& result) override;
     virtual void getSupportedCSSProperties(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSPropertyInfo>>& result) override;
     virtual void forcePseudoState(ErrorString&, int nodeId, const RefPtr<Inspector::InspectorArray>&& forcedPseudoClasses) override;
     virtual void getNamedFlowCollection(ErrorString&, int documentNodeId, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::NamedFlow>>& result) override;
 
+    // Public entry points for the Inspector CSS wrapper system.
+    void withWrappedRule(WebCore::StyleRule&, Document& ownerDocument, const std::function<void(Inspector::StyleRule&)>&);
+    void withWrappedStyle(CSSStyleDeclaration&, const std::function<void(Inspector::StyleDeclaration&)>&);
+    Inspector::StylesheetRuleSet& ruleSetForStyleSheet(CSSStyleSheet&);
+    Inspector::InlineStyleRuleSet& ruleSetForInlineStyle(Element&);
+    Inspector::StylesheetRuleSet* ruleSetForRule(WebCore::StyleRule&, Document& ownerDocument);
+
+    RefPtr<Inspector::Protocol::CSS::RuleMatch> buildObjectForMatchedRule(StyleRule&, Element&);
+
 private:
-    class StyleSheetAction;
+    class StyleRuleSetAction;
     class SetStyleSheetTextAction;
     class SetStyleTextAction;
     class SetRuleSelectorAction;
     class AddRuleAction;
 
-    typedef HashMap<String, RefPtr<InspectorStyleSheet>> IdToInspectorStyleSheet;
-    typedef HashMap<CSSStyleSheet*, RefPtr<InspectorStyleSheet>> CSSStyleSheetToInspectorStyleSheet;
-    typedef HashMap<Node*, RefPtr<InspectorStyleSheetForInlineStyle>> NodeToInspectorStyleSheet; // bogus "stylesheets" with elements' inline styles
-    typedef HashMap<RefPtr<Document>, RefPtr<InspectorStyleSheet>> DocumentToViaInspectorStyleSheet; // "via inspector" stylesheets
+    typedef HashMap<uint64_t, RefPtr<Inspector::StyleRuleSet>> IdentifierToRuleSetMap;
+    typedef HashMap<CSSStyleSheet*, RefPtr<Inspector::StylesheetRuleSet>> CSSStyleSheetToRuleSetMap;
+    typedef HashMap<Node*, RefPtr<Inspector::InlineStyleRuleSet>> NodeToInlineRuleSetMap;
+    typedef HashMap<RefPtr<Document>, RefPtr<Inspector::StylesheetRuleSet>> DocumentToInspectorRuleSetMap; // "via inspector" stylesheets
     typedef HashMap<int, unsigned> NodeIdToForcedPseudoState;
 
     void resetNonPersistentData();
-    InspectorStyleSheetForInlineStyle* asInspectorStyleSheet(Element* element);
     Element* elementForId(ErrorString&, int nodeId);
     int documentNodeWithRequestedFlowsId(Document*);
-    void collectStyleSheets(CSSStyleSheet*, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>*);
+    void collectStyleSheets(CSSStyleSheet&, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>&);
 
-    InspectorStyleSheet* bindStyleSheet(CSSStyleSheet*);
-    InspectorStyleSheet* viaInspectorStyleSheet(Document*, bool createIfAbsent);
-    InspectorStyleSheet* assertStyleSheetForId(ErrorString&, const String&);
-    Inspector::Protocol::CSS::StyleSheetOrigin detectOrigin(CSSStyleSheet* pageStyleSheet, Document* ownerDocument);
+    Inspector::StyleRuleSet* ruleSetForStylesheetId(ErrorString&, Inspector::Protocol::CSS::StyleSheetId);
+    // For a given document, returns the stylesheet containing rules added through the inspector.
+    Inspector::StylesheetRuleSet* inspectorRuleSetForDocument(Document&, bool createIfAbsent);
 
-    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForRule(StyleRule*, StyleResolver&, Element*);
-    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForRule(CSSStyleRule*);
-    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> buildArrayForMatchedRuleList(const Vector<RefPtr<StyleRule>>&, StyleResolver&, Element*);
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForAttributesStyle(Element*);
+    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> buildArrayForMatchedRuleList(const Vector<RefPtr<StyleRule>>&, Element&);
     RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::Region>> buildArrayForRegions(ErrorString&, RefPtr<NodeList>&&, int documentNodeId);
     RefPtr<Inspector::Protocol::CSS::NamedFlow> buildObjectForNamedFlow(ErrorString&, WebKitNamedFlow*, int documentNodeId);
 
     // InspectorDOMAgent::DOMListener implementation
     virtual void didRemoveDocument(Document*) override;
     virtual void didRemoveDOMNode(Node*) override;
     virtual void didModifyDOMAttr(Element*) override;
 
     // InspectorCSSAgent::Listener implementation
-    virtual void styleSheetChanged(InspectorStyleSheet*) override;
+    virtual void styleSheetChanged(Inspector::StylesheetRuleSet&) override;
 
     void resetPseudoStates();
 
     std::unique_ptr<Inspector::CSSFrontendDispatcher> m_frontendDispatcher;
     RefPtr<Inspector::CSSBackendDispatcher> m_backendDispatcher;
     InspectorDOMAgent* m_domAgent;
 
-    IdToInspectorStyleSheet m_idToInspectorStyleSheet;
-    CSSStyleSheetToInspectorStyleSheet m_cssStyleSheetToInspectorStyleSheet;
-    NodeToInspectorStyleSheet m_nodeToInspectorStyleSheet;
-    DocumentToViaInspectorStyleSheet m_documentToInspectorStyleSheet;
+    IdentifierToRuleSetMap m_identifierToRuleSetMap;
+    CSSStyleSheetToRuleSetMap m_cssStyleSheetToRuleSetMap;
+    NodeToInlineRuleSetMap m_nodeToInlineRuleSetMap;
+    DocumentToInspectorRuleSetMap m_documentToInspectorRuleSetMap;
+
     NodeIdToForcedPseudoState m_nodeIdToForcedPseudoState;
     HashSet<int> m_namedFlowCollectionsRequested;
     std::unique_ptr<ChangeRegionOversetTask> m_changeRegionOversetTask;
-
-    int m_lastStyleSheetId;
 };
 
+RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyle(Inspector::StyleDeclaration&);
+RefPtr<Inspector::Protocol::CSS::SourceRange> buildObjectForSourceRange(TextPosition& start, TextPosition& end);
+
 } // namespace WebCore
 
 #endif // !defined(InspectorCSSAgent_h)
diff --git a/Source/WebCore/inspector/InspectorCSSId.h b/Source/WebCore/inspector/InspectorCSSId.h
new file mode 100644
index 0000000..4a74bbb
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorCSSId.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorCSSId_h
+#define InspectorCSSId_h
+
+#include <inspector/InspectorProtocolTypes.h>
+#include <wtf/RefPtr.h>
+#include <wtf/text/WTFString.h>
+
+namespace Inspector {
+
+class CSSId {
+public:
+    CSSId() { }
+
+    explicit CSSId(const RefPtr<InspectorObject>&& value)
+    {
+        if (!value->getInteger(ASCIILiteral("styleSheetId"), m_stylesheetId))
+            return;
+
+        if (!value->getInteger(ASCIILiteral("ordinal"), m_ruleOrdinal))
+            return;
+    }
+
+    CSSId(uint64_t stylesheetId, uint64_t ruleOrdinal)
+        : m_stylesheetId(stylesheetId)
+        , m_ruleOrdinal(ruleOrdinal)
+    {
+    }
+
+    bool isEmpty() const { return !m_stylesheetId; }
+
+    uint64_t stylesheetId() const { return m_stylesheetId; }
+    uint64_t ruleOrdinal() const { return m_ruleOrdinal; }
+
+    // ProtocolType is either Inspector::Protocol::CSS::CSSStyleId or Inspector::Protocol::CSS::CSSRuleId.
+    template<typename ProtocolType>
+    RefPtr<ProtocolType> asProtocolValue() const
+    {
+        if (isEmpty())
+            return nullptr;
+
+        return ProtocolType::create()
+            .setStyleSheetId(m_stylesheetId)
+            .setOrdinal(m_ruleOrdinal)
+            .release();
+    }
+
+private:
+    uint64_t m_stylesheetId {0};
+    uint64_t m_ruleOrdinal {0};
+};
+
+} // namespace Inspector
+
+#endif // InspectorCSSId_h
diff --git a/Source/WebCore/inspector/InspectorInlineStyleRuleSet.cpp b/Source/WebCore/inspector/InspectorInlineStyleRuleSet.cpp
new file mode 100644
index 0000000..57ddb53
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorInlineStyleRuleSet.cpp
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorInlineStyleRuleSet.h"
+
+#include "CSSStyleRule.h"
+#include "Element.h"
+#include "InspectorCSSAgent.h"
+#include "InspectorStyleRule.h"
+#include "Node.h"
+#include "StyledElement.h"
+#include "StyleProperties.h"
+
+using namespace WebCore;
+
+namespace Inspector {
+
+Ref<InlineStyleRuleSet> InlineStyleRuleSet::create(Ref<Element>&& element)
+{
+    return adoptRef(*new InlineStyleRuleSet(WTF::move(element)));
+}
+
+InlineStyleRuleSet::InlineStyleRuleSet(Ref<Element>&& element)
+    : StyleRuleSet()
+    , m_element(WTF::move(element))
+{
+}
+
+InlineStyleRuleSet::~InlineStyleRuleSet() { }
+
+void InlineStyleRuleSet::replaceText(const String& text)
+{
+    {
+        InspectorCSSAgent::InlineStyleOverrideScope overrideScope(&m_element->document());
+        ExceptionCode ec;
+        m_element->setAttribute("style", text, ec);
+    }
+
+    commitRuleSetChange(ParsedRuleSetData::create(m_element));
+}
+
+bool InlineStyleRuleSet::setTextForStyle(CSSStyleDeclaration& style, const String& styleText)
+{
+    ASSERT_UNUSED(style, &style == inlineStyle());
+
+    replaceText(styleText);
+    return true;
+}
+
+void InlineStyleRuleSet::didModifyElementAttribute()
+{
+    // Drop stale parsed data since it can be regenerated when needed.
+    commitRuleSetChange(nullptr);
+}
+
+Document* InlineStyleRuleSet::ownerDocument() const
+{
+    return &m_element->document();
+}
+
+std::unique_ptr<ParsedRuleSetData> InlineStyleRuleSet::originalSourceData()
+{
+    return ParsedRuleSetData::create(m_element.get());
+}
+
+CSSStyleDeclaration* InlineStyleRuleSet::inlineStyle()
+{
+    return m_element->style();
+}
+
+CSSStyleDeclaration* InlineStyleRuleSet::attributeStyle()
+{
+    if (!is<StyledElement>(m_element))
+        return nullptr;
+
+    const StyleProperties* attributeStyle = downcast<StyledElement>(m_element.get()).presentationAttributeStyle();
+    
+    if (!is<MutableStyleProperties>(attributeStyle))
+        return nullptr;
+    
+    const MutableStyleProperties* mutableAttributeStyle = downcast<MutableStyleProperties>(attributeStyle);
+    return const_cast<MutableStyleProperties*>(mutableAttributeStyle)->ensureCSSStyleDeclaration();
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorInlineStyleRuleSet.h b/Source/WebCore/inspector/InspectorInlineStyleRuleSet.h
new file mode 100644
index 0000000..0524a92
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorInlineStyleRuleSet.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InlineStyleRuleSet_h
+#define InlineStyleRuleSet_h
+
+#include "InspectorCSSId.h"
+#include "InspectorStyleRule.h"
+#include "InspectorStyleRuleSet.h"
+#include <wtf/TypeCasts.h>
+
+namespace WebCore {
+class CSSStyleDeclaration;
+class Element;
+struct CSSRuleSourceData;
+}
+
+namespace Inspector {
+
+class InlineStyleRuleSet final : public StyleRuleSet {
+public:
+    static Ref<InlineStyleRuleSet> create(Ref<WebCore::Element>&&);
+    virtual ~InlineStyleRuleSet();
+
+    // StyleRuleSet API
+    virtual bool isInlineStyle() const override { return true; }
+    virtual void replaceText(const String&) override;
+
+    virtual std::unique_ptr<ParsedRuleSetData> originalSourceData() override;
+    virtual WebCore::Document* ownerDocument() const override;
+
+    // InlineStyleRuleSet API
+    void withInlineStyle(const std::function<void(Inspector::StyleDeclaration&)>&);
+    // This returns a StyleRule representing CSS styles induced by presentation attributes,
+    // such as 'width', 'align', and other legacy tag attributes.
+    void withAttributeStyle(const std::function<void(Inspector::StyleDeclaration&)>&);
+
+    // Called from CSSAgent through InspectorInstrumentation.
+    void didModifyElementAttribute();
+private:
+    InlineStyleRuleSet(Ref<WebCore::Element>&&);
+
+    WebCore::CSSStyleDeclaration* inlineStyle();
+    WebCore::CSSStyleDeclaration* attributeStyle();
+
+    virtual bool setTextForStyle(WebCore::CSSStyleDeclaration&, const String&) override;
+
+private:
+    Ref<WebCore::Element> m_element;
+};
+
+inline void InlineStyleRuleSet::withInlineStyle(const std::function<void(Inspector::StyleDeclaration&)>& callback)
+{
+    StyleDeclaration wrapper(CSSId(identifier(), 0), *inlineStyle(), this);
+    callback(wrapper);
+}
+
+inline void InlineStyleRuleSet::withAttributeStyle(const std::function<void(Inspector::StyleDeclaration&)>& callback)
+{
+    auto style = attributeStyle();
+    if (!style)
+        return;
+
+    StyleDeclaration wrapper(CSSId(identifier(), 0), *style, this);
+    callback(wrapper);
+}
+
+} // namespace Inspector
+
+SPECIALIZE_TYPE_TRAITS_BEGIN(Inspector::InlineStyleRuleSet)
+static bool isType(const Inspector::StyleRuleSet& ruleSet) { return ruleSet.isInlineStyle(); }
+SPECIALIZE_TYPE_TRAITS_END()
+
+#endif // InlineStyleRuleSet_h
diff --git a/Source/WebCore/inspector/InspectorInstrumentation.h b/Source/WebCore/inspector/InspectorInstrumentation.h
index ad8de6b..21b36a4 100644
--- a/Source/WebCore/inspector/InspectorInstrumentation.h
+++ b/Source/WebCore/inspector/InspectorInstrumentation.h
@@ -276,20 +276,21 @@ public:
     static void pseudoElementDestroyed(Page*, PseudoElement&);
 
     static void frontendCreated() { s_frontendCounter += 1; }
     static void frontendDeleted() { s_frontendCounter -= 1; }
     static bool hasFrontends() { return s_frontendCounter; }
     static bool consoleAgentEnabled(ScriptExecutionContext*);
     static bool timelineAgentEnabled(ScriptExecutionContext*);
     static bool replayAgentEnabled(ScriptExecutionContext*);
 
     WEBCORE_EXPORT static InstrumentingAgents* instrumentingAgentsForPage(Page*);
+    static InstrumentingAgents* instrumentingAgentsForFrame(Frame*);
 
     static void registerInstrumentingAgents(InstrumentingAgents&);
     static void unregisterInstrumentingAgents(InstrumentingAgents&);
 
 private:
     static void didClearWindowObjectInWorldImpl(InstrumentingAgents&, Frame&, DOMWrapperWorld&);
     static bool isDebuggerPausedImpl(InstrumentingAgents&);
 
     static void willInsertDOMNodeImpl(InstrumentingAgents&, Node& parent);
     static void didInsertDOMNodeImpl(InstrumentingAgents&, Node&);
@@ -442,21 +443,20 @@ private:
 
     static void networkStateChangedImpl(InstrumentingAgents&);
     static void updateApplicationCacheStatusImpl(InstrumentingAgents&, Frame*);
 
     static void layerTreeDidChangeImpl(InstrumentingAgents&);
     static void renderLayerDestroyedImpl(InstrumentingAgents&, const RenderLayer&);
     static void pseudoElementDestroyedImpl(InstrumentingAgents&, PseudoElement&);
 
     static InstrumentingAgents* instrumentingAgentsForPage(Page&);
     static InstrumentingAgents* instrumentingAgentsForFrame(Frame&);
-    static InstrumentingAgents* instrumentingAgentsForFrame(Frame*);
     static InstrumentingAgents* instrumentingAgentsForContext(ScriptExecutionContext*);
     static InstrumentingAgents* instrumentingAgentsForDocument(Document&);
     static InstrumentingAgents* instrumentingAgentsForDocument(Document*);
     static InstrumentingAgents* instrumentingAgentsForRenderer(RenderObject*);
 
     static InstrumentingAgents* instrumentingAgentsForWorkerGlobalScope(WorkerGlobalScope*);
     static InstrumentingAgents* instrumentingAgentsForNonDocumentContext(ScriptExecutionContext*);
 
     static InspectorTimelineAgent* retrieveTimelineAgent(const InspectorInstrumentationCookie&);
 
diff --git a/Source/WebCore/inspector/InspectorRuleSelector.cpp b/Source/WebCore/inspector/InspectorRuleSelector.cpp
new file mode 100644
index 0000000..08646bf
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorRuleSelector.cpp
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorRuleSelector.h"
+
+#include "CSSSelector.h"
+#include "SelectorChecker.h"
+
+using namespace WebCore;
+
+namespace Inspector {
+
+unsigned RuleSelector::staticSpecificity() const
+{
+    bool success;
+    unsigned result = m_selector.staticSpecificity(success);
+    return success ? result : 0;
+}
+
+unsigned RuleSelector::dynamicSpecificity(Element& element) const
+{
+    SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
+    SelectorChecker selectorChecker(element.document());
+
+    unsigned computedSpecificity;
+    if (!selectorChecker.match(&m_selector, &element, context, computedSpecificity))
+        return staticSpecificity();
+
+    return computedSpecificity;
+}
+
+bool RuleSelector::matchesElement(Element& element) const
+{
+    SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
+    SelectorChecker selectorChecker(element.document());
+
+    unsigned ignoredSpecificity;
+    return selectorChecker.match(&m_selector, &element, context, ignoredSpecificity);
+}
+
+bool RuleSelector::hasDynamicSpecificity() const
+{
+    // It is possible that these can have a static specificity if each selector in the list has
+    // equal specificity, but lets always report that they can be dynamic.
+    for (const CSSSelector* selector = &m_selector; selector; selector = selector->tagHistory()) {
+        if (selector->match() == CSSSelector::PseudoClass) {
+            CSSSelector::PseudoClassType pseudoClassType = selector->pseudoClassType();
+            if (pseudoClassType == CSSSelector::PseudoClassMatches)
+                return true;
+            if (pseudoClassType == CSSSelector::PseudoClassNthChild || pseudoClassType == CSSSelector::PseudoClassNthLastChild) {
+                if (selector->selectorList())
+                    return true;
+                return false;
+            }
+        }
+    }
+
+    return false;
+}
+
+} // namespace Inspector
diff --git a/Source/WebCore/inspector/InspectorRuleSelector.h b/Source/WebCore/inspector/InspectorRuleSelector.h
new file mode 100644
index 0000000..04ddb29
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorRuleSelector.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorRuleSelector_h
+#define InspectorRuleSelector_h
+
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+class CSSSelector;
+class Element;
+}
+
+namespace Inspector {
+
+class StyleRule;
+
+class RuleSelector {
+    WTF_MAKE_NONCOPYABLE(RuleSelector);
+public:
+    RuleSelector(RuleSelector&&) = default;
+    RuleSelector(const WebCore::CSSSelector& selector, String selectorText)
+        : m_selector(selector)
+        , m_selectorText(selectorText)
+    {
+    }
+
+    String selectorText() const { return m_selectorText; }
+
+    // If hasDynamicSpecificity(), then specificity may change per-element if
+    // the selector multiply-matches the element (through :matches).
+    bool hasDynamicSpecificity() const;
+    unsigned staticSpecificity() const;
+    unsigned dynamicSpecificity(WebCore::Element&) const;
+    bool matchesElement(WebCore::Element&) const;
+
+private:
+    const WebCore::CSSSelector& m_selector;
+    String m_selectorText;
+};
+
+} // namespace Inspector
+
+#endif // InspectorRuleSelector_h
diff --git a/Source/WebCore/inspector/InspectorStyleDeclaration.cpp b/Source/WebCore/inspector/InspectorStyleDeclaration.cpp
new file mode 100644
index 0000000..bee845e
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleDeclaration.cpp
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorStyleRule.h"
+
+#include "CSSParser.h"
+#include "CSSPropertySourceData.h"
+#include "CSSStyleDeclaration.h"
+#include "InspectorCSSAgent.h"
+#include "InspectorStyleProperty.h"
+#include "InspectorStyleRuleSet.h"
+#include "Node.h"
+#include <inspector/ContentSearchUtilities.h>
+
+using namespace WebCore;
+
+namespace Inspector {
+
+StyleDeclaration::StyleDeclaration(const CSSId& styleId, CSSStyleDeclaration& declaration, StyleRuleSet* ruleSet)
+    : m_styleId(styleId)
+    , m_declaration(declaration)
+    , m_ruleSet(ruleSet)
+{
+}
+
+StyleDeclaration::~StyleDeclaration()
+{
+}
+
+void StyleDeclaration::populateProperties(Vector<StyleProperty>& result)
+{
+    HashSet<String> foundProperties;
+
+    if (RefPtr<WebCore::CSSRuleSourceData> sourceData = styleSourceData()) {
+        Vector<WebCore::CSSPropertySourceData>& sourcePropertyData = sourceData->styleSourceData->propertyData;
+
+        for (auto& data : sourcePropertyData) {
+            foundProperties.add(data.name.lower());
+            result.append(StyleProperty(*this, data, true));
+        }
+    }
+
+    for (int i = 0, size = m_declaration.length(); i < size; ++i) {
+        String name = m_declaration.item(i);
+        if (foundProperties.contains(name.lower()))
+            continue;
+
+        foundProperties.add(name.lower());
+        result.append(StyleProperty(*this, WebCore::CSSPropertySourceData(name, m_declaration.getPropertyValue(name), !m_declaration.getPropertyPriority(name).isEmpty(), true, WebCore::SourceRange()), false));
+    }
+}
+
+bool StyleDeclaration::getStyleText(String& result)
+{
+    RefPtr<CSSRuleSourceData> sourceData = styleSourceData();
+    if (!sourceData)
+        return false;
+
+    String stylesheetText = m_ruleSet->getText();
+    SourceRange& bodyRange = sourceData->ruleBodyRange;
+    result = stylesheetText.substring(bodyRange.start, bodyRange.end - bodyRange.start);
+    return true;
+}
+
+bool StyleDeclaration::getStyleTextRange(TextPosition& start, TextPosition& end)
+{
+    if (!isFromSource())
+        return false;
+
+    auto sourceData = styleSourceData();
+    auto lineEndings = m_ruleSet->parsedRuleSetData().lineEndings();
+    start = ContentSearchUtilities::textPositionFromOffset(sourceData->ruleBodyRange.start, lineEndings);
+    end = ContentSearchUtilities::textPositionFromOffset(sourceData->ruleBodyRange.end, lineEndings);
+    return true;
+}
+
+RefPtr<CSSRuleSourceData> StyleDeclaration::styleSourceData()
+{
+    return m_ruleSet ? m_ruleSet->sourceDataForStyle(m_declaration) : nullptr;
+}
+
+bool StyleDeclaration::setStyleText(const String& styleText)
+{
+    if (!m_ruleSet)
+        return false;
+
+    return m_ruleSet->setTextForStyle(m_declaration, styleText);
+}
+
+String StyleDeclaration::shorthandValue(const String& shorthandProperty)
+{
+    String value = m_declaration.getPropertyValue(shorthandProperty);
+    if (!value.isEmpty())
+        return value;
+    StringBuilder builder;
+    for (unsigned i = 0; i < m_declaration.length(); ++i) {
+        String individualProperty = m_declaration.item(i);
+        if (m_declaration.getPropertyShorthand(individualProperty) != shorthandProperty)
+            continue;
+        if (m_declaration.isPropertyImplicit(individualProperty))
+            continue;
+        String individualValue = m_declaration.getPropertyValue(individualProperty);
+        if (individualValue == "initial")
+            continue;
+        if (!builder.isEmpty())
+            builder.append(' ');
+        builder.append(individualValue);
+    }
+    return builder.toString();
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorStyleDeclaration.h b/Source/WebCore/inspector/InspectorStyleDeclaration.h
new file mode 100644
index 0000000..b0e1a5c
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleDeclaration.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStyleDeclaration_h
+#define InspectorStyleDeclaration_h
+
+#include "CSSStyleDeclaration.h"
+#include "InspectorCSSId.h"
+#include "InspectorStyleProperty.h"
+#include <inspector/InspectorProtocolObjects.h>
+#include <wtf/HashSet.h>
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+class CSSStyleDeclaration;
+struct CSSStyleSourceData;
+};
+
+namespace Inspector {
+
+class StyleRuleSet;
+class StyleProperty;
+
+class StyleDeclaration final {
+WTF_MAKE_NONCOPYABLE(StyleDeclaration);
+public:
+    StyleDeclaration(StyleDeclaration&&) = default;
+    StyleDeclaration(const CSSId& styleId, WebCore::CSSStyleDeclaration&, StyleRuleSet* ruleSet);
+    ~StyleDeclaration();
+
+    WebCore::CSSStyleDeclaration& declaration() { return m_declaration; }
+    RefPtr<WebCore::CSSRuleSourceData> styleSourceData();
+    CSSId styleId() const { return m_styleId; }
+    StyleRuleSet* styleRuleSet() const { return m_ruleSet; }
+
+    bool isFromSource() { return !!styleSourceData(); }
+
+    bool getStyleText(String& result);
+    bool setStyleText(const String&);
+
+    bool getStyleTextRange(TextPosition& start, TextPosition& end);
+
+    // StyleProperty objects are not heap-allocated to avoid cyclic reference counting.
+    // Thus, they are noncopyable and only available through a functor callback.
+    template<typename Functor>
+    typename Functor::ReturnType forEachProperty(Functor&);
+
+    // FIXME: remove
+    String shorthandValue(const String& shorthandProperty);
+
+private:
+    void populateProperties(Vector<StyleProperty>&);
+
+    CSSId m_styleId;
+    WebCore::CSSStyleDeclaration& m_declaration;
+    StyleRuleSet* m_ruleSet;
+};
+
+template<typename Functor>
+inline typename Functor::ReturnType StyleDeclaration::forEachProperty(Functor& functor)
+{
+    Vector<StyleProperty> properties;
+    populateProperties(properties);
+    for (StyleProperty& property : properties)
+        functor(property);
+
+    return functor.returnValue();
+}
+
+} // namespace Inspector
+
+#endif // InspectorStyleDeclaration_h
diff --git a/Source/WebCore/inspector/InspectorStyleProperty.cpp b/Source/WebCore/inspector/InspectorStyleProperty.cpp
new file mode 100644
index 0000000..12f7fe5
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleProperty.cpp
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorStyleProperty.h"
+
+#include "CSSStyleDeclaration.h"
+#include "InspectorStyleDeclaration.h"
+#include "InspectorStyleRuleSet.h"
+#include <inspector/ContentSearchUtilities.h>
+#include <wtf/text/StringBuilder.h>
+
+using namespace WebCore;
+
+namespace Inspector {
+
+String StyleProperty::rawText() const
+{
+    String styleText;
+    bool styleTextFound = m_style.getStyleText(styleText);
+    ASSERT_UNUSED(styleTextFound, styleTextFound);
+
+    unsigned start = m_sourceData.range.start;
+    unsigned end = m_sourceData.range.end;
+    ASSERT_WITH_SECURITY_IMPLICATION(start < end);
+    ASSERT(end <= styleText.length());
+    return styleText.substring(start, end - start);
+}
+
+void StyleProperty::getTextRange(TextPosition& start, TextPosition& end) const
+{
+    unsigned startOffset = m_style.styleSourceData()->ruleBodyRange.start;
+    SourceRange propertyRange = m_sourceData.range;
+
+    // The property range is relative to the style body start.
+    // Should be converted into an absolute range (relative to the stylesheet start)
+    // for the proper conversion into line:column.
+    auto lineEndings = m_style.styleRuleSet()->parsedRuleSetData().lineEndings();
+    start = ContentSearchUtilities::textPositionFromOffset(startOffset + propertyRange.start, lineEndings);
+    end = ContentSearchUtilities::textPositionFromOffset(startOffset + propertyRange.end, lineEndings);
+}
+
+bool StyleProperty::isImplicit() const
+{
+    return !isFromSource() && m_style.declaration().isPropertyImplicit(propertyName());
+}
+
+bool StyleProperty::isImportant() const
+{
+    return m_sourceData.important;
+}
+
+bool StyleProperty::parsedOk() const
+{
+    return m_sourceData.parsedOk;
+}
+
+String StyleProperty::propertyName() const
+{
+    return m_sourceData.name;
+}
+
+String StyleProperty::propertyValue() const
+{
+    return m_style.declaration().getPropertyValue(propertyName());
+}
+
+String StyleProperty::shorthandPropertyName() const
+{
+    return m_style.declaration().getPropertyShorthand(propertyName());
+}
+
+String StyleProperty::shorthandPropertyValue() const
+{
+    String explicitValue = propertyValue();
+    if (!explicitValue.isEmpty())
+        return explicitValue;
+
+    StringBuilder builder;
+    for (unsigned i = 0; i < m_style.declaration().length(); ++i) {
+        String individualProperty = m_style.declaration().item(i);
+        if (m_style.declaration().getPropertyShorthand(individualProperty) != shorthandPropertyName())
+            continue;
+        if (m_style.declaration().isPropertyImplicit(individualProperty))
+            continue;
+        String individualValue = m_style.declaration().getPropertyValue(individualProperty);
+        if (individualValue == "initial")
+            continue;
+        if (!builder.isEmpty())
+            builder.append(' ');
+        builder.append(individualValue);
+    }
+    return builder.toString();
+}
+
+} // namespace Inspector
diff --git a/Source/WebCore/inspector/InspectorStyleProperty.h b/Source/WebCore/inspector/InspectorStyleProperty.h
new file mode 100644
index 0000000..493ea1b
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleProperty.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStyleProperty_h
+#define InspectorStyleProperty_h
+
+#include "CSSPropertySourceData.h"
+
+namespace WebCore {
+class CSSStyleDeclaration;
+}
+
+namespace Inspector {
+
+class StyleDeclaration;
+
+class StyleProperty {
+    WTF_MAKE_NONCOPYABLE(StyleProperty);
+public:
+    StyleProperty(StyleProperty&&) = default;
+    StyleProperty(StyleDeclaration& style, WebCore::CSSPropertySourceData sourceData, bool isFromSource)
+        : m_sourceData(sourceData)
+        , m_style(style)
+        , m_fromSource(isFromSource)
+    {
+    }
+
+    // If not from source, then it's from a user or user-agent stylesheet
+    // or is an implicitly defined longhand property caused by a shorthand.
+    bool isImplicit() const;
+    bool isFromSource() const { return m_fromSource; }
+    bool isImportant() const;
+    bool parsedOk() const;
+
+    String rawText() const;
+    void getTextRange(TextPosition& start, TextPosition& end) const;
+
+    String propertyName() const;
+    String propertyValue() const;
+    String shorthandPropertyName() const;
+    String shorthandPropertyValue() const;
+private:
+    WebCore::CSSPropertySourceData m_sourceData;
+    StyleDeclaration& m_style;
+    bool m_fromSource;
+};
+
+} // namespace Inspector
+
+#endif // InspectorStyleProperty_h
diff --git a/Source/WebCore/inspector/InspectorStyleRule.cpp b/Source/WebCore/inspector/InspectorStyleRule.cpp
new file mode 100644
index 0000000..c75993b
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleRule.cpp
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorStyleRule.h"
+
+#include "CSSPropertySourceData.h"
+#include "CSSStyleRule.h"
+#include "InspectorStylesheetRuleSet.h"
+#include "StyleRule.h"
+#include <inspector/ContentSearchUtilities.h>
+#include <wtf/NeverDestroyed.h>
+#include <yarr/RegularExpression.h>
+
+using namespace WebCore;
+
+namespace Inspector {
+
+StyleRule::StyleRule(const CSSId& styleId, CSSStyleRule& rule, StyleRuleSet* ruleSet)
+    : m_ruleId(styleId)
+    , m_rule(rule)
+    , m_ruleSet(ruleSet)
+{
+    // We cannot store the subclass as a member, because it causes cyclic header
+    // dependencies between StylesheetRuleSet and StyleRule when downcasting in
+    // the inlined implementation of withRule().
+    ASSERT(is<StylesheetRuleSet>(m_ruleSet));
+}
+
+StyleRule::~StyleRule()
+{
+}
+
+StylesheetRuleSet* StyleRule::stylesheet() const
+{
+    if (!is<StylesheetRuleSet>(m_ruleSet))
+        return nullptr;
+
+    return downcast<StylesheetRuleSet>(m_ruleSet);
+}
+
+void StyleRule::populateSelectors(Vector<RuleSelector>& result)
+{
+    const CSSSelectorList& selectorList = m_rule.styleRule().selectorList();
+    if (RefPtr<CSSRuleSourceData> sourceData = ruleSourceData()) {
+        if (!stylesheet())
+            return;
+
+        String sheetText = stylesheet()->getText();
+        const SelectorRangeList& ranges = sourceData->selectorRanges;
+        const CSSSelector* selector = selectorList.first();
+        size_t i = 0;
+        for (; selector && i < ranges.size(); ++i, selector = CSSSelectorList::next(selector)) {
+            const SourceRange& range = ranges.at(i);
+            String selectorText = sheetText.substring(range.start, range.length());
+
+            // We don't want to see any comments in the selector components, only the meaningful parts.
+            NeverDestroyed<JSC::Yarr::RegularExpression> commentRegex("/\\*[^]*?\\*/", TextCaseSensitive, JSC::Yarr::MultilineEnabled);
+            replace(selectorText, commentRegex, String());
+            result.append(RuleSelector(*selector, selectorText.stripWhiteSpace()));
+        }
+        ASSERT_WITH_MESSAGE(i == ranges.size(), "Didn't populate all selectors because sourceData and actual rule selectors became desynced.");
+        return;
+    }
+
+    for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
+        result.append(RuleSelector(*selector, selector->selectorText()));
+}
+
+String StyleRule::selectorListText()
+{
+    return m_rule.selectorText();
+}
+
+bool StyleRule::getSelectorListTextRange(TextPosition& start, TextPosition& end)
+{
+    if (!isFromSource())
+        return false;
+
+    auto sourceData = ruleSourceData();
+    auto lineEndings = m_ruleSet->parsedRuleSetData().lineEndings();
+    start = ContentSearchUtilities::textPositionFromOffset(sourceData->ruleHeaderRange.start, lineEndings);
+    end = ContentSearchUtilities::textPositionFromOffset(sourceData->ruleHeaderRange.end, lineEndings);
+    return true;
+}
+
+bool StyleRule::hasSelectors()
+{
+    auto sourceData = ruleSourceData();
+    return sourceData && sourceData->selectorRanges.size() > 0;
+}
+
+RefPtr<CSSRuleSourceData> StyleRule::ruleSourceData()
+{
+    return m_ruleSet ? m_ruleSet->sourceDataForRule(m_rule) : nullptr;
+}
+
+int StyleRule::sourceLine() const
+{
+    return m_rule.styleRule().sourceLine();
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorStyleRule.h b/Source/WebCore/inspector/InspectorStyleRule.h
new file mode 100644
index 0000000..c4a8272
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleRule.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStyleRule_h
+#define InspectorStyleRule_h
+
+#include "CSSStyleRule.h"
+#include "InspectorCSSId.h"
+#include "InspectorRuleSelector.h"
+#include "InspectorStyleDeclaration.h"
+#include <inspector/InspectorProtocolObjects.h>
+#include <wtf/text/WTFString.h>
+
+namespace WebCore {
+struct CSSRuleSourceData;
+struct CSSStyleSourceData;
+};
+
+namespace Inspector {
+
+class RuleSelector;
+class StyleRuleSet;
+class StylesheetRuleSet;
+
+class StyleRule final {
+WTF_MAKE_NONCOPYABLE(StyleRule);
+public:
+    StyleRule(StyleRule&&) = default;
+    StyleRule(const CSSId& styleId, WebCore::CSSStyleRule&, StyleRuleSet* ruleSet);
+    ~StyleRule();
+
+    WebCore::CSSStyleRule& rule() { return m_rule; }
+    RefPtr<WebCore::CSSRuleSourceData> ruleSourceData();
+    CSSId ruleId() const { return m_ruleId; }
+    StylesheetRuleSet* stylesheet() const;
+
+    bool hasSelectors();
+    bool isFromSource() { return !!ruleSourceData(); }
+    int sourceLine() const;
+
+    String selectorListText();
+    bool getSelectorListTextRange(TextPosition& start, TextPosition& end);
+
+    void withStyle(const std::function<void(Inspector::StyleDeclaration&)>&);
+
+    template<typename Functor>
+    typename Functor::ReturnType forEachSelector(Functor&);
+
+private:
+    void populateSelectors(Vector<RuleSelector>&);
+
+    CSSId m_ruleId;
+    WebCore::CSSStyleRule& m_rule;
+    StyleRuleSet* m_ruleSet;
+};
+
+inline void StyleRule::withStyle(const std::function<void(Inspector::StyleDeclaration&)>& callback)
+{
+    StyleDeclaration style(ruleId(), m_rule.style(), m_ruleSet);
+    callback(style);
+}
+
+template<typename Functor>
+inline typename Functor::ReturnType StyleRule::forEachSelector(Functor& functor)
+{
+    Vector<RuleSelector> selectors;
+    populateSelectors(selectors);
+    for (RuleSelector& selector : selectors)
+        functor(selector);
+
+    return functor.returnValue();
+}
+
+} // namespace Inspector
+
+#endif // InspectorStyleRule_h
diff --git a/Source/WebCore/inspector/InspectorStyleRuleSet.cpp b/Source/WebCore/inspector/InspectorStyleRuleSet.cpp
new file mode 100644
index 0000000..58bac51
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleRuleSet.cpp
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorStyleRuleSet.h"
+
+#include "CSSImportRule.h"
+#include "CSSKeyframesRule.h"
+#include "CSSMediaRule.h"
+#include "CSSParser.h"
+#include "CSSRule.h"
+#include "CSSRuleList.h"
+#include "CSSSupportsRule.h"
+#include "CSSStyleSheet.h"
+#include "CSSStyleRule.h"
+#include "Element.h"
+#include "InspectorStyleRule.h"
+#include "InspectorStylesheetRuleSet.h" // For ParsedRuleSetData::create().
+#include "StyleSheetContents.h"
+#include <inspector/ContentSearchUtilities.h>
+
+using namespace WebCore;
+
+namespace Inspector {
+
+ParsedRuleSetData::ParsedRuleSetData(String sourceText, std::unique_ptr<RuleSourceDataList> sourceData, std::unique_ptr<StyleRuleList> styleRules)
+    : m_sourceText(sourceText)
+    , m_flattenedSourceData(WTF::move(sourceData))
+    , m_flattenedStyleRules(WTF::move(styleRules))
+{
+    if (!m_sourceText.isEmpty())
+        m_lineEndings = ContentSearchUtilities::lineEndings(m_sourceText);
+}
+
+static CSSParserContext parserContextForDocument(Document* document)
+{
+    return document ? CSSParserContext(*document) : strictCSSParserContext();
+}
+
+static void flattenSourceData(RuleSourceDataList& sourceDataList, RuleSourceDataList& flattenedDataList)
+{
+    for (auto& sourceData : sourceDataList) {
+        if (sourceData->type == CSSRuleSourceData::STYLE_RULE)
+            flattenedDataList.append(sourceData);
+        else if (sourceData->type == CSSRuleSourceData::MEDIA_RULE)
+            flattenSourceData(sourceData->childRules, flattenedDataList);
+        else if (sourceData->type == CSSRuleSourceData::SUPPORTS_RULE)
+            flattenSourceData(sourceData->childRules, flattenedDataList);
+    }
+}
+
+static void flattenStyleRules(CSSRuleList& ruleList, StyleRuleList& result);
+
+static void flattenStyleRules(RefPtr<CSSRule>&& rule, StyleRuleList& result)
+{
+    if (!rule)
+        return;
+
+    if (is<CSSStyleRule>(*rule)) {
+        result.append(&downcast<CSSStyleRule>(*rule));
+        return;
+    }
+
+    if (is<CSSMediaRule>(*rule))
+        flattenStyleRules(downcast<CSSMediaRule>(*rule).cssRules(), result);
+
+    if (is<CSSKeyframesRule>(*rule))
+        flattenStyleRules(downcast<CSSKeyframesRule>(*rule).cssRules(), result);
+
+    if (is<CSSSupportsRule>(*rule))
+        flattenStyleRules(downcast<CSSSupportsRule>(*rule).cssRules(), result);
+}
+
+static void flattenStyleRules(CSSRuleList& ruleList, StyleRuleList& result)
+{
+    for (unsigned i = 0; i < ruleList.length(); ++i)
+        flattenStyleRules(ruleList.item(i), result);
+}
+
+std::unique_ptr<ParsedRuleSetData> ParsedRuleSetData::create(StylesheetRuleSet& stylesheet)
+{
+    String originalStylesheetText;
+    if (!stylesheet.originalSourceText(originalStylesheetText))
+        return nullptr;
+
+    return ParsedRuleSetData::createWithText(stylesheet, originalStylesheetText);
+}
+
+std::unique_ptr<ParsedRuleSetData> ParsedRuleSetData::createEmpty()
+    {
+        return std::make_unique<ParsedRuleSetData>(emptyString(), std::make_unique<RuleSourceDataList>(), std::make_unique<StyleRuleList>());
+    }
+
+std::unique_ptr<ParsedRuleSetData> ParsedRuleSetData::createWithText(StylesheetRuleSet& stylesheet, const String& stylesheetText)
+{
+    CSSParser parser(parserContextForDocument(stylesheet.ownerDocument()));
+
+    RefPtr<StyleSheetContents> contents = StyleSheetContents::create();
+    int startLine = 0;
+    auto sourceData = std::make_unique<RuleSourceDataList>();
+    parser.parseSheet(contents.get(), stylesheetText, startLine, sourceData.get());
+
+    // FIXME: This is a temporary solution to retain the original flat sourceData structure
+    // containing only style rules, even though CSSParser now provides the full rule source data tree.
+    auto flattenedSourceData = std::make_unique<RuleSourceDataList>();
+    flattenSourceData(*sourceData, *flattenedSourceData);
+
+    auto flattenedRules = std::make_unique<StyleRuleList>();
+    auto ruleTree = stylesheet.pageStylesheet().cssRules();
+    flattenStyleRules(*ruleTree, *flattenedRules);
+
+    return std::make_unique<ParsedRuleSetData>(stylesheetText, WTF::move(flattenedSourceData), WTF::move(flattenedRules));
+}
+
+std::unique_ptr<ParsedRuleSetData> ParsedRuleSetData::create(Element& element)
+{
+    String sourceText = element.isStyledElement() ? element.getAttribute("style").string() : String();
+    auto sourceData = CSSRuleSourceData::create(CSSRuleSourceData::STYLE_RULE);
+
+    if (sourceText.isEmpty()) {
+        sourceData->ruleBodyRange.start = 0;
+        sourceData->ruleBodyRange.end = 0;
+    } else {
+        RefPtr<MutableStyleProperties> dummyDeclaration = MutableStyleProperties::create();
+        CSSParser parser(parserContextForDocument(&element.document()));
+        parser.parseDeclaration(dummyDeclaration.get(), sourceText, sourceData.get(), &element.document().elementSheet().contents());
+    }
+
+    auto sourceDataList = std::make_unique<RuleSourceDataList>(1);
+    sourceDataList->append(WTF::move(sourceData));
+
+    auto flattenedRules = std::make_unique<StyleRuleList>();
+    return std::make_unique<ParsedRuleSetData>(sourceText, WTF::move(sourceDataList), WTF::move(flattenedRules));
+}
+
+uint64_t StyleRuleSet::s_nextRuleSetId = 1;
+
+StyleRuleSet::StyleRuleSet()
+    : m_identifier(s_nextRuleSetId++)
+{
+}
+
+StyleRuleSet::~StyleRuleSet() { }
+
+void StyleRuleSet::commitRuleSetChange(std::unique_ptr<ParsedRuleSetData> parsedData)
+{
+    m_parsedRuleSetData = WTF::move(parsedData);
+    if (m_parsedRuleSetData) // If nullptr, we can invalidate without eagerly reparsing.
+        notifyRuleSetChanged();
+}
+
+ParsedRuleSetData& StyleRuleSet::parsedRuleSetData()
+{
+    if (!m_parsedRuleSetData)
+        m_parsedRuleSetData = originalSourceData();
+
+    if (!m_parsedRuleSetData)
+        m_parsedRuleSetData = ParsedRuleSetData::createEmpty();
+
+    ASSERT(m_parsedRuleSetData);
+    return *m_parsedRuleSetData;
+}
+
+const String& StyleRuleSet::getText()
+{
+    return parsedRuleSetData().sourceText();
+}
+
+static size_t sourceDataOrdinalForStyle(CSSStyleDeclaration& style, StyleRuleList& flattenedRules)
+{
+    for (size_t ruleOrdinal = 0; ruleOrdinal < flattenedRules.size(); ++ruleOrdinal)
+        if (&flattenedRules.at(ruleOrdinal)->style() == &style)
+            return ruleOrdinal;
+
+    return notFound;
+}
+
+CSSId StyleRuleSet::idForStyle(CSSStyleDeclaration& style)
+{
+    auto ruleOrdinal = sourceDataOrdinalForStyle(style, parsedRuleSetData().flattenedStyleRules());
+    return (ruleOrdinal != notFound) ? CSSId(identifier(), ruleOrdinal) : CSSId();
+}
+
+RefPtr<CSSRuleSourceData> StyleRuleSet::sourceDataForRule(CSSStyleRule& rule)
+{
+    auto& rules = parsedRuleSetData().flattenedStyleRules();
+    size_t ruleOrdinal = rules.find(&rule);
+    if (ruleOrdinal == notFound)
+        return nullptr;
+
+    auto& sourceData = parsedRuleSetData().flattenedSourceData();
+    return sourceData.at(ruleOrdinal);
+}
+
+RefPtr<CSSRuleSourceData> StyleRuleSet::sourceDataForStyle(CSSStyleDeclaration& style)
+{
+    size_t ordinal = sourceDataOrdinalForStyle(style, parsedRuleSetData().flattenedStyleRules());
+    return (ordinal != notFound) ? parsedRuleSetData().flattenedSourceData().at(ordinal) : nullptr;
+}
+
+} // namespace Inspector
diff --git a/Source/WebCore/inspector/InspectorStyleRuleSet.h b/Source/WebCore/inspector/InspectorStyleRuleSet.h
new file mode 100644
index 0000000..381a259
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleRuleSet.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStyleRuleSet_h
+#define InspectorStyleRuleSet_h
+
+#include "CSSPropertySourceData.h"
+#include <wtf/RefCounted.h>
+#include <wtf/Vector.h>
+#include <wtf/text/WTFString.h>
+
+// FIXME: remove
+#include <inspector/InspectorProtocolObjects.h>
+
+namespace WebCore {
+class CSSStyleDeclaration;
+class CSSStyleRule;
+class Document;
+class Element;
+
+typedef Vector<RefPtr<CSSStyleRule>> StyleRuleList;
+}
+
+namespace Inspector {
+
+class CSSId;
+class StyleRule;
+class StylesheetRuleSet;
+
+struct ParsedRuleSetData {
+    WTF_MAKE_NONCOPYABLE(ParsedRuleSetData);
+public:
+    ParsedRuleSetData(String, std::unique_ptr<WebCore::RuleSourceDataList>, std::unique_ptr<WebCore::StyleRuleList>);
+    static std::unique_ptr<ParsedRuleSetData> create(StylesheetRuleSet&);
+    static std::unique_ptr<ParsedRuleSetData> create(WebCore::Element&);
+    // This is used to parse modified stylesheet text. The original StyleSheetContents is
+    // immutable and will no longer match the stylesheet's text, rules and declarations.
+    static std::unique_ptr<ParsedRuleSetData> createWithText(StylesheetRuleSet&, const String& sourceText);
+    // For user and user agent stylesheets.
+    static std::unique_ptr<ParsedRuleSetData> createEmpty();
+
+    const String& sourceText() const { return m_sourceText; }
+    const Vector<size_t>& lineEndings() const
+    {
+        ASSERT(m_lineEndings);
+        return *m_lineEndings;
+    }
+    WebCore::RuleSourceDataList& flattenedSourceData() const
+    {
+        ASSERT(m_flattenedSourceData);
+        return *m_flattenedSourceData;
+    }
+    WebCore::StyleRuleList& flattenedStyleRules() const
+    {
+        ASSERT(m_flattenedStyleRules);
+        return *m_flattenedStyleRules;
+    }
+
+private:
+    String m_sourceText;
+    std::unique_ptr<Vector<size_t>> m_lineEndings;
+    std::unique_ptr<WebCore::RuleSourceDataList> m_flattenedSourceData;
+    std::unique_ptr<WebCore::StyleRuleList> m_flattenedStyleRules;
+};
+
+class StyleRuleSet : public RefCounted<StyleRuleSet> {
+public:
+    StyleRuleSet();
+    virtual ~StyleRuleSet();
+
+    uint64_t identifier() const { return m_identifier; }
+    virtual bool isStylesheet() const { return false; }
+    virtual bool isInlineStyle() const { return false; }
+
+    const String& getText();
+    virtual void replaceText(const String&) = 0;
+
+    virtual std::unique_ptr<ParsedRuleSetData> originalSourceData() = 0;
+
+    virtual void notifyRuleSetChanged() { }
+
+    virtual WebCore::Document* ownerDocument() const = 0;
+    virtual bool setTextForStyle(WebCore::CSSStyleDeclaration&, const String&) = 0;
+
+    // Return rule source data since it contains the style declaration range.
+    RefPtr<WebCore::CSSRuleSourceData> sourceDataForStyle(WebCore::CSSStyleDeclaration& style);
+    RefPtr<WebCore::CSSRuleSourceData> sourceDataForRule(WebCore::CSSStyleRule& rule);
+
+    CSSId idForStyle(WebCore::CSSStyleDeclaration&);
+
+    // FIXME: make protected again when protocol builders use StyleRule instead.
+    ParsedRuleSetData& parsedRuleSetData();
+protected:
+    void commitRuleSetChange(std::unique_ptr<ParsedRuleSetData>);
+
+private:
+    std::unique_ptr<ParsedRuleSetData> m_parsedRuleSetData;
+    uint64_t m_identifier;
+
+    static uint64_t s_nextRuleSetId;
+};
+
+} // namespace Inspector
+
+#endif // InspectorStyleRuleSet_h
diff --git a/Source/WebCore/inspector/InspectorStyleSheet.cpp b/Source/WebCore/inspector/InspectorStyleSheet.cpp
deleted file mode 100644
index 08bdbee..0000000
--- a/Source/WebCore/inspector/InspectorStyleSheet.cpp
+++ /dev/null
@@ -1,1354 +0,0 @@
-/*
- * Copyright (C) 2010, Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "InspectorStyleSheet.h"
-
-#include "CSSImportRule.h"
-#include "CSSKeyframesRule.h"
-#include "CSSMediaRule.h"
-#include "CSSParser.h"
-#include "CSSPropertyNames.h"
-#include "CSSPropertySourceData.h"
-#include "CSSRule.h"
-#include "CSSRuleList.h"
-#include "CSSStyleRule.h"
-#include "CSSStyleSheet.h"
-#include "CSSSupportsRule.h"
-#include "ContentSecurityPolicy.h"
-#include "Document.h"
-#include "Element.h"
-#include "HTMLHeadElement.h"
-#include "HTMLNames.h"
-#include "HTMLParserIdioms.h"
-#include "HTMLStyleElement.h"
-#include "InspectorCSSAgent.h"
-#include "InspectorPageAgent.h"
-#include "Node.h"
-#include "SVGElement.h"
-#include "SVGNames.h"
-#include "StyleProperties.h"
-#include "StyleResolver.h"
-#include "StyleRule.h"
-#include "StyleRuleImport.h"
-#include "StyleSheetContents.h"
-#include "StyleSheetList.h"
-#include <inspector/ContentSearchUtilities.h>
-#include <wtf/text/StringBuilder.h>
-#include <yarr/RegularExpression.h>
-
-using Inspector::Protocol::Array;
-using WebCore::RuleSourceDataList;
-using WebCore::CSSRuleSourceData;
-
-class ParsedStyleSheet {
-    WTF_MAKE_FAST_ALLOCATED;
-public:
-    ParsedStyleSheet();
-
-    const String& text() const { ASSERT(m_hasText); return m_text; }
-    void setText(const String& text);
-    bool hasText() const { return m_hasText; }
-    RuleSourceDataList* sourceData() const { return m_sourceData.get(); }
-    void setSourceData(std::unique_ptr<RuleSourceDataList>);
-    bool hasSourceData() const { return m_sourceData != nullptr; }
-    RefPtr<WebCore::CSSRuleSourceData> ruleSourceDataAt(unsigned) const;
-
-private:
-
-    String m_text;
-    bool m_hasText;
-    std::unique_ptr<RuleSourceDataList> m_sourceData;
-};
-
-ParsedStyleSheet::ParsedStyleSheet()
-    : m_hasText(false)
-{
-}
-
-void ParsedStyleSheet::setText(const String& text)
-{
-    m_hasText = true;
-    m_text = text;
-    setSourceData(nullptr);
-}
-
-static void flattenSourceData(RuleSourceDataList* dataList, RuleSourceDataList* target)
-{
-    for (size_t i = 0; i < dataList->size(); ++i) {
-        RefPtr<CSSRuleSourceData>& data = dataList->at(i);
-        if (data->type == CSSRuleSourceData::STYLE_RULE)
-            target->append(data);
-        else if (data->type == CSSRuleSourceData::MEDIA_RULE)
-            flattenSourceData(&data->childRules, target);
-        else if (data->type == CSSRuleSourceData::SUPPORTS_RULE)
-            flattenSourceData(&data->childRules, target);
-    }
-}
-
-void ParsedStyleSheet::setSourceData(std::unique_ptr<RuleSourceDataList> sourceData)
-{
-    if (!sourceData) {
-        m_sourceData.reset();
-        return;
-    }
-
-    m_sourceData = std::make_unique<RuleSourceDataList>();
-
-    // FIXME: This is a temporary solution to retain the original flat sourceData structure
-    // containing only style rules, even though CSSParser now provides the full rule source data tree.
-    // Normally, we should just assign m_sourceData = sourceData;
-    flattenSourceData(sourceData.get(), m_sourceData.get());
-}
-
-RefPtr<WebCore::CSSRuleSourceData> ParsedStyleSheet::ruleSourceDataAt(unsigned index) const
-{
-    if (!hasSourceData() || index >= m_sourceData->size())
-        return nullptr;
-
-    return m_sourceData->at(index);
-}
-
-using namespace Inspector;
-
-namespace WebCore {
-
-enum MediaListSource {
-    MediaListSourceLinkedSheet,
-    MediaListSourceInlineSheet,
-    MediaListSourceMediaRule,
-    MediaListSourceImportRule
-};
-
-static RefPtr<Inspector::Protocol::CSS::SourceRange> buildSourceRangeObject(const SourceRange& range, Vector<size_t>* lineEndings)
-{
-    if (!lineEndings)
-        return nullptr;
-    TextPosition start = ContentSearchUtilities::textPositionFromOffset(range.start, *lineEndings);
-    TextPosition end = ContentSearchUtilities::textPositionFromOffset(range.end, *lineEndings);
-
-    return Inspector::Protocol::CSS::SourceRange::create()
-        .setStartLine(start.m_line.zeroBasedInt())
-        .setStartColumn(start.m_column.zeroBasedInt())
-        .setEndLine(end.m_line.zeroBasedInt())
-        .setEndColumn(end.m_column.zeroBasedInt())
-        .release();
-}
-
-static Ref<Inspector::Protocol::CSS::CSSMedia> buildMediaObject(const MediaList* media, MediaListSource mediaListSource, const String& sourceURL)
-{
-    // Make certain compilers happy by initializing |source| up-front.
-    Inspector::Protocol::CSS::CSSMedia::Source source = Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;
-    switch (mediaListSource) {
-    case MediaListSourceMediaRule:
-        source = Inspector::Protocol::CSS::CSSMedia::Source::MediaRule;
-        break;
-    case MediaListSourceImportRule:
-        source = Inspector::Protocol::CSS::CSSMedia::Source::ImportRule;
-        break;
-    case MediaListSourceLinkedSheet:
-        source = Inspector::Protocol::CSS::CSSMedia::Source::LinkedSheet;
-        break;
-    case MediaListSourceInlineSheet:
-        source = Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;
-        break;
-    }
-
-    auto mediaObject = Inspector::Protocol::CSS::CSSMedia::create()
-        .setText(media->mediaText())
-        .setSource(source)
-        .release();
-
-    if (!sourceURL.isEmpty()) {
-        mediaObject->setSourceURL(sourceURL);
-        mediaObject->setSourceLine(media->queries()->lastLine());
-    }
-    return WTF::move(mediaObject);
-}
-
-static RefPtr<CSSRuleList> asCSSRuleList(CSSStyleSheet* styleSheet)
-{
-    if (!styleSheet)
-        return nullptr;
-
-    RefPtr<StaticCSSRuleList> list = StaticCSSRuleList::create();
-    Vector<RefPtr<CSSRule>>& listRules = list->rules();
-    for (unsigned i = 0, size = styleSheet->length(); i < size; ++i) {
-        CSSRule* item = styleSheet->item(i);
-        if (item->type() == CSSRule::CHARSET_RULE)
-            continue;
-        listRules.append(item);
-    }
-    return WTF::move(list);
-}
-
-static RefPtr<CSSRuleList> asCSSRuleList(CSSRule* rule)
-{
-    if (!rule)
-        return nullptr;
-
-    if (is<CSSMediaRule>(*rule))
-        return &downcast<CSSMediaRule>(*rule).cssRules();
-
-    if (is<CSSKeyframesRule>(*rule))
-        return &downcast<CSSKeyframesRule>(*rule).cssRules();
-
-    if (is<CSSSupportsRule>(*rule))
-        return &downcast<CSSSupportsRule>(*rule).cssRules();
-
-    return nullptr;
-}
-
-static void fillMediaListChain(CSSRule* rule, Array<Inspector::Protocol::CSS::CSSMedia>& mediaArray)
-{
-    MediaList* mediaList;
-    CSSRule* parentRule = rule;
-    String sourceURL;
-    while (parentRule) {
-        CSSStyleSheet* parentStyleSheet = nullptr;
-        bool isMediaRule = true;
-        if (is<CSSMediaRule>(*parentRule)) {
-            CSSMediaRule& mediaRule = downcast<CSSMediaRule>(*parentRule);
-            mediaList = mediaRule.media();
-            parentStyleSheet = mediaRule.parentStyleSheet();
-        } else if (is<CSSImportRule>(*parentRule)) {
-            CSSImportRule& importRule = downcast<CSSImportRule>(*parentRule);
-            mediaList = &importRule.media();
-            parentStyleSheet = importRule.parentStyleSheet();
-            isMediaRule = false;
-        } else
-            mediaList = nullptr;
-
-        if (parentStyleSheet) {
-            sourceURL = parentStyleSheet->contents().baseURL();
-            if (sourceURL.isEmpty())
-                sourceURL = InspectorDOMAgent::documentURLString(parentStyleSheet->ownerDocument());
-        } else
-            sourceURL = "";
-
-        if (mediaList && mediaList->length())
-            mediaArray.addItem(buildMediaObject(mediaList, isMediaRule ? MediaListSourceMediaRule : MediaListSourceImportRule, sourceURL));
-
-        if (parentRule->parentRule())
-            parentRule = parentRule->parentRule();
-        else {
-            CSSStyleSheet* styleSheet = parentRule->parentStyleSheet();
-            while (styleSheet) {
-                mediaList = styleSheet->media();
-                if (mediaList && mediaList->length()) {
-                    Document* doc = styleSheet->ownerDocument();
-                    if (doc)
-                        sourceURL = doc->url();
-                    else if (!styleSheet->contents().baseURL().isEmpty())
-                        sourceURL = styleSheet->contents().baseURL();
-                    else
-                        sourceURL = "";
-                    mediaArray.addItem(buildMediaObject(mediaList, styleSheet->ownerNode() ? MediaListSourceLinkedSheet : MediaListSourceInlineSheet, sourceURL));
-                }
-                parentRule = styleSheet->ownerRule();
-                if (parentRule)
-                    break;
-                styleSheet = styleSheet->parentStyleSheet();
-            }
-        }
-    }
-}
-
-static std::unique_ptr<CSSParser> createCSSParser(Document* document)
-{
-    return std::make_unique<CSSParser>(document ? CSSParserContext(*document) : strictCSSParserContext());
-}
-
-Ref<InspectorStyle> InspectorStyle::create(const InspectorCSSId& styleId, RefPtr<CSSStyleDeclaration>&& style, InspectorStyleSheet* parentStyleSheet)
-{
-    return adoptRef(*new InspectorStyle(styleId, WTF::move(style), parentStyleSheet));
-}
-
-InspectorStyle::InspectorStyle(const InspectorCSSId& styleId, RefPtr<CSSStyleDeclaration>&& style, InspectorStyleSheet* parentStyleSheet)
-    : m_styleId(styleId)
-    , m_style(style)
-    , m_parentStyleSheet(parentStyleSheet)
-{
-    ASSERT(m_style);
-}
-
-InspectorStyle::~InspectorStyle()
-{
-}
-
-RefPtr<Inspector::Protocol::CSS::CSSStyle> InspectorStyle::buildObjectForStyle() const
-{
-    Ref<Inspector::Protocol::CSS::CSSStyle> result = styleWithProperties();
-    if (!m_styleId.isEmpty())
-        result->setStyleId(m_styleId.asProtocolValue<Inspector::Protocol::CSS::CSSStyleId>());
-
-    result->setWidth(m_style->getPropertyValue("width"));
-    result->setHeight(m_style->getPropertyValue("height"));
-
-    RefPtr<CSSRuleSourceData> sourceData = extractSourceData();
-    if (sourceData)
-        result->setRange(buildSourceRangeObject(sourceData->ruleBodyRange, m_parentStyleSheet->lineEndings().get()));
-
-    return WTF::move(result);
-}
-
-Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> InspectorStyle::buildArrayForComputedStyle() const
-{
-    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>::create();
-    Vector<InspectorStyleProperty> properties;
-    populateAllProperties(&properties);
-
-    for (Vector<InspectorStyleProperty>::iterator it = properties.begin(), itEnd = properties.end(); it != itEnd; ++it) {
-        const CSSPropertySourceData& propertyEntry = it->sourceData;
-        auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
-            .setName(propertyEntry.name)
-            .setValue(propertyEntry.value)
-            .release();
-        result->addItem(WTF::move(entry));
-    }
-
-    return WTF::move(result);
-}
-
-bool InspectorStyle::getText(String* result) const
-{
-    // Precondition: m_parentStyleSheet->ensureParsedDataReady() has been called successfully.
-    RefPtr<CSSRuleSourceData> sourceData = extractSourceData();
-    if (!sourceData)
-        return false;
-
-    String styleSheetText;
-    bool success = m_parentStyleSheet->getText(&styleSheetText);
-    if (!success)
-        return false;
-
-    SourceRange& bodyRange = sourceData->ruleBodyRange;
-    *result = styleSheetText.substring(bodyRange.start, bodyRange.end - bodyRange.start);
-    return true;
-}
-
-bool InspectorStyle::populateAllProperties(Vector<InspectorStyleProperty>* result) const
-{
-    HashSet<String> sourcePropertyNames;
-
-    RefPtr<CSSRuleSourceData> sourceData = extractSourceData();
-    Vector<CSSPropertySourceData>* sourcePropertyData = sourceData ? &(sourceData->styleSourceData->propertyData) : nullptr;
-    if (sourcePropertyData) {
-        String styleDeclaration;
-        bool isStyleTextKnown = styleText(&styleDeclaration);
-        ASSERT_UNUSED(isStyleTextKnown, isStyleTextKnown);
-        for (Vector<CSSPropertySourceData>::const_iterator it = sourcePropertyData->begin(); it != sourcePropertyData->end(); ++it) {
-            InspectorStyleProperty p(*it, true, false);
-            p.setRawTextFromStyleDeclaration(styleDeclaration);
-            result->append(p);
-            sourcePropertyNames.add(it->name.lower());
-        }
-    }
-
-    for (int i = 0, size = m_style->length(); i < size; ++i) {
-        String name = m_style->item(i);
-        if (sourcePropertyNames.contains(name.lower()))
-            continue;
-
-        sourcePropertyNames.add(name.lower());
-        result->append(InspectorStyleProperty(CSSPropertySourceData(name, m_style->getPropertyValue(name), !m_style->getPropertyPriority(name).isEmpty(), true, SourceRange()), false, false));
-    }
-
-    return true;
-}
-
-Ref<Inspector::Protocol::CSS::CSSStyle> InspectorStyle::styleWithProperties() const
-{
-    Vector<InspectorStyleProperty> properties;
-    populateAllProperties(&properties);
-
-    auto propertiesObject = Array<Inspector::Protocol::CSS::CSSProperty>::create();
-    auto shorthandEntries = Array<Inspector::Protocol::CSS::ShorthandEntry>::create();
-    HashMap<String, RefPtr<Inspector::Protocol::CSS::CSSProperty>> propertyNameToPreviousActiveProperty;
-    HashSet<String> foundShorthands;
-    String previousPriority;
-    String previousStatus;
-    std::unique_ptr<Vector<size_t>> lineEndings(m_parentStyleSheet ? m_parentStyleSheet->lineEndings() : nullptr);
-    RefPtr<CSSRuleSourceData> sourceData = extractSourceData();
-    unsigned ruleBodyRangeStart = sourceData ? sourceData->ruleBodyRange.start : 0;
-
-    for (Vector<InspectorStyleProperty>::iterator it = properties.begin(), itEnd = properties.end(); it != itEnd; ++it) {
-        const CSSPropertySourceData& propertyEntry = it->sourceData;
-        const String& name = propertyEntry.name;
-
-        // Visual Studio disagrees with other compilers as to whether 'class' is needed here.
-#if COMPILER(MSVC)
-        enum class Protocol::CSS::CSSPropertyStatus status;
-#else
-        enum Inspector::Protocol::CSS::CSSPropertyStatus status;
-#endif
-        status = it->disabled ? Inspector::Protocol::CSS::CSSPropertyStatus::Disabled : Inspector::Protocol::CSS::CSSPropertyStatus::Active;
-
-        RefPtr<Inspector::Protocol::CSS::CSSProperty> property = Inspector::Protocol::CSS::CSSProperty::create()
-            .setName(name.lower())
-            .setValue(propertyEntry.value)
-            .release();
-
-        propertiesObject->addItem(property.copyRef());
-
-        // Default "parsedOk" == true.
-        if (!propertyEntry.parsedOk)
-            property->setParsedOk(false);
-        if (it->hasRawText())
-            property->setText(it->rawText);
-
-        // Default "priority" == "".
-        if (propertyEntry.important)
-            property->setPriority("important");
-        if (!it->disabled) {
-            if (it->hasSource) {
-                ASSERT(sourceData);
-                property->setImplicit(false);
-                // The property range is relative to the style body start.
-                // Should be converted into an absolute range (relative to the stylesheet start)
-                // for the proper conversion into line:column.
-                SourceRange absolutePropertyRange = propertyEntry.range;
-                absolutePropertyRange.start += ruleBodyRangeStart;
-                absolutePropertyRange.end += ruleBodyRangeStart;
-                property->setRange(buildSourceRangeObject(absolutePropertyRange, lineEndings.get()));
-
-                // Parsed property overrides any property with the same name. Non-parsed property overrides
-                // previous non-parsed property with the same name (if any).
-                bool shouldInactivate = false;
-                CSSPropertyID propertyId = cssPropertyID(name);
-                // Canonicalize property names to treat non-prefixed and vendor-prefixed property names the same (opacity vs. -webkit-opacity).
-                String canonicalPropertyName = propertyId ? getPropertyNameString(propertyId) : name;
-                HashMap<String, RefPtr<Inspector::Protocol::CSS::CSSProperty>>::iterator activeIt = propertyNameToPreviousActiveProperty.find(canonicalPropertyName);
-                if (activeIt != propertyNameToPreviousActiveProperty.end()) {
-                    if (propertyEntry.parsedOk) {
-                        bool successPriority = activeIt->value->getString(Inspector::Protocol::CSS::CSSProperty::Priority, previousPriority);
-                        bool successStatus = activeIt->value->getString(Inspector::Protocol::CSS::CSSProperty::Status, previousStatus);
-                        if (successStatus && previousStatus != "inactive") {
-                            if (propertyEntry.important || !successPriority) // Priority not set == "not important".
-                                shouldInactivate = true;
-                            else if (status == Inspector::Protocol::CSS::CSSPropertyStatus::Active) {
-                                // Inactivate a non-important property following the same-named important property.
-                                status = Inspector::Protocol::CSS::CSSPropertyStatus::Inactive;
-                            }
-                        }
-                    } else {
-                        bool previousParsedOk;
-                        bool success = activeIt->value->getBoolean(Inspector::Protocol::CSS::CSSProperty::ParsedOk, previousParsedOk);
-                        if (success && !previousParsedOk)
-                            shouldInactivate = true;
-                    }
-                } else
-                    propertyNameToPreviousActiveProperty.set(canonicalPropertyName, property);
-
-                if (shouldInactivate) {
-                    activeIt->value->setStatus(Inspector::Protocol::CSS::CSSPropertyStatus::Inactive);
-                    propertyNameToPreviousActiveProperty.set(canonicalPropertyName, property);
-                }
-            } else {
-                bool implicit = m_style->isPropertyImplicit(name);
-                // Default "implicit" == false.
-                if (implicit)
-                    property->setImplicit(true);
-                status = Inspector::Protocol::CSS::CSSPropertyStatus::Style;
-
-                String shorthand = m_style->getPropertyShorthand(name);
-                if (!shorthand.isEmpty()) {
-                    if (!foundShorthands.contains(shorthand)) {
-                        foundShorthands.add(shorthand);
-                        auto entry = Inspector::Protocol::CSS::ShorthandEntry::create()
-                            .setName(shorthand)
-                            .setValue(shorthandValue(shorthand))
-                            .release();
-                        shorthandEntries->addItem(WTF::move(entry));
-                    }
-                }
-            }
-        }
-
-        // Default "status" == "style".
-        if (status != Inspector::Protocol::CSS::CSSPropertyStatus::Style)
-            property->setStatus(status);
-    }
-
-    return Inspector::Protocol::CSS::CSSStyle::create()
-        .setCssProperties(WTF::move(propertiesObject))
-        .setShorthandEntries(WTF::move(shorthandEntries))
-        .release();
-}
-
-RefPtr<CSSRuleSourceData> InspectorStyle::extractSourceData() const
-{
-    if (!m_parentStyleSheet || !m_parentStyleSheet->ensureParsedDataReady())
-        return nullptr;
-    return m_parentStyleSheet->ruleSourceDataFor(m_style.get());
-}
-
-bool InspectorStyle::setText(const String& text, ExceptionCode& ec)
-{
-    return m_parentStyleSheet->setStyleText(m_style.get(), text, ec);
-}
-
-String InspectorStyle::shorthandValue(const String& shorthandProperty) const
-{
-    String value = m_style->getPropertyValue(shorthandProperty);
-    if (!value.isEmpty())
-        return value;
-    StringBuilder builder;
-    for (unsigned i = 0; i < m_style->length(); ++i) {
-        String individualProperty = m_style->item(i);
-        if (m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
-            continue;
-        if (m_style->isPropertyImplicit(individualProperty))
-            continue;
-        String individualValue = m_style->getPropertyValue(individualProperty);
-        if (individualValue == "initial")
-            continue;
-        if (!builder.isEmpty())
-            builder.append(' ');
-        builder.append(individualValue);
-    }
-    return builder.toString();
-}
-
-String InspectorStyle::shorthandPriority(const String& shorthandProperty) const
-{
-    String priority = m_style->getPropertyPriority(shorthandProperty);
-    if (priority.isEmpty()) {
-        for (unsigned i = 0; i < m_style->length(); ++i) {
-            String individualProperty = m_style->item(i);
-            if (m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
-                continue;
-            priority = m_style->getPropertyPriority(individualProperty);
-            break;
-        }
-    }
-    return priority;
-}
-
-Vector<String> InspectorStyle::longhandProperties(const String& shorthandProperty) const
-{
-    Vector<String> properties;
-    HashSet<String> foundProperties;
-    for (unsigned i = 0; i < m_style->length(); ++i) {
-        String individualProperty = m_style->item(i);
-        if (foundProperties.contains(individualProperty) || m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
-            continue;
-
-        foundProperties.add(individualProperty);
-        properties.append(individualProperty);
-    }
-    return properties;
-}
-
-Ref<InspectorStyleSheet> InspectorStyleSheet::create(InspectorPageAgent* pageAgent, const String& id, RefPtr<CSSStyleSheet>&& pageStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin origin, const String& documentURL, Listener* listener)
-{
-    return adoptRef(*new InspectorStyleSheet(pageAgent, id, WTF::move(pageStyleSheet), origin, documentURL, listener));
-}
-
-// static
-String InspectorStyleSheet::styleSheetURL(CSSStyleSheet* pageStyleSheet)
-{
-    if (pageStyleSheet && !pageStyleSheet->contents().baseURL().isEmpty())
-        return pageStyleSheet->contents().baseURL().string();
-    return emptyString();
-}
-
-InspectorStyleSheet::InspectorStyleSheet(InspectorPageAgent* pageAgent, const String& id, RefPtr<CSSStyleSheet>&& pageStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin origin, const String& documentURL, Listener* listener)
-    : m_pageAgent(pageAgent)
-    , m_id(id)
-    , m_pageStyleSheet(WTF::move(pageStyleSheet))
-    , m_origin(origin)
-    , m_documentURL(documentURL)
-    , m_listener(listener)
-{
-    m_parsedStyleSheet = new ParsedStyleSheet();
-}
-
-InspectorStyleSheet::~InspectorStyleSheet()
-{
-    delete m_parsedStyleSheet;
-}
-
-String InspectorStyleSheet::finalURL() const
-{
-    String url = styleSheetURL(m_pageStyleSheet.get());
-    return url.isEmpty() ? m_documentURL : url;
-}
-
-void InspectorStyleSheet::reparseStyleSheet(const String& text)
-{
-    {
-        // Have a separate scope for clearRules() (bug 95324).
-        CSSStyleSheet::RuleMutationScope mutationScope(m_pageStyleSheet.get());
-        m_pageStyleSheet->contents().clearRules();
-    }
-    {
-        CSSStyleSheet::RuleMutationScope mutationScope(m_pageStyleSheet.get());
-        m_pageStyleSheet->contents().parseString(text);
-        m_pageStyleSheet->clearChildRuleCSSOMWrappers();
-        fireStyleSheetChanged();
-    }
-
-    // We just wiped the entire contents of the stylesheet. Clear the mutation flag.
-    m_pageStyleSheet->clearHadRulesMutation();
-}
-
-bool InspectorStyleSheet::setText(const String& text, ExceptionCode& ec)
-{
-    if (!checkPageStyleSheet(ec))
-        return false;
-    if (!m_parsedStyleSheet)
-        return false;
-
-    m_parsedStyleSheet->setText(text);
-    m_flatRules.clear();
-
-    return true;
-}
-
-String InspectorStyleSheet::ruleSelector(const InspectorCSSId& id, ExceptionCode& ec)
-{
-    CSSStyleRule* rule = ruleForId(id);
-    if (!rule) {
-        ec = NOT_FOUND_ERR;
-        return "";
-    }
-    return rule->selectorText();
-}
-
-bool InspectorStyleSheet::setRuleSelector(const InspectorCSSId& id, const String& selector, ExceptionCode& ec)
-{
-    if (!checkPageStyleSheet(ec))
-        return false;
-    CSSStyleRule* rule = ruleForId(id);
-    if (!rule) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-    CSSStyleSheet* styleSheet = rule->parentStyleSheet();
-    if (!styleSheet || !ensureParsedDataReady()) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    rule->setSelectorText(selector);
-    RefPtr<CSSRuleSourceData> sourceData = ruleSourceDataFor(&rule->style());
-    if (!sourceData) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    String sheetText = m_parsedStyleSheet->text();
-    sheetText.replace(sourceData->ruleHeaderRange.start, sourceData->ruleHeaderRange.length(), selector);
-    m_parsedStyleSheet->setText(sheetText);
-    fireStyleSheetChanged();
-    return true;
-}
-
-static bool checkStyleRuleSelector(Document* document, const String& selector)
-{
-    CSSSelectorList selectorList;
-    createCSSParser(document)->parseSelector(selector, selectorList);
-    return selectorList.isValid();
-}
-
-CSSStyleRule* InspectorStyleSheet::addRule(const String& selector, ExceptionCode& ec)
-{
-    if (!checkPageStyleSheet(ec))
-        return nullptr;
-    if (!checkStyleRuleSelector(m_pageStyleSheet->ownerDocument(), selector)) {
-        ec = SYNTAX_ERR;
-        return nullptr;
-    }
-
-    String text;
-    bool success = getText(&text);
-    if (!success) {
-        ec = NOT_FOUND_ERR;
-        return nullptr;
-    }
-    StringBuilder styleSheetText;
-    styleSheetText.append(text);
-
-    m_pageStyleSheet->addRule(selector, "", ec);
-    if (ec)
-        return nullptr;
-    ASSERT(m_pageStyleSheet->length());
-    unsigned lastRuleIndex = m_pageStyleSheet->length() - 1;
-    CSSRule* rule = m_pageStyleSheet->item(lastRuleIndex);
-    ASSERT(rule);
-
-    CSSStyleRule* styleRule = InspectorCSSAgent::asCSSStyleRule(*rule);
-    if (!styleRule) {
-        // What we just added has to be a CSSStyleRule - we cannot handle other types of rules yet.
-        // If it is not a style rule, pretend we never touched the stylesheet.
-        m_pageStyleSheet->deleteRule(lastRuleIndex, ASSERT_NO_EXCEPTION);
-        ec = SYNTAX_ERR;
-        return nullptr;
-    }
-
-    if (!styleSheetText.isEmpty())
-        styleSheetText.append('\n');
-
-    styleSheetText.append(selector);
-    styleSheetText.appendLiteral(" {}");
-    // Using setText() as this operation changes the style sheet rule set.
-    setText(styleSheetText.toString(), ASSERT_NO_EXCEPTION);
-
-    fireStyleSheetChanged();
-
-    return styleRule;
-}
-
-bool InspectorStyleSheet::deleteRule(const InspectorCSSId& id, ExceptionCode& ec)
-{
-    if (!checkPageStyleSheet(ec))
-        return false;
-    RefPtr<CSSStyleRule> rule = ruleForId(id);
-    if (!rule) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-    CSSStyleSheet* styleSheet = rule->parentStyleSheet();
-    if (!styleSheet || !ensureParsedDataReady()) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    RefPtr<CSSRuleSourceData> sourceData = ruleSourceDataFor(&rule->style());
-    if (!sourceData) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    styleSheet->deleteRule(id.ordinal(), ec);
-    // |rule| MAY NOT be addressed after this line!
-
-    if (ec)
-        return false;
-
-    String sheetText = m_parsedStyleSheet->text();
-    sheetText.remove(sourceData->ruleHeaderRange.start, sourceData->ruleBodyRange.end - sourceData->ruleHeaderRange.start + 1);
-    setText(sheetText, ASSERT_NO_EXCEPTION);
-    fireStyleSheetChanged();
-    return true;
-}
-
-CSSStyleRule* InspectorStyleSheet::ruleForId(const InspectorCSSId& id) const
-{
-    if (!m_pageStyleSheet)
-        return nullptr;
-
-    ASSERT(!id.isEmpty());
-    ensureFlatRules();
-    return id.ordinal() >= m_flatRules.size() ? nullptr : m_flatRules.at(id.ordinal()).get();
-}
-
-RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> InspectorStyleSheet::buildObjectForStyleSheet()
-{
-    CSSStyleSheet* styleSheet = pageStyleSheet();
-    if (!styleSheet)
-        return nullptr;
-
-    RefPtr<CSSRuleList> cssRuleList = asCSSRuleList(styleSheet);
-
-    auto result = Inspector::Protocol::CSS::CSSStyleSheetBody::create()
-        .setStyleSheetId(id())
-        .setRules(buildArrayForRuleList(cssRuleList.get()))
-        .release();
-
-    String styleSheetText;
-    bool success = getText(&styleSheetText);
-    if (success)
-        result->setText(styleSheetText);
-
-    return WTF::move(result);
-}
-
-RefPtr<Inspector::Protocol::CSS::CSSStyleSheetHeader> InspectorStyleSheet::buildObjectForStyleSheetInfo()
-{
-    CSSStyleSheet* styleSheet = pageStyleSheet();
-    if (!styleSheet)
-        return nullptr;
-
-    Document* document = styleSheet->ownerDocument();
-    Frame* frame = document ? document->frame() : nullptr;
-    return Inspector::Protocol::CSS::CSSStyleSheetHeader::create()
-        .setStyleSheetId(id())
-        .setOrigin(m_origin)
-        .setDisabled(styleSheet->disabled())
-        .setSourceURL(finalURL())
-        .setTitle(styleSheet->title())
-        .setFrameId(m_pageAgent->frameId(frame))
-        .release();
-}
-
-static bool hasDynamicSpecificity(const CSSSelector& simpleSelector)
-{
-    // It is possible that these can have a static specificity if each selector in the list has
-    // equal specificity, but lets always report that they can be dynamic.
-    for (const CSSSelector* selector = &simpleSelector; selector; selector = selector->tagHistory()) {
-        if (selector->match() == CSSSelector::PseudoClass) {
-            CSSSelector::PseudoClassType pseudoClassType = selector->pseudoClassType();
-            if (pseudoClassType == CSSSelector::PseudoClassMatches)
-                return true;
-            if (pseudoClassType == CSSSelector::PseudoClassNthChild || pseudoClassType == CSSSelector::PseudoClassNthLastChild) {
-                if (selector->selectorList())
-                    return true;
-                return false;
-            }
-        }
-    }
-
-    return false;
-}
-
-static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelectorHelper(const String& selectorText, const CSSSelector& selector, Element* element)
-{
-    auto inspectorSelector = Inspector::Protocol::CSS::CSSSelector::create()
-        .setText(selectorText)
-        .release();
-
-    if (element) {
-        bool dynamic = hasDynamicSpecificity(selector);
-        if (dynamic)
-            inspectorSelector->setDynamic(true);
-
-        SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
-        SelectorChecker selectorChecker(element->document());
-
-        unsigned specificity;
-        bool okay = selectorChecker.match(&selector, element, context, specificity);
-        if (!okay)
-            specificity = selector.staticSpecificity(okay);
-
-        if (okay) {
-            auto tuple = Inspector::Protocol::Array<int>::create();
-            tuple->addItem(static_cast<int>((specificity & CSSSelector::idMask) >> 16));
-            tuple->addItem(static_cast<int>((specificity & CSSSelector::classMask) >> 8));
-            tuple->addItem(static_cast<int>(specificity & CSSSelector::elementMask));
-            inspectorSelector->setSpecificity(WTF::move(tuple));
-        }
-    }
-
-    return WTF::move(inspectorSelector);
-}
-
-static Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> selectorsFromSource(const CSSRuleSourceData* sourceData, const String& sheetText, const CSSSelectorList& selectorList, Element* element)
-{
-    DEPRECATED_DEFINE_STATIC_LOCAL(JSC::Yarr::RegularExpression, comment, ("/\\*[^]*?\\*/", TextCaseSensitive, JSC::Yarr::MultilineEnabled));
-
-    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>::create();
-    const SelectorRangeList& ranges = sourceData->selectorRanges;
-    const CSSSelector* selector = selectorList.first();
-    for (size_t i = 0, size = ranges.size(); i < size; ++i) {
-        // If we don't have a selector, that means the SourceData for this CSSStyleSheet
-        // no longer matches up with the actual rules in the CSSStyleSheet.
-        ASSERT(selector);
-        if (!selector)
-            break;
-
-        const SourceRange& range = ranges.at(i);
-        String selectorText = sheetText.substring(range.start, range.length());
-
-        // We don't want to see any comments in the selector components, only the meaningful parts.
-        replace(selectorText, comment, String());
-        result->addItem(buildObjectForSelectorHelper(selectorText.stripWhiteSpace(), *selector, element));
-
-        selector = CSSSelectorList::next(selector);
-    }
-    return WTF::move(result);
-}
-
-Ref<Inspector::Protocol::CSS::CSSSelector> InspectorStyleSheet::buildObjectForSelector(const CSSSelector* selector, Element* element)
-{
-    return buildObjectForSelectorHelper(selector->selectorText(), *selector, element);
-}
-
-Ref<Inspector::Protocol::CSS::SelectorList> InspectorStyleSheet::buildObjectForSelectorList(CSSStyleRule* rule, Element* element)
-{
-    RefPtr<CSSRuleSourceData> sourceData;
-    if (ensureParsedDataReady())
-        sourceData = ruleSourceDataFor(&rule->style());
-    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> selectors;
-
-    // This intentionally does not rely on the source data to avoid catching the trailing comments (before the declaration starting '{').
-    String selectorText = rule->selectorText();
-
-    if (sourceData)
-        selectors = selectorsFromSource(sourceData.get(), m_parsedStyleSheet->text(), rule->styleRule().selectorList(), element);
-    else {
-        selectors = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>::create();
-        const CSSSelectorList& selectorList = rule->styleRule().selectorList();
-        for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
-            selectors->addItem(buildObjectForSelector(selector, element));
-    }
-    auto result = Inspector::Protocol::CSS::SelectorList::create()
-        .setSelectors(selectors.release())
-        .setText(selectorText)
-        .release();
-    if (sourceData)
-        result->setRange(buildSourceRangeObject(sourceData->ruleHeaderRange, lineEndings().get()));
-    return WTF::move(result);
-}
-
-RefPtr<Inspector::Protocol::CSS::CSSRule> InspectorStyleSheet::buildObjectForRule(CSSStyleRule* rule, Element* element)
-{
-    CSSStyleSheet* styleSheet = pageStyleSheet();
-    if (!styleSheet)
-        return nullptr;
-
-    auto result = Inspector::Protocol::CSS::CSSRule::create()
-        .setSelectorList(buildObjectForSelectorList(rule, element))
-        .setSourceLine(rule->styleRule().sourceLine())
-        .setOrigin(m_origin)
-        .setStyle(buildObjectForStyle(&rule->style()))
-        .release();
-
-    // "sourceURL" is present only for regular rules, otherwise "origin" should be used in the frontend.
-    if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::Regular)
-        result->setSourceURL(finalURL());
-
-    if (canBind()) {
-        InspectorCSSId id(ruleId(rule));
-        if (!id.isEmpty())
-            result->setRuleId(id.asProtocolValue<Inspector::Protocol::CSS::CSSRuleId>());
-    }
-
-    auto mediaArray = Array<Inspector::Protocol::CSS::CSSMedia>::create();
-
-    fillMediaListChain(rule, mediaArray.get());
-    if (mediaArray->length())
-        result->setMedia(WTF::move(mediaArray));
-
-    return WTF::move(result);
-}
-
-RefPtr<Inspector::Protocol::CSS::CSSStyle> InspectorStyleSheet::buildObjectForStyle(CSSStyleDeclaration* style)
-{
-    RefPtr<CSSRuleSourceData> sourceData;
-    if (ensureParsedDataReady())
-        sourceData = ruleSourceDataFor(style);
-
-    InspectorCSSId id = ruleOrStyleId(style);
-    if (id.isEmpty()) {
-        return Inspector::Protocol::CSS::CSSStyle::create()
-            .setCssProperties(Array<Inspector::Protocol::CSS::CSSProperty>::create())
-            .setShorthandEntries(Array<Inspector::Protocol::CSS::ShorthandEntry>::create())
-            .release();
-    }
-    RefPtr<InspectorStyle> inspectorStyle = inspectorStyleForId(id);
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> result = inspectorStyle->buildObjectForStyle();
-
-    // Style text cannot be retrieved without stylesheet, so set cssText here.
-    if (sourceData) {
-        String sheetText;
-        bool success = getText(&sheetText);
-        if (success) {
-            const SourceRange& bodyRange = sourceData->ruleBodyRange;
-            result->setCssText(sheetText.substring(bodyRange.start, bodyRange.end - bodyRange.start));
-        }
-    }
-
-    return WTF::move(result);
-}
-
-bool InspectorStyleSheet::setStyleText(const InspectorCSSId& id, const String& text, String* oldText, ExceptionCode& ec)
-{
-    RefPtr<InspectorStyle> inspectorStyle = inspectorStyleForId(id);
-    if (!inspectorStyle) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    if (oldText && !inspectorStyle->getText(oldText))
-        return false;
-
-    bool success = inspectorStyle->setText(text, ec);
-    if (success)
-        fireStyleSheetChanged();
-    return success;
-}
-
-bool InspectorStyleSheet::getText(String* result) const
-{
-    if (!ensureText())
-        return false;
-    *result = m_parsedStyleSheet->text();
-    return true;
-}
-
-CSSStyleDeclaration* InspectorStyleSheet::styleForId(const InspectorCSSId& id) const
-{
-    CSSStyleRule* rule = ruleForId(id);
-    if (!rule)
-        return nullptr;
-
-    return &rule->style();
-}
-
-void InspectorStyleSheet::fireStyleSheetChanged()
-{
-    if (m_listener)
-        m_listener->styleSheetChanged(this);
-}
-
-RefPtr<InspectorStyle> InspectorStyleSheet::inspectorStyleForId(const InspectorCSSId& id)
-{
-    CSSStyleDeclaration* style = styleForId(id);
-    if (!style)
-        return nullptr;
-
-    return InspectorStyle::create(id, style, this);
-}
-
-InspectorCSSId InspectorStyleSheet::ruleOrStyleId(CSSStyleDeclaration* style) const
-{
-    unsigned index = ruleIndexByStyle(style);
-    if (index != UINT_MAX)
-        return InspectorCSSId(id(), index);
-    return InspectorCSSId();
-}
-
-Document* InspectorStyleSheet::ownerDocument() const
-{
-    return m_pageStyleSheet->ownerDocument();
-}
-
-RefPtr<CSSRuleSourceData> InspectorStyleSheet::ruleSourceDataFor(CSSStyleDeclaration* style) const
-{
-    return m_parsedStyleSheet->ruleSourceDataAt(ruleIndexByStyle(style));
-}
-
-std::unique_ptr<Vector<size_t>> InspectorStyleSheet::lineEndings() const
-{
-    if (!m_parsedStyleSheet->hasText())
-        return nullptr;
-    return ContentSearchUtilities::lineEndings(m_parsedStyleSheet->text());
-}
-
-unsigned InspectorStyleSheet::ruleIndexByStyle(CSSStyleDeclaration* pageStyle) const
-{
-    ensureFlatRules();
-    unsigned index = 0;
-    for (unsigned i = 0, size = m_flatRules.size(); i < size; ++i) {
-        if (&m_flatRules.at(i)->style() == pageStyle)
-            return index;
-
-        ++index;
-    }
-    return UINT_MAX;
-}
-
-bool InspectorStyleSheet::checkPageStyleSheet(ExceptionCode& ec) const
-{
-    if (!m_pageStyleSheet) {
-        ec = NOT_SUPPORTED_ERR;
-        return false;
-    }
-    return true;
-}
-
-bool InspectorStyleSheet::styleSheetMutated() const
-{
-    return m_pageStyleSheet && m_pageStyleSheet->hadRulesMutation();
-}
-
-bool InspectorStyleSheet::ensureParsedDataReady()
-{
-    return !styleSheetMutated() && ensureText() && ensureSourceData();
-}
-
-bool InspectorStyleSheet::ensureText() const
-{
-    if (!m_parsedStyleSheet)
-        return false;
-    if (m_parsedStyleSheet->hasText())
-        return true;
-
-    String text;
-    bool success = originalStyleSheetText(&text);
-    if (success)
-        m_parsedStyleSheet->setText(text);
-    // No need to clear m_flatRules here - it's empty.
-
-    return success;
-}
-
-bool InspectorStyleSheet::ensureSourceData()
-{
-    if (m_parsedStyleSheet->hasSourceData())
-        return true;
-
-    if (!m_parsedStyleSheet->hasText())
-        return false;
-
-    RefPtr<StyleSheetContents> newStyleSheet = StyleSheetContents::create();
-    auto ruleSourceDataResult = std::make_unique<RuleSourceDataList>();
-    createCSSParser(m_pageStyleSheet->ownerDocument())->parseSheet(newStyleSheet.get(), m_parsedStyleSheet->text(), 0, ruleSourceDataResult.get());
-    m_parsedStyleSheet->setSourceData(WTF::move(ruleSourceDataResult));
-    return m_parsedStyleSheet->hasSourceData();
-}
-
-void InspectorStyleSheet::ensureFlatRules() const
-{
-    // We are fine with redoing this for empty stylesheets as this will run fast.
-    if (m_flatRules.isEmpty())
-        collectFlatRules(asCSSRuleList(pageStyleSheet()), &m_flatRules);
-}
-
-bool InspectorStyleSheet::setStyleText(CSSStyleDeclaration* style, const String& text, ExceptionCode& ec)
-{
-    if (!m_pageStyleSheet)
-        return false;
-    if (!ensureParsedDataReady())
-        return false;
-
-    String patchedStyleSheetText;
-    bool success = styleSheetTextWithChangedStyle(style, text, &patchedStyleSheetText);
-    if (!success)
-        return false;
-
-    InspectorCSSId id = ruleOrStyleId(style);
-    if (id.isEmpty())
-        return false;
-
-    style->setCssText(text, ec);
-    if (!ec)
-        m_parsedStyleSheet->setText(patchedStyleSheetText);
-
-    return !ec;
-}
-
-bool InspectorStyleSheet::styleSheetTextWithChangedStyle(CSSStyleDeclaration* style, const String& newStyleText, String* result)
-{
-    if (!style)
-        return false;
-
-    if (!ensureParsedDataReady())
-        return false;
-
-    RefPtr<CSSRuleSourceData> sourceData = ruleSourceDataFor(style);
-    unsigned bodyStart = sourceData->ruleBodyRange.start;
-    unsigned bodyEnd = sourceData->ruleBodyRange.end;
-    ASSERT(bodyStart <= bodyEnd);
-
-    String text = m_parsedStyleSheet->text();
-    ASSERT_WITH_SECURITY_IMPLICATION(bodyEnd <= text.length()); // bodyEnd is exclusive
-
-    text.replace(bodyStart, bodyEnd - bodyStart, newStyleText);
-    *result = text;
-    return true;
-}
-
-InspectorCSSId InspectorStyleSheet::ruleId(CSSStyleRule* rule) const
-{
-    return ruleOrStyleId(&rule->style());
-}
-
-bool InspectorStyleSheet::originalStyleSheetText(String* result) const
-{
-    bool success = inlineStyleSheetText(result);
-    if (!success)
-        success = resourceStyleSheetText(result);
-    return success;
-}
-
-bool InspectorStyleSheet::resourceStyleSheetText(String* result) const
-{
-    if (m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::User || m_origin == Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent)
-        return false;
-
-    if (!m_pageStyleSheet || !ownerDocument() || !ownerDocument()->frame())
-        return false;
-
-    String error;
-    bool base64Encoded;
-    InspectorPageAgent::resourceContent(error, ownerDocument()->frame(), URL(ParsedURLString, m_pageStyleSheet->href()), result, &base64Encoded);
-    return error.isEmpty() && !base64Encoded;
-}
-
-bool InspectorStyleSheet::inlineStyleSheetText(String* result) const
-{
-    if (!m_pageStyleSheet)
-        return false;
-
-    Node* ownerNode = m_pageStyleSheet->ownerNode();
-    if (!is<Element>(ownerNode))
-        return false;
-    Element& ownerElement = downcast<Element>(*ownerNode);
-
-    if (!is<HTMLStyleElement>(ownerElement) && !is<SVGStyleElement>(ownerElement))
-        return false;
-    *result = ownerElement.textContent();
-    return true;
-}
-
-Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> InspectorStyleSheet::buildArrayForRuleList(CSSRuleList* ruleList)
-{
-    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>::create();
-    if (!ruleList)
-        return WTF::move(result);
-
-    RefPtr<CSSRuleList> refRuleList = ruleList;
-    CSSStyleRuleVector rules;
-    collectFlatRules(WTF::move(refRuleList), &rules);
-
-    for (unsigned i = 0, size = rules.size(); i < size; ++i)
-        result->addItem(buildObjectForRule(rules.at(i).get(), nullptr));
-
-    return WTF::move(result);
-}
-
-void InspectorStyleSheet::collectFlatRules(RefPtr<CSSRuleList>&& ruleList, CSSStyleRuleVector* result)
-{
-    if (!ruleList)
-        return;
-
-    for (unsigned i = 0, size = ruleList->length(); i < size; ++i) {
-        CSSRule* rule = ruleList->item(i);
-        CSSStyleRule* styleRule = InspectorCSSAgent::asCSSStyleRule(*rule);
-        if (styleRule)
-            result->append(styleRule);
-        else {
-            RefPtr<CSSRuleList> childRuleList = asCSSRuleList(rule);
-            if (childRuleList)
-                collectFlatRules(WTF::move(childRuleList), result);
-        }
-    }
-}
-
-Ref<InspectorStyleSheetForInlineStyle> InspectorStyleSheetForInlineStyle::create(InspectorPageAgent* pageAgent, const String& id, RefPtr<Element>&& element, Inspector::Protocol::CSS::StyleSheetOrigin origin, Listener* listener)
-{
-    return adoptRef(*new InspectorStyleSheetForInlineStyle(pageAgent, id, WTF::move(element), origin, listener));
-}
-
-InspectorStyleSheetForInlineStyle::InspectorStyleSheetForInlineStyle(InspectorPageAgent* pageAgent, const String& id, RefPtr<Element>&& element, Inspector::Protocol::CSS::StyleSheetOrigin origin, Listener* listener)
-    : InspectorStyleSheet(pageAgent, id, nullptr, origin, String(), listener)
-    , m_element(WTF::move(element))
-    , m_ruleSourceData(nullptr)
-    , m_isStyleTextValid(false)
-{
-    ASSERT(m_element);
-    m_inspectorStyle = InspectorStyle::create(InspectorCSSId(id, 0), inlineStyle(), this);
-    m_styleText = m_element->isStyledElement() ? m_element->getAttribute("style").string() : String();
-}
-
-void InspectorStyleSheetForInlineStyle::didModifyElementAttribute()
-{
-    m_isStyleTextValid = false;
-    if (m_element->isStyledElement() && m_element->style() != m_inspectorStyle->cssStyle())
-        m_inspectorStyle = InspectorStyle::create(InspectorCSSId(id(), 0), inlineStyle(), this);
-    m_ruleSourceData.clear();
-}
-
-bool InspectorStyleSheetForInlineStyle::getText(String* result) const
-{
-    if (!m_isStyleTextValid) {
-        m_styleText = elementStyleText();
-        m_isStyleTextValid = true;
-    }
-    *result = m_styleText;
-    return true;
-}
-
-bool InspectorStyleSheetForInlineStyle::setStyleText(CSSStyleDeclaration* style, const String& text, ExceptionCode& ec)
-{
-    ASSERT_UNUSED(style, style == inlineStyle());
-
-    {
-        InspectorCSSAgent::InlineStyleOverrideScope overrideScope(&m_element->document());
-        m_element->setAttribute("style", text, ec);
-    }
-
-    m_styleText = text;
-    m_isStyleTextValid = true;
-    m_ruleSourceData.clear();
-    return !ec;
-}
-
-std::unique_ptr<Vector<size_t>> InspectorStyleSheetForInlineStyle::lineEndings() const
-{
-    return ContentSearchUtilities::lineEndings(elementStyleText());
-}
-
-Document* InspectorStyleSheetForInlineStyle::ownerDocument() const
-{
-    return &m_element->document();
-}
-
-bool InspectorStyleSheetForInlineStyle::ensureParsedDataReady()
-{
-    // The "style" property value can get changed indirectly, e.g. via element.style.borderWidth = "2px".
-    const String& currentStyleText = elementStyleText();
-    if (m_styleText != currentStyleText) {
-        m_ruleSourceData.clear();
-        m_styleText = currentStyleText;
-        m_isStyleTextValid = true;
-    }
-
-    if (m_ruleSourceData)
-        return true;
-
-    m_ruleSourceData = CSSRuleSourceData::create(CSSRuleSourceData::STYLE_RULE);
-    bool success = getStyleAttributeRanges(m_ruleSourceData.get());
-    if (!success)
-        return false;
-
-    return true;
-}
-
-RefPtr<InspectorStyle> InspectorStyleSheetForInlineStyle::inspectorStyleForId(const InspectorCSSId& id)
-{
-    ASSERT_UNUSED(id, !id.ordinal());
-    return m_inspectorStyle.copyRef();
-}
-
-CSSStyleDeclaration* InspectorStyleSheetForInlineStyle::inlineStyle() const
-{
-    return m_element->style();
-}
-
-const String& InspectorStyleSheetForInlineStyle::elementStyleText() const
-{
-    return m_element->getAttribute("style").string();
-}
-
-bool InspectorStyleSheetForInlineStyle::getStyleAttributeRanges(CSSRuleSourceData* result) const
-{
-    if (!m_element->isStyledElement())
-        return false;
-
-    if (m_styleText.isEmpty()) {
-        result->ruleBodyRange.start = 0;
-        result->ruleBodyRange.end = 0;
-        return true;
-    }
-
-    RefPtr<MutableStyleProperties> tempDeclaration = MutableStyleProperties::create();
-    createCSSParser(&m_element->document())->parseDeclaration(tempDeclaration.get(), m_styleText, result, &m_element->document().elementSheet().contents());
-    return true;
-}
-
-} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorStyleSheet.h b/Source/WebCore/inspector/InspectorStyleSheet.h
deleted file mode 100644
index 9a82187..0000000
--- a/Source/WebCore/inspector/InspectorStyleSheet.h
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * Copyright (C) 2010, Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef InspectorStyleSheet_h
-#define InspectorStyleSheet_h
-
-#include "CSSPropertySourceData.h"
-#include "CSSStyleDeclaration.h"
-#include "ExceptionCode.h"
-#include <inspector/InspectorProtocolObjects.h>
-#include <inspector/InspectorValues.h>
-#include <wtf/HashMap.h>
-#include <wtf/HashSet.h>
-#include <wtf/RefPtr.h>
-#include <wtf/Vector.h>
-#include <wtf/text/WTFString.h>
-
-class ParsedStyleSheet;
-
-namespace WebCore {
-
-class CSSRuleList;
-class CSSSelector;
-class CSSStyleDeclaration;
-class CSSStyleRule;
-class CSSStyleSheet;
-class Document;
-class Element;
-class InspectorPageAgent;
-class InspectorStyleSheet;
-
-typedef String ErrorString;
-
-class InspectorCSSId {
-public:
-    InspectorCSSId() { }
-
-    explicit InspectorCSSId(const RefPtr<Inspector::InspectorObject>&& value)
-    {
-        if (!value->getString(ASCIILiteral("styleSheetId"), m_styleSheetId))
-            return;
-
-        if (!value->getInteger(ASCIILiteral("ordinal"), m_ordinal))
-            m_styleSheetId = String();
-    }
-
-    InspectorCSSId(const String& styleSheetId, unsigned ordinal)
-        : m_styleSheetId(styleSheetId)
-        , m_ordinal(ordinal)
-    {
-    }
-
-    bool isEmpty() const { return m_styleSheetId.isEmpty(); }
-
-    const String& styleSheetId() const { return m_styleSheetId; }
-    unsigned ordinal() const { return m_ordinal; }
-
-    // ID type is either Inspector::Protocol::CSS::CSSStyleId or Inspector::Protocol::CSS::CSSRuleId.
-    template<typename ID>
-    RefPtr<ID> asProtocolValue() const
-    {
-        if (isEmpty())
-            return nullptr;
-
-        return ID::create()
-            .setStyleSheetId(m_styleSheetId)
-            .setOrdinal(m_ordinal)
-            .release();
-    }
-
-private:
-    String m_styleSheetId;
-    unsigned m_ordinal = {0};
-};
-
-struct InspectorStyleProperty {
-    InspectorStyleProperty()
-        : hasSource(false)
-        , disabled(false)
-    {
-    }
-
-    InspectorStyleProperty(CSSPropertySourceData sourceData, bool hasSource, bool disabled)
-        : sourceData(sourceData)
-        , hasSource(hasSource)
-        , disabled(disabled)
-    {
-    }
-
-    void setRawTextFromStyleDeclaration(const String& styleDeclaration)
-    {
-        unsigned start = sourceData.range.start;
-        unsigned end = sourceData.range.end;
-        ASSERT_WITH_SECURITY_IMPLICATION(start < end);
-        ASSERT(end <= styleDeclaration.length());
-        rawText = styleDeclaration.substring(start, end - start);
-    }
-
-    bool hasRawText() const { return !rawText.isEmpty(); }
-
-    CSSPropertySourceData sourceData;
-    bool hasSource;
-    bool disabled;
-    String rawText;
-};
-
-class InspectorStyle final : public RefCounted<InspectorStyle> {
-public:
-    static Ref<InspectorStyle> create(const InspectorCSSId& styleId, RefPtr<CSSStyleDeclaration>&&, InspectorStyleSheet* parentStyleSheet);
-    ~InspectorStyle();
-
-    CSSStyleDeclaration* cssStyle() const { return m_style.get(); }
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyle() const;
-    Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> buildArrayForComputedStyle() const;
-
-    bool getText(String* result) const;
-    bool setText(const String&, ExceptionCode&);
-
-private:
-    InspectorStyle(const InspectorCSSId& styleId, RefPtr<CSSStyleDeclaration>&&, InspectorStyleSheet* parentStyleSheet);
-
-    // FIXME: Remove these aliases and update all the current call sites to use the new public methods.
-    bool styleText(String* result) const { return getText(result); }
-    bool applyStyleText(const String& text) { ExceptionCode ec = 0; return setText(text, ec); }
-
-    bool populateAllProperties(Vector<InspectorStyleProperty>* result) const;
-    Ref<Inspector::Protocol::CSS::CSSStyle> styleWithProperties() const;
-    RefPtr<CSSRuleSourceData> extractSourceData() const;
-    String shorthandValue(const String& shorthandProperty) const;
-    String shorthandPriority(const String& shorthandProperty) const;
-    Vector<String> longhandProperties(const String& shorthandProperty) const;
-
-    InspectorCSSId m_styleId;
-    RefPtr<CSSStyleDeclaration> m_style;
-    InspectorStyleSheet* m_parentStyleSheet;
-};
-
-class InspectorStyleSheet : public RefCounted<InspectorStyleSheet> {
-public:
-    class Listener {
-    public:
-        Listener() { }
-        virtual ~Listener() { }
-        virtual void styleSheetChanged(InspectorStyleSheet*) = 0;
-    };
-
-    typedef HashMap<CSSStyleDeclaration*, RefPtr<InspectorStyle>> InspectorStyleMap;
-    static Ref<InspectorStyleSheet> create(InspectorPageAgent*, const String& id, RefPtr<CSSStyleSheet>&& pageStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin, const String& documentURL, Listener*);
-    static String styleSheetURL(CSSStyleSheet* pageStyleSheet);
-
-    virtual ~InspectorStyleSheet();
-
-    String id() const { return m_id; }
-    String finalURL() const;
-    CSSStyleSheet* pageStyleSheet() const { return m_pageStyleSheet.get(); }
-    void reparseStyleSheet(const String&);
-    bool setText(const String&, ExceptionCode&);
-    String ruleSelector(const InspectorCSSId&, ExceptionCode&);
-    bool setRuleSelector(const InspectorCSSId&, const String& selector, ExceptionCode&);
-    CSSStyleRule* addRule(const String& selector, ExceptionCode&);
-    bool deleteRule(const InspectorCSSId&, ExceptionCode&);
-    CSSStyleRule* ruleForId(const InspectorCSSId&) const;
-    RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> buildObjectForStyleSheet();
-    RefPtr<Inspector::Protocol::CSS::CSSStyleSheetHeader> buildObjectForStyleSheetInfo();
-    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForRule(CSSStyleRule*, Element*);
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyle(CSSStyleDeclaration*);
-    bool setStyleText(const InspectorCSSId&, const String& text, String* oldText, ExceptionCode&);
-
-    virtual bool getText(String* result) const;
-    virtual CSSStyleDeclaration* styleForId(const InspectorCSSId&) const;
-    void fireStyleSheetChanged();
-
-    InspectorCSSId ruleId(CSSStyleRule*) const;
-    InspectorCSSId styleId(CSSStyleDeclaration* style) const { return ruleOrStyleId(style); }
-
-protected:
-    InspectorStyleSheet(InspectorPageAgent*, const String& id, RefPtr<CSSStyleSheet>&& pageStyleSheet, Inspector::Protocol::CSS::StyleSheetOrigin, const String& documentURL, Listener*);
-
-    bool canBind() const { return m_origin != Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent && m_origin != Inspector::Protocol::CSS::StyleSheetOrigin::User; }
-    InspectorCSSId ruleOrStyleId(CSSStyleDeclaration*) const;
-    virtual Document* ownerDocument() const;
-    virtual RefPtr<CSSRuleSourceData> ruleSourceDataFor(CSSStyleDeclaration*) const;
-    virtual unsigned ruleIndexByStyle(CSSStyleDeclaration*) const;
-    virtual bool ensureParsedDataReady();
-    virtual RefPtr<InspectorStyle> inspectorStyleForId(const InspectorCSSId&);
-
-    // Also accessed by friend class InspectorStyle.
-    virtual bool setStyleText(CSSStyleDeclaration*, const String&, ExceptionCode&);
-    virtual std::unique_ptr<Vector<size_t>> lineEndings() const;
-
-private:
-    typedef Vector<RefPtr<CSSStyleRule>> CSSStyleRuleVector;
-    friend class InspectorStyle;
-
-    static void collectFlatRules(RefPtr<CSSRuleList>&&, CSSStyleRuleVector* result);
-    bool checkPageStyleSheet(ExceptionCode&) const;
-    bool styleSheetMutated() const;
-    bool ensureText() const;
-    bool ensureSourceData();
-    void ensureFlatRules() const;
-    bool styleSheetTextWithChangedStyle(CSSStyleDeclaration*, const String& newStyleText, String* result);
-    bool originalStyleSheetText(String* result) const;
-    bool resourceStyleSheetText(String* result) const;
-    bool inlineStyleSheetText(String* result) const;
-    Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> buildArrayForRuleList(CSSRuleList*);
-    Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelector(const CSSSelector*, Element*);
-    Ref<Inspector::Protocol::CSS::SelectorList> buildObjectForSelectorList(CSSStyleRule*, Element*);
-
-    InspectorPageAgent* m_pageAgent;
-    String m_id;
-    RefPtr<CSSStyleSheet> m_pageStyleSheet;
-    Inspector::Protocol::CSS::StyleSheetOrigin m_origin;
-    String m_documentURL;
-    ParsedStyleSheet* m_parsedStyleSheet;
-    mutable CSSStyleRuleVector m_flatRules;
-    Listener* m_listener;
-};
-
-class InspectorStyleSheetForInlineStyle final : public InspectorStyleSheet {
-public:
-    static Ref<InspectorStyleSheetForInlineStyle> create(InspectorPageAgent*, const String& id, RefPtr<Element>&&, Inspector::Protocol::CSS::StyleSheetOrigin, Listener*);
-
-    void didModifyElementAttribute();
-    virtual bool getText(String* result) const override;
-    virtual CSSStyleDeclaration* styleForId(const InspectorCSSId& id) const override { ASSERT_UNUSED(id, !id.ordinal()); return inlineStyle(); }
-
-protected:
-    InspectorStyleSheetForInlineStyle(InspectorPageAgent*, const String& id, RefPtr<Element>&&, Inspector::Protocol::CSS::StyleSheetOrigin, Listener*);
-
-    virtual Document* ownerDocument() const override;
-    virtual RefPtr<CSSRuleSourceData> ruleSourceDataFor(CSSStyleDeclaration* style) const override { ASSERT_UNUSED(style, style == inlineStyle()); return m_ruleSourceData; }
-    virtual unsigned ruleIndexByStyle(CSSStyleDeclaration*) const override { return 0; }
-    virtual bool ensureParsedDataReady() override;
-    virtual RefPtr<InspectorStyle> inspectorStyleForId(const InspectorCSSId&) override;
-
-    // Also accessed by friend class InspectorStyle.
-    virtual bool setStyleText(CSSStyleDeclaration*, const String&, ExceptionCode&) override;
-    virtual std::unique_ptr<Vector<size_t>> lineEndings() const override;
-
-private:
-    CSSStyleDeclaration* inlineStyle() const;
-    const String& elementStyleText() const;
-    bool getStyleAttributeRanges(CSSRuleSourceData* result) const;
-
-    RefPtr<Element> m_element;
-    RefPtr<CSSRuleSourceData> m_ruleSourceData;
-    RefPtr<InspectorStyle> m_inspectorStyle;
-
-    // Contains "style" attribute value.
-    mutable String m_styleText;
-    mutable bool m_isStyleTextValid;
-};
-
-} // namespace WebCore
-
-#endif // !defined(InspectorStyleSheet_h)
diff --git a/Source/WebCore/inspector/InspectorStylesheetRuleSet.cpp b/Source/WebCore/inspector/InspectorStylesheetRuleSet.cpp
new file mode 100644
index 0000000..994af7e
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStylesheetRuleSet.cpp
@@ -0,0 +1,339 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorStylesheetRuleSet.h"
+
+#include "CSSParser.h"
+#include "CSSPropertySourceData.h"
+#include "CSSSelectorList.h"
+#include "CSSStyleRule.h"
+#include "CSSStyleSheet.h"
+#include "Element.h"
+#include "HTMLStyleElement.h"
+#include "InspectorCSSAgent.h"
+#include "InspectorPageAgent.h"
+#include "InspectorStyleRule.h"
+#include "SelectorChecker.h"
+#include "StyleRule.h"
+#include "StyleSheetContents.h"
+#include "SVGStyleElement.h"
+#include <inspector/ContentSearchUtilities.h>
+
+using namespace WebCore;
+
+namespace Inspector {
+
+Ref<StylesheetRuleSet> StylesheetRuleSet::create(Ref<CSSStyleSheet>&& pageStylesheet, StyleSheetOrigin origin, const String& documentURL, Listener* listener)
+{
+    return adoptRef(*new StylesheetRuleSet(WTF::move(pageStylesheet), origin, documentURL, listener));
+}
+
+StylesheetRuleSet::StylesheetRuleSet(Ref<CSSStyleSheet>&& pageStylesheet, StyleSheetOrigin origin, const String& documentURL, Listener* listener)
+    : StyleRuleSet()
+    , m_stylesheet(WTF::move(pageStylesheet))
+    , m_origin(origin)
+    , m_documentURL(documentURL)
+    , m_listener(listener)
+{
+}
+
+StylesheetRuleSet::~StylesheetRuleSet()
+{
+}
+
+String StylesheetRuleSet::finalURL() const
+{
+    if (!m_stylesheet->contents().baseURL().isEmpty())
+        return m_stylesheet->contents().baseURL().string();
+
+    return m_documentURL;
+}
+
+bool StylesheetRuleSet::isEnabled() const
+{
+    return !m_stylesheet->disabled();
+}
+
+String StylesheetRuleSet::title() const
+{
+    return m_stylesheet->title();
+}
+
+void StylesheetRuleSet::patchStylesheetText(const String& stylesheetText)
+{
+    commitRuleSetChange(ParsedRuleSetData::createWithText(*this, stylesheetText));
+}
+
+void StylesheetRuleSet::replaceText(const String& stylesheetText)
+{
+    {
+        // Must use a separate scope for clearRules(). https://www.webkit.org/b/95324/
+        CSSStyleSheet::RuleMutationScope mutationScope(&m_stylesheet.get());
+        m_stylesheet->contents().clearRules();
+    }
+    {
+        CSSStyleSheet::RuleMutationScope mutationScope(&m_stylesheet.get());
+        m_stylesheet->contents().parseString(stylesheetText);
+        m_stylesheet->clearChildRuleCSSOMWrappers();
+    }
+
+    // We just wiped the entire contents of the stylesheet. Clear the mutation flag.
+    m_stylesheet->clearHadRulesMutation();
+
+    commitRuleSetChange(ParsedRuleSetData::create(*this));
+}
+
+void StylesheetRuleSet::notifyRuleSetChanged()
+{
+    if (m_listener)
+        m_listener->styleSheetChanged(*this);
+}
+
+bool StylesheetRuleSet::selectorTextForRule(const CSSId& id, String& result)
+{
+    if (CSSStyleRule* rule = ruleForId(id)) {
+        result = rule->selectorText();
+        return true;
+    }
+
+    return false;
+}
+
+bool StylesheetRuleSet::setSelectorTextForRule(const CSSId& id, const String& selectorText)
+{
+    CSSStyleRule* rule = ruleForId(id);
+    if (!rule)
+        return false;
+
+    CSSStyleSheet* styleSheet = rule->parentStyleSheet();
+    if (!styleSheet)
+        return false;
+
+    rule->setSelectorText(selectorText);
+    RefPtr<CSSRuleSourceData> sourceData = sourceDataForRule(*rule);
+    if (!sourceData)
+        return false;
+
+    String stylesheetText = parsedRuleSetData().sourceText();
+    stylesheetText.replace(sourceData->ruleHeaderRange.start, sourceData->ruleHeaderRange.length(), selectorText);
+    patchStylesheetText(stylesheetText);
+    return true;
+}
+
+static CSSParserContext parserContextForDocument(Document* document)
+{
+    return document ? CSSParserContext(*document) : strictCSSParserContext();
+}
+
+static bool checkStyleRuleSelector(Document* document, const String& selector)
+{
+    CSSSelectorList selectorList;
+    CSSParser parser(parserContextForDocument(document));
+    parser.parseSelector(selector, selectorList);
+    return selectorList.isValid();
+}
+
+CSSStyleRule* StylesheetRuleSet::addRule(const String& selectorText, ExceptionCode& ec)
+{
+    if (!checkStyleRuleSelector(m_stylesheet->ownerDocument(), selectorText)) {
+        ec = SYNTAX_ERR;
+        return nullptr;
+    }
+
+    String stylesheetText = getText();
+
+    m_stylesheet->addRule(selectorText, "", ec);
+    if (ec)
+        return nullptr;
+    ASSERT(m_stylesheet->length());
+
+    unsigned lastRuleOrdinal = m_stylesheet->length() - 1;
+    CSSRule* rule = m_stylesheet->item(lastRuleOrdinal);
+    if (!is<CSSStyleRule>(rule)) {
+        // What we just added has to be a CSSStyleRule - we cannot handle other types of rules yet.
+        // If it is not a style rule, pretend we never touched the stylesheet.
+        m_stylesheet->deleteRule(lastRuleOrdinal, ASSERT_NO_EXCEPTION);
+        ec = SYNTAX_ERR;
+        return nullptr;
+    }
+
+    StringBuilder patchedStylesheetText;
+    patchedStylesheetText.append(stylesheetText);
+
+    if (!patchedStylesheetText.isEmpty())
+        patchedStylesheetText.append('\n');
+
+    patchedStylesheetText.append(selectorText);
+    patchedStylesheetText.appendLiteral(" {}");
+
+    patchStylesheetText(patchedStylesheetText.toString());
+
+    return downcast<CSSStyleRule>(rule);
+}
+
+bool StylesheetRuleSet::deleteRule(const CSSId& id, ExceptionCode& ec)
+{
+    RefPtr<CSSStyleRule> rule = ruleForId(id);
+    if (!rule) {
+        ec = NOT_FOUND_ERR;
+        return false;
+    }
+    RefPtr<CSSRuleSourceData> sourceData = sourceDataForRule(*rule);
+    if (!sourceData) {
+        ec = NOT_FOUND_ERR;
+        return false;
+    }
+
+    CSSStyleSheet* styleSheet = rule->parentStyleSheet();
+    styleSheet->deleteRule(id.ruleOrdinal(), ec);
+    rule = nullptr; // The rule is no longer valid, so don't keep a reference.
+
+    if (ec)
+        return false;
+
+    String stylesheetText = parsedRuleSetData().sourceText();
+    stylesheetText.remove(sourceData->ruleHeaderRange.start, sourceData->ruleBodyRange.end - sourceData->ruleHeaderRange.start + 1);
+
+    patchStylesheetText(stylesheetText);
+    return true;
+}
+
+bool StylesheetRuleSet::withStyleForId(const CSSId& identifier, const std::function<void(Inspector::StyleDeclaration&)>& callback)
+{
+    WebCore::CSSStyleRule* rule = ruleForId(identifier);
+    if (!rule)
+        return false;
+
+    StyleDeclaration style(identifier, rule->style(), this);
+    callback(style);
+    return true;
+}
+
+bool StylesheetRuleSet::withRuleForId(const CSSId& identifier, const std::function<void(Inspector::StyleRule&)>& callback)
+{
+    WebCore::CSSStyleRule* cssRule = ruleForId(identifier);
+    if (!cssRule)
+        return false;
+
+    Inspector::StyleRule rule(identifier, *cssRule, this);
+    callback(rule);
+    return true;
+}
+
+CSSStyleRule* StylesheetRuleSet::ruleForId(const CSSId& id)
+{
+    ParsedRuleSetData& parsedData = parsedRuleSetData();
+    if (id.ruleOrdinal() >= parsedData.flattenedStyleRules().size())
+        return nullptr;
+
+    return parsedData.flattenedStyleRules().at(id.ruleOrdinal()).get();
+}
+
+Document* StylesheetRuleSet::ownerDocument() const
+{
+    return m_stylesheet->ownerDocument();
+}
+
+std::unique_ptr<ParsedRuleSetData> StylesheetRuleSet::originalSourceData()
+{
+    return ParsedRuleSetData::create(*this);
+}
+
+bool StylesheetRuleSet::styleSheetMutated()
+{
+    return m_stylesheet->hadRulesMutation();
+}
+
+bool StylesheetRuleSet::setTextForStyle(CSSStyleDeclaration& style, const String& text)
+{
+    String patchedStyleSheetText;
+    if (!getTextWithPatchedStyle(style, text, patchedStyleSheetText))
+        return false;
+
+    if (idForStyle(style).isEmpty())
+        return false;
+
+    ExceptionCode ec;
+    style.setCssText(text, ec);
+    if (ec)
+        return false;
+
+    commitRuleSetChange(ParsedRuleSetData::createWithText(*this, patchedStyleSheetText));
+    return true;
+}
+
+bool StylesheetRuleSet::getTextWithPatchedStyle(CSSStyleDeclaration& style, const String& newStyleText, String& result)
+{
+    RefPtr<CSSRuleSourceData> sourceData = sourceDataForStyle(style);
+    if (!sourceData)
+        return false;
+
+    unsigned bodyStart = sourceData->ruleBodyRange.start;
+    unsigned bodyEnd = sourceData->ruleBodyRange.end;
+    ASSERT(bodyStart <= bodyEnd);
+
+    String sourceText = parsedRuleSetData().sourceText();
+    ASSERT_WITH_SECURITY_IMPLICATION(bodyEnd <= sourceText.length()); // bodyEnd is exclusive
+
+    sourceText.replace(bodyStart, bodyEnd - bodyStart, newStyleText);
+    result = sourceText;
+    return true;
+}
+
+bool StylesheetRuleSet::originalSourceText(String& result) const
+{
+    return inlineStylesheetText(result) || resourceStylesheetText(result);
+}
+
+bool StylesheetRuleSet::inlineStylesheetText(String& result) const
+{
+    Node* ownerNode = m_stylesheet->ownerNode();
+    if (!is<Element>(ownerNode))
+        return false;
+
+    Element& ownerElement = downcast<Element>(*ownerNode);
+    if (!is<HTMLStyleElement>(ownerElement) && !is<SVGStyleElement>(ownerElement))
+        return false;
+
+    result = ownerElement.textContent();
+    return true;
+}
+
+bool StylesheetRuleSet::resourceStylesheetText(String& result) const
+{
+    if (m_origin == StyleSheetOrigin::User || m_origin == StyleSheetOrigin::UserAgent)
+        return false;
+
+    if (!ownerDocument() || !ownerDocument()->frame())
+        return false;
+
+    String error;
+    bool base64Encoded;
+    InspectorPageAgent::resourceContent(error, ownerDocument()->frame(), URL(ParsedURLString, m_stylesheet->href()), &result, &base64Encoded);
+    return error.isEmpty() && !base64Encoded;
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorStylesheetRuleSet.h b/Source/WebCore/inspector/InspectorStylesheetRuleSet.h
new file mode 100644
index 0000000..83a55b8
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStylesheetRuleSet.h
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStylesheetRuleSet_h
+#define InspectorStylesheetRuleSet_h
+
+#include "CSSStyleDeclaration.h"
+#include "CSSStyleRule.h"
+#include "ExceptionCode.h"
+#include "InspectorCSSId.h"
+#include "InspectorStyleRule.h"
+#include "InspectorStyleRuleSet.h"
+#include <inspector/InspectorProtocolObjects.h>
+#include <inspector/InspectorValues.h>
+#include <wtf/HashMap.h>
+#include <wtf/HashSet.h>
+#include <wtf/RefPtr.h>
+#include <wtf/TypeCasts.h>
+#include <wtf/Vector.h>
+#include <wtf/text/WTFString.h>
+
+struct ParsedRuleSetData;
+
+namespace WebCore {
+class CSSRuleList;
+class CSSSelector;
+class CSSStyleDeclaration;
+class CSSStyleRule;
+class CSSStyleSheet;
+class Document;
+class Element;
+class InspectorPageAgent;
+
+struct CSSRuleSourceData;
+}
+
+namespace Inspector {
+
+class StyleRule;
+class StyleRuleSet;
+typedef String ErrorString;
+
+enum class StyleSheetOrigin {
+    Inspector,
+    UserAgent,
+    User,
+    Author
+};
+
+enum class MediaListSource {
+    LinkedSheet,
+    InlineSheet,
+    MediaRule,
+    ImportRule
+};
+
+class StylesheetRuleSet : public StyleRuleSet {
+public:
+    class Listener {
+    public:
+        Listener() { }
+        virtual ~Listener() { }
+        virtual void styleSheetChanged(StylesheetRuleSet&) = 0;
+    };
+
+    static Ref<StylesheetRuleSet> create(Ref<WebCore::CSSStyleSheet>&&, StyleSheetOrigin, const String& documentURL, Listener*);
+    virtual ~StylesheetRuleSet();
+
+    // StyleRuleSet API
+    virtual bool isStylesheet() const override { return true; }
+    virtual void replaceText(const String&) override;
+
+    virtual std::unique_ptr<ParsedRuleSetData> originalSourceData() override;
+    virtual WebCore::Document* ownerDocument() const override;
+
+    virtual void notifyRuleSetChanged() override;
+
+    // StylesheetRuleSet API
+    String finalURL() const;
+    String title() const;
+    StyleSheetOrigin origin() const { return m_origin; }
+    bool isEnabled() const;
+    bool originalSourceText(String& result) const;
+    bool canBind() const { return m_origin != StyleSheetOrigin::UserAgent && m_origin != StyleSheetOrigin::User; }
+
+    bool selectorTextForRule(const CSSId&, String& result);
+    bool setSelectorTextForRule(const CSSId&, const String& selectorText);
+
+    WebCore::CSSStyleRule* addRule(const String& selector, WebCore::ExceptionCode&);
+    bool deleteRule(const CSSId&, WebCore::ExceptionCode&);
+
+    bool withStyleForId(const CSSId&, const std::function<void(Inspector::StyleDeclaration&)>&);
+    bool withRuleForId(const CSSId&, const std::function<void(Inspector::StyleRule&)>&);
+    template<typename Functor> typename Functor::ReturnType forEachStyle(Functor&);
+    template<typename Functor> typename Functor::ReturnType forEachRule(Functor&);
+
+    WebCore::CSSStyleRule* ruleForId(const CSSId&);
+
+protected:
+    StylesheetRuleSet(Ref<WebCore::CSSStyleSheet>&& pageStyleSheet, StyleSheetOrigin, const String& documentURL, Listener*);
+
+    friend struct ParsedRuleSetData;
+    WebCore::CSSStyleSheet& pageStylesheet() { return m_stylesheet.get(); }
+    virtual bool setTextForStyle(WebCore::CSSStyleDeclaration&, const String&) override;
+private:
+    bool styleSheetMutated();
+    bool getTextWithPatchedStyle(WebCore::CSSStyleDeclaration&, const String& newStyleText, String& result);
+    bool resourceStylesheetText(String& result) const;
+    bool inlineStylesheetText(String& result) const;
+
+    // Only to be used internally when a rule has been added, removed, or modified. If the entire
+    // stylesheet contents have been changed, use replaceText() which recreates all CSSOM wrappers
+    // and updates the StyleSheetContents backing store to hold the new stylesheet text.
+    void patchStylesheetText(const String&);
+
+    Ref<WebCore::CSSStyleSheet> m_stylesheet;
+    StyleSheetOrigin m_origin;
+    String m_documentURL;
+    Listener* m_listener;
+};
+
+template<typename Functor>
+inline typename Functor::ReturnType StylesheetRuleSet::forEachStyle(Functor& functor)
+{
+    auto ruleList = parsedRuleSetData().flattenedStyleRules();
+    for (size_t ordinal = 0; ordinal < ruleList.size(); ++ordinal) {
+        RefPtr<WebCore::CSSStyleRule> rule = ruleList.at(ordinal);
+        StyleDeclaration style(CSSId(identifier(), ordinal), rule->style(), this);
+        functor(style);
+    }
+
+    return functor.returnValue();
+}
+
+
+template<typename Functor>
+inline typename Functor::ReturnType StylesheetRuleSet::forEachRule(Functor& functor)
+{
+    auto ruleList = parsedRuleSetData().flattenedStyleRules();
+    for (size_t ordinal = 0; ordinal < ruleList.size(); ++ordinal) {
+        RefPtr<WebCore::CSSStyleRule> cssRule = ruleList.at(ordinal);
+        if (!cssRule)
+            continue;
+
+        Inspector::StyleRule rule(CSSId(identifier(), ordinal), *cssRule, this);
+        functor(rule);
+    }
+
+    return functor.returnValue();
+}
+
+} // namespace Inspector
+
+SPECIALIZE_TYPE_TRAITS_BEGIN(Inspector::StylesheetRuleSet)
+static bool isType(const Inspector::StyleRuleSet& ruleSet) { return ruleSet.isStylesheet(); }
+SPECIALIZE_TYPE_TRAITS_END()
+
+#endif // InspectorStylesheetRuleSet_h
-- 
2.2.2

