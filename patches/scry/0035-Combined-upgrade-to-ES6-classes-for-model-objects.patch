From 02f2693d562d53b9a4f2dbee45ffc8a5c3878935 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Fri, 20 Mar 2015 22:35:07 -0700
Subject: [PATCH] Combined upgrade to ES6 classes for model objects.

---
 .../UserInterface/Controllers/DOMTracingManager.js |   5 +-
 .../UserInterface/Controllers/TimelineManager.js   |   3 +-
 .../UserInterface/Models/CSSStyleDeclaration.js    |   2 +-
 .../UserInterface/Models/DOMNodeSnapshot.js        | 104 ++---
 .../UserInterface/Models/DOMTreeSnapshot.js        |  31 +-
 .../UserInterface/Models/EffectiveStyleSnapshot.js | 448 +++++++++++----------
 .../UserInterface/Models/ElementSnapshot.js        |  69 ++--
 .../UserInterface/Models/ElementSnapshotDiff.js    |  23 +-
 .../Models/ElementTrackingTimeline.js              |  24 +-
 .../Models/ElementTrackingTimelineRecord.js        |  67 +--
 .../UserInterface/Models/Timeline.js               |   1 -
 .../Models/TraceOperationTimelineRecord.js         | 127 +++---
 .../UserInterface/Protocol/DOMTracingObserver.js   |   3 +-
 .../Views/ElementTrackingTimelineDataGridNode.js   |   3 +-
 .../WebInspectorUI/UserInterface/Views/Resizer.js  |   3 +-
 .../UserInterface/Views/TimelineRecordStack.js     |   6 +-
 16 files changed, 468 insertions(+), 451 deletions(-)

diff --git a/Source/WebInspectorUI/UserInterface/Controllers/DOMTracingManager.js b/Source/WebInspectorUI/UserInterface/Controllers/DOMTracingManager.js
index e6a6ee3..ce19893 100644
--- a/Source/WebInspectorUI/UserInterface/Controllers/DOMTracingManager.js
+++ b/Source/WebInspectorUI/UserInterface/Controllers/DOMTracingManager.js
@@ -18,21 +18,22 @@
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 WebInspector.DOMTracingManager = function()
 {
-    WebInspector.Object.call(this);
+    // FIXME: Convert this to a WebInspector.Object subclass, and call super().
+    // WebInspector.Object.call(this);
 
     this._snapshotHeaderMap = new Map;
     this._targetNode = null;
 
     // This maps from key "prestate.snapshotId:poststate.snapshotId" to a promise
     // that resolves to an ElementSnapshotDiff instance for the states.
     this._snapshotDiffPromises = new Map;
 
     WebInspector.TimelineManager.addEventListener(WebInspector.TimelineManager.Event.CapturingStopped, this._timelineCapturingStopped, this);
 };
@@ -47,21 +48,21 @@ WebInspector.DOMTracingManager.prototype = {
     {
         this._targetNode = node;
 
         var result = Promise.resolve();
         if (!WebInspector.timelineManager.isCapturing())
             result = WebInspector.timelineManager.startCapturing();
 
         var recording = WebInspector.timelineManager.activeRecording;
         var timelineType = WebInspector.TimelineRecord.Type.ElementTracking
         if (!recording.timelines.has(timelineType))
-            recording.addTimeline(new WebInspector.Timeline(timelineType));
+            recording.addTimeline(WebInspector.Timeline.create(timelineType));
 
         result = result.then(function() {
             DOMTracingAgent.startTrackingElement(node.id);
         });
         return result;
     },
 
     stopTracking: function()
     {
         console.assert(this._targetNode, "Tried to clear target element, but none was set.");
diff --git a/Source/WebInspectorUI/UserInterface/Controllers/TimelineManager.js b/Source/WebInspectorUI/UserInterface/Controllers/TimelineManager.js
index 95653f7..ed77ca4 100644
--- a/Source/WebInspectorUI/UserInterface/Controllers/TimelineManager.js
+++ b/Source/WebInspectorUI/UserInterface/Controllers/TimelineManager.js
@@ -42,21 +42,22 @@ WebInspector.TimelineManager = function()
 
     function delayedWork()
     {
         this._loadNewRecording();
     }
 
     // Allow other code to set up listeners before firing the initial RecordingLoaded event.
     setTimeout(delayedWork.bind(this), 0);
 };
 
-WebInspector.Object.addConstructorFunctions(WebInspector.TimelineManager);
+// FIXME: Move to a WebInspector.Object subclass and we can remove this.
+WebInspector.Object.deprecatedAddConstructorFunctions(WebInspector.TimelineManager);
 
 WebInspector.TimelineManager.Event = {
     RecordingCreated: "timeline-manager-recording-created",
     RecordingLoaded: "timeline-manager-recording-loaded",
     CapturingStarted: "timeline-manager-capturing-started",
     CapturingStopped: "timeline-manager-capturing-stopped"
 };
 
 WebInspector.TimelineManager.MaximumAutoRecordDuration = 90000; // 90 seconds
 WebInspector.TimelineManager.MaximumAutoRecordDurationAfterLoadEvent = 10000; // 10 seconds
diff --git a/Source/WebInspectorUI/UserInterface/Models/CSSStyleDeclaration.js b/Source/WebInspectorUI/UserInterface/Models/CSSStyleDeclaration.js
index 24d437c..ed281ed 100644
--- a/Source/WebInspectorUI/UserInterface/Models/CSSStyleDeclaration.js
+++ b/Source/WebInspectorUI/UserInterface/Models/CSSStyleDeclaration.js
@@ -182,21 +182,21 @@ WebInspector.CSSStyleDeclaration = class CSSStyleDeclaration extends WebInspecto
         return this._text;
     }
 
     set text(text)
     {
         if (this._text === text)
             return;
 
         console.assert(this._updateDelegate, "Tried to edit style text of non-editable declaratin.");
         this._updateDelegate.changeStyleText(this, text);
-    },
+    }
 
     get properties()
     {
         return this._properties;
     }
 
     get visibleProperties()
     {
         if (this._visibleProperties)
             return this._visibleProperties;
diff --git a/Source/WebInspectorUI/UserInterface/Models/DOMNodeSnapshot.js b/Source/WebInspectorUI/UserInterface/Models/DOMNodeSnapshot.js
index 18ef8bf..8f3b3c0 100644
--- a/Source/WebInspectorUI/UserInterface/Models/DOMNodeSnapshot.js
+++ b/Source/WebInspectorUI/UserInterface/Models/DOMNodeSnapshot.js
@@ -20,166 +20,168 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 // This class acts as a static data source for DOM node data. It can be used in
 // place of WebInspector.DOMTree. It does not update node data as it
 // changes on the page, nor does it support editing or incremental fetching.
 
-WebInspector.DOMNodeSnapshot = function(type, name, value, childOrdinals, attributeMap)
+WebInspector.DOMNodeSnapshot = class DOMNodeSnapshot extends WebInspector.Object
 {
-    this._nodesToResolve = childOrdinals || [];
-    this._attributeMap = attributeMap;
+    constructor(type, name, value, childOrdinals, attributeMap)
+    {
+        super();
 
-    this._nodeType = type;
-    this._nodeName = name;
-    this._nodeValue = value;
-}
+        this._nodesToResolve = childOrdinals || [];
+        this._attributeMap = attributeMap;
 
-WebInspector.DOMNodeSnapshot.fromPayload = function(payload)
-{
-    var attributeList = payload.attributes || [];
-    console.assert(attributeList.length % 2 === 0, "Attribute list for node snapshot must have even number of entries.");
+        this._nodeType = type;
+        this._nodeName = name;
+        this._nodeValue = value;
+    }
 
-    var attributeMap = attributeList.length ? new Map : null;
-    for (var i = 0; i < attributeList.length; i += 2)
-        attributeMap.set(attributeList[i], attributeList[i + 1]);
+    // Static
+
+    static fromPayload(payload)
+    {
+        var attributeList = payload.attributes || [];
+        console.assert(attributeList.length % 2 === 0, "Attribute list for node snapshot must have even number of entries.");
 
-    return new WebInspector.DOMNodeSnapshot(payload.nodeType, payload.nodeName, payload.nodeValue, payload.children, attributeMap)
-}
+        var attributeMap = attributeList.length ? new Map : null;
+        for (var i = 0; i < attributeList.length; i += 2)
+            attributeMap.set(attributeList[i], attributeList[i + 1]);
 
-WebInspector.DOMNodeSnapshot.prototype = {
-    constructor: WebInspector.DOMNodeSnapshot,
-    __proto__: WebInspector.Object.prototype,
+        return new WebInspector.DOMNodeSnapshot(payload.nodeType, payload.nodeName, payload.nodeValue, payload.children, attributeMap)
+    }
 
     // Public
 
     get children()
     {
         if (!this._children)
             return null;
 
         return this._children.slice();
-    },
+    }
 
     get parentNode()
     {
         return this._parentNode || null;
-    },
+    }
 
     get firstChild()
     {
         if (this._children && this._children.length)
             return this._children[0];
 
         return null;
-    },
+    }
 
     get lastChild()
     {
         if (this._children && this._children.length)
             return this._children.lastValue;
 
         return null;
-    },
+    }
 
     get nextSibling()
     {
         return this._nextSibling || null;
-    },
+    }
 
     get previousSibling()
     {
         return this._previousSibling || null;
-    },
+    }
 
     get childNodeCount()
     {
         return this._children ? this._children.length : 0;
-    },
+    }
 
-    nodeType: function()
+    nodeType()
     {
         return this._nodeType;
-    },
+    }
 
-    nodeName: function()
+    nodeName()
     {
         return this._nodeName;
-    },
+    }
 
-    nodeValue: function()
+    nodeValue()
     {
         return this._nodeValue;
-    },
+    }
 
-    attributes: function()
+    attributes()
     {
         if (!this._attributeMap)
             return null;
 
         var attributesList = [];
         for (var [name, value] of this._attributeMap)
             attributesList.push({name, value});
 
         return attributesList;
-    },
+    }
 
-    getAttribute: function(name)
+    getAttribute(name)
     {
         return this._attributeMap ? this._attributeMap.get(name) : null;
-    },
+    }
 
     // APIs that are cruft or redundant, but must exist to placate DOMTreeOutline / DOMTreeElement.
 
-    isXMLNode: function() { return false; },
-    isInShadowTree: function() { return false; },
-    isEditable: function() { return false; },
-    isTrackable: function() { return false; },
-    hasChildNodes: function() { return this.childNodeCount > 0; },
-    hasShadowRoots: function() { return false; },
-    hasAttributes: function() { return !!this._attributeMap; },
-    nodeNameInCorrectCase: function() { return this.nodeName().toLowerCase(); },
-    getSubtree: function(depth, callback) { setTimeout(callback, 0); },
-    getChildNodes: function(callback) { setTimeout(callback, 0); },
-    get enabledPseudoClasses() { return []; },
+    isXMLNode() { return false; }
+    isInShadowTree() { return false; }
+    isEditable() { return false; }
+    isTrackable() { return false; }
+    hasChildNodes() { return this.childNodeCount > 0; }
+    hasShadowRoots() { return false; }
+    hasAttributes() { return !!this._attributeMap; }
+    nodeNameInCorrectCase() { return this.nodeName().toLowerCase(); }
+    getSubtree(depth, callback) { setTimeout(callback, 0); }
+    getChildNodes(callback) { setTimeout(callback, 0); }
+    get enabledPseudoClasses() { return []; }
 
     // Protected
 
-    resolveChildren: function(nodeList)
+    resolveChildren(nodeList)
     {
         console.assert(this._nodesToResolve, "Already resolved nodes.");
         if (!this._nodesToResolve)
             return;
 
         if (this._nodesToResolve.length) {
             this._children = [];
             for (var childOrdinal of this._nodesToResolve) {
                 var isValidIndex = childOrdinal === Number.constrain(childOrdinal, 0, nodeList.length - 1);
                 console.assert(isValidIndex, "Invalid node ordinal is out of range. ", childOrdinal);
                 if (!isValidIndex)
                     return;
 
                 this._children.push(nodeList[childOrdinal]);
             }
         }
 
         delete this._nodesToResolve;
         this.linkChildren();
-    },
+    }
 
-    linkChildren: function()
+    linkChildren()
     {
         if (!this._children)
             return;
 
         var childCount = this._children.length;
         for (var i = 0; i < childCount; ++i) {
             var child = this._children[i];
             child._nextSibling = i + 1 < childCount ? this._children[i + 1] : null;
             child._previousSibling = i - 1 >= 0 ? this._children[i - 1] : null;
             child._parentNode = this;
         }
     }
-}
+};
diff --git a/Source/WebInspectorUI/UserInterface/Models/DOMTreeSnapshot.js b/Source/WebInspectorUI/UserInterface/Models/DOMTreeSnapshot.js
index 66bf591..f04ffc9 100644
--- a/Source/WebInspectorUI/UserInterface/Models/DOMTreeSnapshot.js
+++ b/Source/WebInspectorUI/UserInterface/Models/DOMTreeSnapshot.js
@@ -20,33 +20,36 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 // This class acts as a static data source for DOM node data. It can be used in
 // place of WebInspector.DOMTree. It does not update node data as it
 // changes on the page, nor does it support editing or incremental fetching.
 
-WebInspector.DOMTreeSnapshot = function(rootNode)
+WebInspector.DOMTreeSnapshot = class DOMTreeSnapshot extends WebInspector.Object
 {
-    this._rootNode = rootNode;
-}
+    constructor(rootNode)
+    {
+        super();
 
-WebInspector.DOMTreeSnapshot.fromPayload = function(payload)
-{
-    var nodeList = payload.nodes.map(WebInspector.DOMNodeSnapshot.fromPayload);
-    for (var node of nodeList)
-        node.resolveChildren(nodeList);
+        this._rootNode = rootNode;
+    }
 
-    return new WebInspector.DOMTreeSnapshot(nodeList[0]);
-}
+    // Static
+    static fromPayload(payload)
+    {
+        var nodeList = payload.nodes.map(WebInspector.DOMNodeSnapshot.fromPayload);
+        for (var node of nodeList)
+            node.resolveChildren(nodeList);
+
+        return new WebInspector.DOMTreeSnapshot(nodeList[0]);
+    }
 
-WebInspector.DOMTreeSnapshot.prototype = {
-    constructor: WebInspector.DOMTreeSnapshot,
-    __proto__: WebInspector.Object.prototype,
+    // Public
 
     get rootNode()
     {
         return this._rootNode;
     }
-}
+};
diff --git a/Source/WebInspectorUI/UserInterface/Models/EffectiveStyleSnapshot.js b/Source/WebInspectorUI/UserInterface/Models/EffectiveStyleSnapshot.js
index 5cf0c3e..56ddcfe 100644
--- a/Source/WebInspectorUI/UserInterface/Models/EffectiveStyleSnapshot.js
+++ b/Source/WebInspectorUI/UserInterface/Models/EffectiveStyleSnapshot.js
@@ -20,285 +20,289 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 // This class acts as a static data source for style data. It can be used in
 // place of WebInspector.DOMNodeStyles. It does not update style data as it
 // changes on the page, nor does it support editing.
 
-WebInspector.EffectiveStyleSnapshot = function(targetElement, properties, matchedRules, inlineStyles)
+WebInspector.EffectiveStyleSnapshot = class EffectiveStyleSnapshot extends WebInspector.Object
 {
-    this._targetElement = targetElement;
-    this._properties = properties;
-    this._matchedRules = matchedRules;
-    this._inlineStyles = inlineStyles;
-
-    var args = [
-        null, // updateDelegate
-        null, // ownerStyleSheet
-        null, // id
-        WebInspector.CSSStyleDeclaration.Type.Effective, // type
-        // FIXME: is this actually used anywhere? Not sure where it is used. We could plug in the target element.
-        null, // node
-        false, // inherited
-        null, // text
-        this._properties, // properties
-        null, // styleSheetTextRange
-    ];
-    this._declaration = new WebInspector.CSSStyleDeclaration(...args);
-}
-
-WebInspector.EffectiveStyleSnapshot.fromPayload = function(payload)
-{
-    // Much of this parsing functionality is copied from DOMNodeStyles. It is
-    // simplified in some parts because we do not need to update existing model objects.
+    constructor(targetElement, properties, matchedRules, inlineStyles)
+    {
+        super();
+
+        this._targetElement = targetElement;
+        this._properties = properties;
+        this._matchedRules = matchedRules;
+        this._inlineStyles = inlineStyles;
+
+        var args = [
+            null, // updateDelegate
+            null, // ownerStyleSheet
+            null, // id
+            WebInspector.CSSStyleDeclaration.Type.Effective, // type
+            // FIXME: is this actually used anywhere? Not sure where it is used. We could plug in the target element.
+            null, // node
+            false, // inherited
+            null, // text
+            this._properties, // properties
+            null, // styleSheetTextRange
+        ];
+        this._declaration = new WebInspector.CSSStyleDeclaration(...args);
+    }
 
-    var ruleIdToParsedRuleMap = new Map;
-    var nodeIdToParsedInlineStyleMap = new Map;
+    // Static
 
-    var matchedRules = [];
-    var inlineStyles = [];
+    static fromPayload(payload)
+    {
+        // Much of this parsing functionality is copied from DOMNodeStyles. It is
+        // simplified in some parts because we do not need to update existing model objects.
 
-    var targetElement = WebInspector.domTreeManager.nodeForId(payload.targetElement);
+        var ruleIdToParsedRuleMap = new Map;
+        var nodeIdToParsedInlineStyleMap = new Map;
 
-    for (var elementEntry of payload.elements) {
-        var node = WebInspector.domTreeManager.nodeForId(elementEntry.nodeId);
-        console.assert(node, node);
-        var isInherited = node !== targetElement;
-        if ("inlineStyle" in elementEntry) {
-            var inlineStyle = parseDeclarationPayload(elementEntry.inlineStyle, node, isInherited, WebInspector.CSSStyleDeclaration.Type.Inline);
-            nodeIdToParsedInlineStyleMap.set(elementEntry.nodeId, inlineStyle);
-            inlineStyles.push(inlineStyle);
-        }
+        var matchedRules = [];
+        var inlineStyles = [];
 
-        // Iterate matched rules in reverse order to match the cascade order.
-        for (var match of elementEntry.matchedRules) {
-            var rule = parseRulePayload(match.rule, match.matchingSelectors, node, isInherited);
-            if (!rule)
-                continue;
-            var key = "%d:%d".format(rule.id.styleSheetId, rule.id.ordinal);
-            ruleIdToParsedRuleMap.set(key, rule);
-            matchedRules.push(rule);
-        }
-    }
+        var targetElement = WebInspector.domTreeManager.nodeForId(payload.targetElement);
 
-    var effectiveProperties = [];
-    for (var i = 0; i < payload.properties.length; ++i) {
-        var propertyEntry = payload.properties[i];
-        var property = parsePropertyPayload(propertyEntry.property, i, null);
-        // If property came from a rule, find that rule based on its id.
-        if ("sourceRule" in propertyEntry) {
-            var ruleId = propertyEntry.sourceRule;
-            var key = "%d:%d".format(ruleId.styleSheetId, ruleId.ordinal);
-            console.assert(ruleIdToParsedRuleMap.has(key));
-            var originatingRule = ruleIdToParsedRuleMap.get(key);
-            property.ownerStyle = originatingRule.style;
-        }
-        // If property came from an element's inline style, find that.
-        else if ("sourceElement" in propertyEntry) {
-            console.assert(nodeIdToParsedInlineStyleMap.has(propertyEntry.sourceElement));
-            var originatingStyle = nodeIdToParsedInlineStyleMap.get(propertyEntry.sourceElement);
-            property.ownerStyle = originatingStyle;
+        for (var elementEntry of payload.elements) {
+            var node = WebInspector.domTreeManager.nodeForId(elementEntry.nodeId);
+            console.assert(node, node);
+            var isInherited = node !== targetElement;
+            if ("inlineStyle" in elementEntry) {
+                var inlineStyle = parseDeclarationPayload(elementEntry.inlineStyle, node, isInherited, WebInspector.CSSStyleDeclaration.Type.Inline);
+                nodeIdToParsedInlineStyleMap.set(elementEntry.nodeId, inlineStyle);
+                inlineStyles.push(inlineStyle);
+            }
+
+            // Iterate matched rules in reverse order to match the cascade order.
+            for (var match of elementEntry.matchedRules) {
+                var rule = parseRulePayload(match.rule, match.matchingSelectors, node, isInherited);
+                if (!rule)
+                    continue;
+                var key = "%d:%d".format(rule.id.styleSheetId, rule.id.ordinal);
+                ruleIdToParsedRuleMap.set(key, rule);
+                matchedRules.push(rule);
+            }
         }
 
-        effectiveProperties.push(property);
-    }
+        var effectiveProperties = [];
+        for (var i = 0; i < payload.properties.length; ++i) {
+            var propertyEntry = payload.properties[i];
+            var property = parsePropertyPayload(propertyEntry.property, i, null);
+            // If property came from a rule, find that rule based on its id.
+            if ("sourceRule" in propertyEntry) {
+                var ruleId = propertyEntry.sourceRule;
+                var key = "%d:%d".format(ruleId.styleSheetId, ruleId.ordinal);
+                console.assert(ruleIdToParsedRuleMap.has(key));
+                var originatingRule = ruleIdToParsedRuleMap.get(key);
+                property.ownerStyle = originatingRule.style;
+            }
+            // If property came from an element's inline style, find that.
+            else if ("sourceElement" in propertyEntry) {
+                console.assert(nodeIdToParsedInlineStyleMap.has(propertyEntry.sourceElement));
+                var originatingStyle = nodeIdToParsedInlineStyleMap.get(propertyEntry.sourceElement);
+                property.ownerStyle = originatingStyle;
+            }
+
+            effectiveProperties.push(property);
+        }
 
-    function createSourceCodeLocation(sourceURL, sourceLine, sourceColumn) {
-        if (!sourceURL)
-            return null;
+        function createSourceCodeLocation(sourceURL, sourceLine, sourceColumn) {
+            if (!sourceURL)
+                return null;
 
-        var sourceCode;
+            var sourceCode;
 
-        // Try to use the node to find the frame which has the correct resource first.
-        if (targetElement.ownerDocument) {
-            var mainResource = WebInspector.frameResourceManager.resourceForURL(targetElement.ownerDocument.documentURL);
-            if (mainResource) {
-                var parentFrame = mainResource.parentFrame;
-                sourceCode = parentFrame.resourceForURL(sourceURL);
+            // Try to use the node to find the frame which has the correct resource first.
+            if (targetElement.ownerDocument) {
+                var mainResource = WebInspector.frameResourceManager.resourceForURL(targetElement.ownerDocument.documentURL);
+                if (mainResource) {
+                    var parentFrame = mainResource.parentFrame;
+                    sourceCode = parentFrame.resourceForURL(sourceURL);
+                }
             }
-        }
 
-        // If that didn't find the resource, then search all frames.
-        if (!sourceCode)
-            sourceCode = WebInspector.frameResourceManager.resourceForURL(sourceURL);
+            // If that didn't find the resource, then search all frames.
+            if (!sourceCode)
+                sourceCode = WebInspector.frameResourceManager.resourceForURL(sourceURL);
 
-        if (!sourceCode)
-            return null;
+            if (!sourceCode)
+                return null;
 
-        return sourceCode.createSourceCodeLocation(sourceLine || 0, sourceColumn || 0);
-    };
+            return sourceCode.createSourceCodeLocation(sourceLine || 0, sourceColumn || 0);
+        };
 
-    return new WebInspector.EffectiveStyleSnapshot(targetElement, effectiveProperties, matchedRules, inlineStyles);
+        return new WebInspector.EffectiveStyleSnapshot(targetElement, effectiveProperties, matchedRules, inlineStyles);
 
-    function parseRulePayload(payload, matchedSelectorIndices, node, isInherited)
-    {
-        if (!payload)
-            return null;
-
-        // User and User Agent rules don't have 'ruleId' in the payload. However, their style's have 'styleId' and
-        // 'styleId' is the same identifier the backend uses for Author rule identifiers, so do the same here.
-        // They are excluded by the backend because they are not editable, however our front-end does not determine
-        // editability solely based on the existence of the id like the open source front-end does.
-        var ruleId = payload.ruleId || payload.style.styleId;
-
-        var style = parseDeclarationPayload(payload.style, node, isInherited, WebInspector.CSSStyleDeclaration.Type.Rule);
-        if (!style)
-            return null;
-
-        var selectorText = payload.selectorList.text;
-        var selectors = parseSelectorListPayload(payload.selectorList);
-        var sourceRange = payload.selectorList.range;
-        var sourceCodeLocation = createSourceCodeLocation(payload.sourceURL, sourceRange.startLine, sourceRange.startColumn);
-        var mediaList = parseMediaListPayload(payload.media);
-
-        var ruleType;
-        switch (payload.origin) {
-        case "regular":
-            ruleType = WebInspector.CSSRule.Type.Author;
-            break;
-        case "user":
-            ruleType = WebInspector.CSSRule.Type.User;
-            break;
-        case "user-agent":
-            ruleType = WebInspector.CSSRule.Type.UserAgent;
-            break;
-        case "inspector":
-            ruleType = WebInspector.CSSRule.Type.Inspector;
-            break;
-        }
+        function parseRulePayload(payload, matchedSelectorIndices, node, isInherited)
+        {
+            if (!payload)
+                return null;
 
-        var rule = new WebInspector.CSSRule(null, null, ruleId, ruleType, sourceCodeLocation, selectorText, selectors, matchedSelectorIndices, null, mediaList);
-        style.ownerRule = rule;
-        return rule;
-    }
+            // User and User Agent rules don't have 'ruleId' in the payload. However, their style's have 'styleId' and
+            // 'styleId' is the same identifier the backend uses for Author rule identifiers, so do the same here.
+            // They are excluded by the backend because they are not editable, however our front-end does not determine
+            // editability solely based on the existence of the id like the open source front-end does.
+            var ruleId = payload.ruleId || payload.style.styleId;
 
-    function parseMediaListPayload(mediaList)
-    {
-        if (!mediaList)
-            return [];
-
-        var mediaList = [];
-        for (var item of mediaList) {
-            var mediaType;
-            switch (item.source) {
-            case "mediaRule":
-                mediaType = WebInspector.CSSMedia.Type.MediaRule;
+            var style = parseDeclarationPayload(payload.style, node, isInherited, WebInspector.CSSStyleDeclaration.Type.Rule);
+            if (!style)
+                return null;
+
+            var selectorText = payload.selectorList.text;
+            var selectors = parseSelectorListPayload(payload.selectorList);
+            var sourceRange = payload.selectorList.range;
+            var sourceCodeLocation = createSourceCodeLocation(payload.sourceURL, sourceRange.startLine, sourceRange.startColumn);
+            var mediaList = parseMediaListPayload(payload.media);
+
+            var ruleType;
+            switch (payload.origin) {
+            case "regular":
+                ruleType = WebInspector.CSSRule.Type.Author;
                 break;
-            case "importRule":
-                mediaType = WebInspector.CSSMedia.Type.ImportRule;
+            case "user":
+                ruleType = WebInspector.CSSRule.Type.User;
                 break;
-            case "linkedSheet":
-                mediaType = WebInspector.CSSMedia.Type.LinkedStyleSheet;
+            case "user-agent":
+                ruleType = WebInspector.CSSRule.Type.UserAgent;
                 break;
-            case "inlineSheet":
-                mediaType = WebInspector.CSSMedia.Type.InlineStyleSheet;
+            case "inspector":
+                ruleType = WebInspector.CSSRule.Type.Inspector;
                 break;
             }
 
-            var location = this._createSourceCodeLocation(item.sourceURL, item.sourceLine);
-            mediaList.push(new WebInspector.CSSMedia(mediaType, mediaText, location));
+            var rule = new WebInspector.CSSRule(null, null, ruleId, ruleType, sourceCodeLocation, selectorText, selectors, matchedSelectorIndices, null, mediaList);
+            style.ownerRule = rule;
+            return rule;
         }
-        return mediaList;
-    }
 
-    function parseSelectorListPayload(selectorList)
-    {
-        var selectors = selectorList.selectors;
-        if (!selectors.length)
-            return [];
-
-        return selectors.map(function(selectorPayload) {
-            return new WebInspector.CSSSelector(selectorPayload.text, selectorPayload.specificity, selectorPayload.dynamic);
-        });
-    }
+        function parseMediaListPayload(mediaList)
+        {
+            if (!mediaList)
+                return [];
+
+            var mediaList = [];
+            for (var item of mediaList) {
+                var mediaType;
+                switch (item.source) {
+                case "mediaRule":
+                    mediaType = WebInspector.CSSMedia.Type.MediaRule;
+                    break;
+                case "importRule":
+                    mediaType = WebInspector.CSSMedia.Type.ImportRule;
+                    break;
+                case "linkedSheet":
+                    mediaType = WebInspector.CSSMedia.Type.LinkedStyleSheet;
+                    break;
+                case "inlineSheet":
+                    mediaType = WebInspector.CSSMedia.Type.InlineStyleSheet;
+                    break;
+                }
+
+                var location = this._createSourceCodeLocation(item.sourceURL, item.sourceLine);
+                mediaList.push(new WebInspector.CSSMedia(mediaType, mediaText, location));
+            }
+            return mediaList;
+        }
 
-    function parseDeclarationPayload(payload, node, isInherited, styleType)
-    {
-        if (!payload)
-            return null;
+        function parseSelectorListPayload(selectorList)
+        {
+            var selectors = selectorList.selectors;
+            if (!selectors.length)
+                return [];
 
-        var shorthands = {};
-        for (var i = 0; payload.shorthandEntries && i < payload.shorthandEntries.length; ++i) {
-            var shorthand = payload.shorthandEntries[i];
-            shorthands[shorthand.name] = shorthand.value;
+            return selectors.map(function(selectorPayload) {
+                return new WebInspector.CSSSelector(selectorPayload.text, selectorPayload.specificity, selectorPayload.dynamic);
+            });
         }
 
-        var inheritedPropertyCount = 0;
-        var cssProperties = [];
-        for (var i = 0; payload.cssProperties && i < payload.cssProperties.length; ++i) {
-            var propertyPayload = payload.cssProperties[i];
+        function parseDeclarationPayload(payload, node, isInherited, styleType)
+        {
+            if (!payload)
+                return null;
+
+            var shorthands = {};
+            for (var i = 0; payload.shorthandEntries && i < payload.shorthandEntries.length; ++i) {
+                var shorthand = payload.shorthandEntries[i];
+                shorthands[shorthand.name] = shorthand.value;
+            }
 
-            if (isInherited && propertyPayload.name in WebInspector.CSSKeywordCompletions.InheritedProperties)
-                ++inheritedPropertyCount;
+            var inheritedPropertyCount = 0;
+            var cssProperties = [];
+            for (var i = 0; payload.cssProperties && i < payload.cssProperties.length; ++i) {
+                var propertyPayload = payload.cssProperties[i];
 
-            var property = parsePropertyPayload(propertyPayload, i, payload.cssText);
-            cssProperties.push(property);
-        }
+                if (isInherited && propertyPayload.name in WebInspector.CSSKeywordCompletions.InheritedProperties)
+                    ++inheritedPropertyCount;
 
-        if (isInherited && !inheritedPropertyCount)
-            return null;
+                var property = parsePropertyPayload(propertyPayload, i, payload.cssText);
+                cssProperties.push(property);
+            }
 
-        var textRange = parseSourceRangePayload(payload.range);
-        var declaration = new WebInspector.CSSStyleDeclaration(this, null, payload.styleId, styleType, node, isInherited, payload.cssText, cssProperties, textRange);
-        for (var cssProperty of cssProperties)
-            cssProperty.ownerStyle = declaration;
+            if (isInherited && !inheritedPropertyCount)
+                return null;
 
-        return declaration;
-    }
+            var textRange = parseSourceRangePayload(payload.range);
+            var declaration = new WebInspector.CSSStyleDeclaration(this, null, payload.styleId, styleType, node, isInherited, payload.cssText, cssProperties, textRange);
+            for (var cssProperty of cssProperties)
+                cssProperty.ownerStyle = declaration;
 
-    function parsePropertyPayload(payload, index, styleText)
-    {
-        if (!payload)
-            return null;
-
-        var propertyText = payload.text || "";
-        var value = (payload.value || "").replace(/\s*!important\s*$/, "");
-        var priority = payload.priority || "";
-
-        var enabled = true;
-        var overridden = false;
-        var implicit = payload.implicit || false;
-        var valid = "parsedOk" in payload ? payload.parsedOk : true;
-
-        switch (payload.status || "style") {
-        case "active":
-            enabled = true;
-            break;
-        case "inactive":
-            overridden = true;
-            enabled = true;
-            break;
-        case "disabled":
-            enabled = false;
-            break;
+            return declaration;
         }
 
-        var styleSheetTextRange = parseSourceRangePayload(payload.range);
-        return new WebInspector.CSSProperty(index, propertyText, payload.name, value, priority, enabled, overridden, implicit, false, valid, styleSheetTextRange, null);
-    }
+        function parsePropertyPayload(payload, index, styleText)
+        {
+            if (!payload)
+                return null;
 
-    function parseSourceRangePayload(payload)
-    {
-        if (!payload)
-            return null;
+            var propertyText = payload.text || "";
+            var value = (payload.value || "").replace(/\s*!important\s*$/, "");
+            var priority = payload.priority || "";
+
+            var enabled = true;
+            var overridden = false;
+            var implicit = payload.implicit || false;
+            var valid = "parsedOk" in payload ? payload.parsedOk : true;
+
+            switch (payload.status || "style") {
+            case "active":
+                enabled = true;
+                break;
+            case "inactive":
+                overridden = true;
+                enabled = true;
+                break;
+            case "disabled":
+                enabled = false;
+                break;
+            }
+
+            var styleSheetTextRange = parseSourceRangePayload(payload.range);
+            return new WebInspector.CSSProperty(index, propertyText, payload.name, value, priority, enabled, overridden, implicit, false, valid, styleSheetTextRange, null);
+        }
 
-        return new WebInspector.TextRange(payload.startLine, payload.startColumn, payload.endLine, payload.endColumn);
+        function parseSourceRangePayload(payload)
+        {
+            if (!payload)
+                return null;
+
+            return new WebInspector.TextRange(payload.startLine, payload.startColumn, payload.endLine, payload.endColumn);
+        }
     }
-}
 
-WebInspector.EffectiveStyleSnapshot.prototype = {
-    constructor: WebInspector.EffectiveStyleSnapshot,
-    __proto__: WebInspector.Object.prototype,
+    // Public
 
     get properties()
     {
         return this._properties.slice();
-    },
+    }
 
     get declaration()
     {
         return this._declaration;
     }
-}
+};
diff --git a/Source/WebInspectorUI/UserInterface/Models/ElementSnapshot.js b/Source/WebInspectorUI/UserInterface/Models/ElementSnapshot.js
index 48fdc09..edf1feb 100644
--- a/Source/WebInspectorUI/UserInterface/Models/ElementSnapshot.js
+++ b/Source/WebInspectorUI/UserInterface/Models/ElementSnapshot.js
@@ -16,105 +16,108 @@
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-WebInspector.ElementSnapshotHeader = function(payload)
+WebInspector.ElementSnapshotHeader = class ElementSnapshotHeader extends WebInspector.Object
 {
-    this.nodeId = payload.nodeId;
-    this.snapshotId = payload.snapshotId; // Used when making queries to the backend.
-    this.elapsedTime = payload.elapsedTimestamp;
-    this.boundingRect = WebInspector.Rect.fromObject(payload.boundingBox);
+    constructor(payload)
+    {
+        super();
 
-    // Assigned when a record for the snapshot is added to an ElementTrackingTimeline instance.
-    this.ordinal = NaN;
+        this.nodeId = payload.nodeId;
+        this.snapshotId = payload.snapshotId; // Used when making queries to the backend.
+        this.elapsedTime = payload.elapsedTimestamp;
+        this.boundingRect = WebInspector.Rect.fromObject(payload.boundingBox);
 
-    this._payloadPromise = null;
-}
+        // Assigned when a record for the snapshot is added to an ElementTrackingTimeline instance.
+        this.ordinal = NaN;
+
+        this._payloadPromise = null;
+    }
 
-WebInspector.ElementSnapshotHeader.prototype = {
-    constructor: WebInspector.ElementSnapshotHeader,
-    __proto__: WebInspector.Object.prototype,
+    // Public
 
-    fetchData: function()
+    fetchData()
     {
         if (!this._payloadPromise) {
             this._payloadPromise = DOMTracingAgent.getSnapshotPayload.promise(this.snapshotId)
                 .then(function(response) {
                     console.assert(response.payload.snapshotId === this.snapshotId);
                     return new WebInspector.ElementSnapshot(this, response.payload);
                 }.bind(this))
                 .catch(function(error) {
                     console.log(error); throw error;
                 });
         }
 
         return this._payloadPromise;
-    },
+    }
 
     get displayName()
     {
         return WebInspector.UIString("Snapshot %d").format(this.ordinal || " ");
-    },
+    }
 
-    saveIdentityToCookie: function(cookie)
+    saveIdentityToCookie(cookie)
     {
         // Do nothing, since snapshots are not saved across reloads or reopens.
     }
 }
 
-WebInspector.ElementSnapshot = function(header, payload)
+WebInspector.ElementSnapshot = class ElementSnapshot extends WebInspector.Object
 {
-    console.assert(header instanceof WebInspector.ElementSnapshotHeader);
 
-    this._header = header;
-    this._imageData = decodeBase64ToBlob(payload.imageData.encodedData, payload.imageData.mimeType);
-    this._effectiveStyle = WebInspector.EffectiveStyleSnapshot.fromPayload(payload.styleData);
-    this._treeSnapshot = WebInspector.DOMTreeSnapshot.fromPayload(payload.subtreeData);
-}
+    constructor(header, payload)
+    {
+        super();
 
-WebInspector.ElementSnapshot.prototype = {
-    constructor: WebInspector.ElementSnapshot,
-    __proto__: WebInspector.Object.prototype,
+        console.assert(header instanceof WebInspector.ElementSnapshotHeader);
+
+        this._header = header;
+        this._imageData = decodeBase64ToBlob(payload.imageData.encodedData, payload.imageData.mimeType);
+        this._effectiveStyle = WebInspector.EffectiveStyleSnapshot.fromPayload(payload.styleData);
+        this._treeSnapshot = WebInspector.DOMTreeSnapshot.fromPayload(payload.subtreeData);
+    }
 
     get displayName()
     {
         return this._header.displayName;
-    },
+    }
 
     get snapshotId()
     {
         return this._header.snapshotId;
-    },
+    }
 
     get ordinal()
     {
         return this._header.ordinal;
-    },
+    }
 
     get header()
     {
         return this._header;
-    },
+    }
 
     // This returns an object URL handle that should be revoked when no longer needed.
-    createObjectURLForImage: function()
+    createObjectURLForImage()
     {
         console.assert(this._imageData instanceof Blob, this._imageData);
         return URL.createObjectURL(this._imageData);
-    },
+    }
 
     get effectiveStyle()
     {
         return this._effectiveStyle;
-    },
+    }
 
     get treeSnapshot()
     {
         return this._treeSnapshot;
     }
 }
diff --git a/Source/WebInspectorUI/UserInterface/Models/ElementSnapshotDiff.js b/Source/WebInspectorUI/UserInterface/Models/ElementSnapshotDiff.js
index 17bb944..e644e8b 100644
--- a/Source/WebInspectorUI/UserInterface/Models/ElementSnapshotDiff.js
+++ b/Source/WebInspectorUI/UserInterface/Models/ElementSnapshotDiff.js
@@ -16,24 +16,25 @@
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-WebInspector.ElementSnapshotDiff = function(preState, postState)
+WebInspector.ElementSnapshotDiff = class ElementSnapshotDiff extends WebInspector.Object
 {
-    console.assert(preState instanceof WebInspector.ElementSnapshot, preState);
-    console.assert(postState instanceof WebInspector.ElementSnapshot, postState);
-    console.assert(preState !== postState, "Cannot diff a snapshot with itself.");
 
-    this.preState = preState;
-    this.postState = postState;
-}
+    constructor(preState, postState)
+    {
+        super();
 
-WebInspector.ElementSnapshotDiff.prototype = {
-    constructor: WebInspector.ElementSnapshotDiff,
-    __proto__: WebInspector.Object.prototype,
-}
+        console.assert(preState instanceof WebInspector.ElementSnapshot, preState);
+        console.assert(postState instanceof WebInspector.ElementSnapshot, postState);
+        console.assert(preState !== postState, "Cannot diff a snapshot with itself.");
+
+        this.preState = preState;
+        this.postState = postState;
+    }
+};
diff --git a/Source/WebInspectorUI/UserInterface/Models/ElementTrackingTimeline.js b/Source/WebInspectorUI/UserInterface/Models/ElementTrackingTimeline.js
index fea2c25..ad6b11e 100644
--- a/Source/WebInspectorUI/UserInterface/Models/ElementTrackingTimeline.js
+++ b/Source/WebInspectorUI/UserInterface/Models/ElementTrackingTimeline.js
@@ -16,48 +16,46 @@
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-WebInspector.ElementTrackingTimeline = function(type)
+WebInspector.ElementTrackingTimeline = class ElementTrackingTimeline extends WebInspector.Timeline
 {
-    WebInspector.Timeline.call(this, type);
-
-    this._snapshotCount = 0;
-};
+    constructor(type)
+    {
+        super(type);
 
-WebInspector.ElementTrackingTimeline.prototype = {
-    constructor: WebInspector.ElementTrackingTimeline,
-    __proto__: WebInspector.Timeline.prototype,
+        this._snapshotCount = 0;
+    }
 
     // Public
 
-    reset: function(suppressEvents)
+    reset(suppressEvents)
     {
         WebInspector.Timeline.prototype.reset.call(this, suppressEvents);
-    },
+    }
 
     get traceRecords()
     {
         return this.records.filter(function(record) { return record instanceof WebInspector.TraceOperationTimelineRecord; });
-    },
+    }
 
     get snapshotRecords()
     {
         return this.records.filter(function(record) { return record instanceof WebInspector.ElementTrackingTimelineRecord; });
-    },
+    }
 
-    addRecord: function(record)
+    addRecord(record)
     {
         console.assert(record.type === WebInspector.TimelineRecord.Type.ElementTracking, record);
 
         if (record instanceof WebInspector.ElementTrackingTimelineRecord)
             record.snapshotHeader.ordinal = ++this._snapshotCount;
 
         WebInspector.Timeline.prototype.addRecord.call(this, record);
     }
 };
diff --git a/Source/WebInspectorUI/UserInterface/Models/ElementTrackingTimelineRecord.js b/Source/WebInspectorUI/UserInterface/Models/ElementTrackingTimelineRecord.js
index 53490ab..75e564a 100644
--- a/Source/WebInspectorUI/UserInterface/Models/ElementTrackingTimelineRecord.js
+++ b/Source/WebInspectorUI/UserInterface/Models/ElementTrackingTimelineRecord.js
@@ -16,87 +16,88 @@
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-WebInspector.ElementTrackingTimelineRecord = function(eventType, snapshotHeader)
+WebInspector.ElementTrackingTimelineRecord = class ElementTrackingTimelineRecord extends WebInspector.TimelineRecord
 {
-    WebInspector.TimelineRecord.call(this, WebInspector.TimelineRecord.Type.ElementTracking, snapshotHeader.elapsedTime, snapshotHeader.elapsedTime);
-
-    console.assert(eventType, eventType);
-    console.assert(snapshotHeader instanceof WebInspector.ElementSnapshotHeader, snapshotHeader);
-
-    if (eventType in WebInspector.ElementTrackingTimelineRecord.EventType)
-        eventType = WebInspector.ElementTrackingTimelineRecord.EventType[eventType];
+    constructor(eventType, snapshotHeader)
+    {
+        super(WebInspector.TimelineRecord.Type.ElementTracking, snapshotHeader.elapsedTime, snapshotHeader.elapsedTime);
 
-    this._eventType = eventType;
-    this._snapshotHeader = snapshotHeader;
-};
+        console.assert(eventType, eventType);
+        console.assert(snapshotHeader instanceof WebInspector.ElementSnapshotHeader, snapshotHeader);
 
-WebInspector.ElementTrackingTimelineRecord.EventType = {
-    OutputChanged: "element-tracking-timeline-record-output-changed",
-};
+        if (eventType in WebInspector.ElementTrackingTimelineRecord.EventType)
+            eventType = WebInspector.ElementTrackingTimelineRecord.EventType[eventType];
 
-WebInspector.ElementTrackingTimelineRecord.displayNameForEventType = function(eventType)
-{
-    switch (eventType) {
-    case WebInspector.ElementTrackingTimelineRecord.EventType.OutputChanged:
-        return WebInspector.UIString("Output Changed");
+        this._eventType = eventType;
+        this._snapshotHeader = snapshotHeader;
     }
-};
 
-WebInspector.ElementTrackingTimelineRecord.TypeIdentifier = "element-tracking-timeline-record";
-WebInspector.ElementTrackingTimelineRecord.EventTypeCookieKey = "element-tracking-timeline-record-event-type";
+    // Static
 
-WebInspector.ElementTrackingTimelineRecord.prototype = {
-    constructor: WebInspector.ElementTrackingTimelineRecord,
-    __proto__: WebInspector.TimelineRecord.prototype,
+    static displayNameForEventType(eventType)
+    {
+        switch (eventType) {
+        case WebInspector.ElementTrackingTimelineRecord.EventType.OutputChanged:
+            return WebInspector.UIString("Output Changed");
+        }
+    }
 
     // Public
 
     get eventType()
     {
         return this._eventType;
-    },
+    }
 
     get x()
     {
         return this._snapshotHeader.boundingRect.origin.x;
-    },
+    }
 
     get y()
     {
         return this._snapshotHeader.boundingRect.origin.y;
-    },
+    }
 
     get width()
     {
         return this._snapshotHeader.boundingRect.size.width;
-    },
+    }
 
     get height()
     {
         return this._snapshotHeader.boundingRect.size.height;
-    },
+    }
 
     get rect()
     {
         return this._snapshotHeader.boundingRect;
-    },
+    }
 
     get snapshotHeader()
     {
         return this._snapshotHeader;
-    },
+    }
 
-    saveIdentityToCookie: function(cookie)
+    saveIdentityToCookie(cookie)
     {
         WebInspector.TimelineRecord.prototype.saveIdentityToCookie.call(this, cookie);
 
         cookie[WebInspector.ElementTrackingTimelineRecord.EventTypeCookieKey] = this._eventType;
     }
 };
+
+WebInspector.ElementTrackingTimelineRecord.EventType = {
+    OutputChanged: "element-tracking-timeline-record-output-changed",
+};
+
+WebInspector.ElementTrackingTimelineRecord.TypeIdentifier = "element-tracking-timeline-record";
+WebInspector.ElementTrackingTimelineRecord.EventTypeCookieKey = "element-tracking-timeline-record-event-type";
+
diff --git a/Source/WebInspectorUI/UserInterface/Models/Timeline.js b/Source/WebInspectorUI/UserInterface/Models/Timeline.js
index cf3f4ee..a50906f 100644
--- a/Source/WebInspectorUI/UserInterface/Models/Timeline.js
+++ b/Source/WebInspectorUI/UserInterface/Models/Timeline.js
@@ -35,21 +35,20 @@ WebInspector.Timeline = class Timeline extends WebInspector.Object
     }
 
     // Static
 
     static create(type)
     {
         if (type === WebInspector.TimelineRecord.Type.Network)
             return new WebInspector.NetworkTimeline(type);
         if (type === WebInspector.TimelineRecord.Type.ElementTracking)
             return new WebInspector.ElementTrackingTimeline(type);
-    }
 
         return new WebInspector.Timeline(type);
     }
 
     // Public
 
     get startTime()
     {
         return this._startTime;
     }
diff --git a/Source/WebInspectorUI/UserInterface/Models/TraceOperationTimelineRecord.js b/Source/WebInspectorUI/UserInterface/Models/TraceOperationTimelineRecord.js
index 51f9982..99566ea 100644
--- a/Source/WebInspectorUI/UserInterface/Models/TraceOperationTimelineRecord.js
+++ b/Source/WebInspectorUI/UserInterface/Models/TraceOperationTimelineRecord.js
@@ -16,99 +16,98 @@
  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-WebInspector.TraceOperationTimelineRecord = function(eventType, relationToTarget, data, timestamp, callFrames, sourceCodeLocation)
+WebInspector.TraceOperationTimelineRecord = class TraceOperationTimelineRecord extends WebInspector.TimelineRecord
 {
-    WebInspector.TimelineRecord.call(this, WebInspector.TimelineRecord.Type.ElementTracking, timestamp, timestamp, callFrames, sourceCodeLocation);
-
-    console.assert(eventType, eventType);
-
-    this._eventType = eventType;
-    this._relationToTarget = relationToTarget;
-    this._data = data;
-};
-
-WebInspector.TraceOperationTimelineRecord.EventType = {
-    ElementInserted: "trace-operation-timeline-record-element-inserted",
-    ElementRemoved: "trace-operation-timeline-record-element-removed",
-    AttributeModified: "trace-operation-timeline-record-attribute-modified",
-    AttributeRemoved: "trace-operation-timeline-record-attribute-removed",
-};
+    constructor(eventType, relationToTarget, data, timestamp, callFrames, sourceCodeLocation)
+    {
+        super(WebInspector.TimelineRecord.Type.ElementTracking, timestamp, timestamp, callFrames, sourceCodeLocation);
 
-WebInspector.TraceOperationTimelineRecord.ElementRelation = {
-    Target: "trace-operation-timeline-record-element-relation-target",
-    Parent: "trace-operation-timeline-record-element-relation-parent",
-    Child: "trace-operation-timeline-record-element-relation-child",
-    Ancestor: "trace-operation-timeline-record-element-relation-ancestor",
-    Descendant: "trace-operation-timeline-record-element-relation-descendant",
-    Sibling: "trace-operation-timeline-record-element-relation-sibling",
-    None: "trace-operation-timeline-record-element-relation-none",
-};
+        console.assert(eventType, eventType);
 
-WebInspector.TraceOperationTimelineRecord.displayNameForEventType = function(eventType)
-{
-    switch (eventType) {
-    case WebInspector.TraceOperationTimelineRecord.EventType.ElementInserted:
-        return WebInspector.UIString("Element Inserted");
-    case WebInspector.TraceOperationTimelineRecord.EventType.ElementRemoved:
-        return WebInspector.UIString("Element Removed");
-    case WebInspector.TraceOperationTimelineRecord.EventType.AttributeModified:
-        return WebInspector.UIString("Attribute Modified");
-    case WebInspector.TraceOperationTimelineRecord.EventType.AttributeRemoved:
-        return WebInspector.UIString("Attribute Removed");
+        this._eventType = eventType;
+        this._relationToTarget = relationToTarget;
+        this._data = data;
     }
-};
 
+    // Static
 
-WebInspector.TraceOperationTimelineRecord.displayNameForElementRelation = function(relation)
-{
-    switch (relation) {
-    case WebInspector.TraceOperationTimelineRecord.ElementRelation.Target:
-        return WebInspector.UIString("Is Target");
-    case WebInspector.TraceOperationTimelineRecord.ElementRelation.Parent:
-        return WebInspector.UIString("Parent");
-    case WebInspector.TraceOperationTimelineRecord.ElementRelation.Child:
-        return WebInspector.UIString("Child");
-    case WebInspector.TraceOperationTimelineRecord.ElementRelation.Ancestor:
-        return WebInspector.UIString("Ancestor");
-    case WebInspector.TraceOperationTimelineRecord.ElementRelation.Descendant:
-        return WebInspector.UIString("Descendant");
-    case WebInspector.TraceOperationTimelineRecord.ElementRelation.Sibling:
-        return WebInspector.UIString("Sibling");
-    case WebInspector.TraceOperationTimelineRecord.ElementRelation.None:
-        return WebInspector.UIString("None");
+    static displayNameForEventType(eventType)
+    {
+        switch (eventType) {
+        case WebInspector.TraceOperationTimelineRecord.EventType.ElementInserted:
+            return WebInspector.UIString("Element Inserted");
+        case WebInspector.TraceOperationTimelineRecord.EventType.ElementRemoved:
+            return WebInspector.UIString("Element Removed");
+        case WebInspector.TraceOperationTimelineRecord.EventType.AttributeModified:
+            return WebInspector.UIString("Attribute Modified");
+        case WebInspector.TraceOperationTimelineRecord.EventType.AttributeRemoved:
+            return WebInspector.UIString("Attribute Removed");
+        }
     }
-};
-
-WebInspector.TraceOperationTimelineRecord.TypeIdentifier = "trace-operation-timeline-record";
-WebInspector.TraceOperationTimelineRecord.EventTypeCookieKey = "trace-operation-timeline-record-event-type";
 
-WebInspector.TraceOperationTimelineRecord.prototype = {
-    constructor: WebInspector.TraceOperationTimelineRecord,
-    __proto__: WebInspector.TimelineRecord.prototype,
+    static displayNameForElementRelation(relation)
+    {
+        switch (relation) {
+        case WebInspector.TraceOperationTimelineRecord.ElementRelation.Target:
+            return WebInspector.UIString("Is Target");
+        case WebInspector.TraceOperationTimelineRecord.ElementRelation.Parent:
+            return WebInspector.UIString("Parent");
+        case WebInspector.TraceOperationTimelineRecord.ElementRelation.Child:
+            return WebInspector.UIString("Child");
+        case WebInspector.TraceOperationTimelineRecord.ElementRelation.Ancestor:
+            return WebInspector.UIString("Ancestor");
+        case WebInspector.TraceOperationTimelineRecord.ElementRelation.Descendant:
+            return WebInspector.UIString("Descendant");
+        case WebInspector.TraceOperationTimelineRecord.ElementRelation.Sibling:
+            return WebInspector.UIString("Sibling");
+        case WebInspector.TraceOperationTimelineRecord.ElementRelation.None:
+            return WebInspector.UIString("None");
+        }
+    }
 
     // Public
 
     get eventType()
     {
         return this._eventType;
-    },
+    }
 
     get relationToTarget()
     {
         return this._relationToTarget;
-    },
+    }
 
-    saveIdentityToCookie: function(cookie)
+    saveIdentityToCookie(cookie)
     {
         WebInspector.TimelineRecord.prototype.saveIdentityToCookie.call(this, cookie);
 
         cookie[WebInspector.TraceOperationTimelineRecord.EventTypeCookieKey] = this._eventType;
     }
 };
+
+WebInspector.TraceOperationTimelineRecord.EventType = {
+    ElementInserted: "trace-operation-timeline-record-element-inserted",
+    ElementRemoved: "trace-operation-timeline-record-element-removed",
+    AttributeModified: "trace-operation-timeline-record-attribute-modified",
+    AttributeRemoved: "trace-operation-timeline-record-attribute-removed",
+};
+
+WebInspector.TraceOperationTimelineRecord.ElementRelation = {
+    Target: "trace-operation-timeline-record-element-relation-target",
+    Parent: "trace-operation-timeline-record-element-relation-parent",
+    Child: "trace-operation-timeline-record-element-relation-child",
+    Ancestor: "trace-operation-timeline-record-element-relation-ancestor",
+    Descendant: "trace-operation-timeline-record-element-relation-descendant",
+    Sibling: "trace-operation-timeline-record-element-relation-sibling",
+    None: "trace-operation-timeline-record-element-relation-none",
+};
+
+WebInspector.TraceOperationTimelineRecord.TypeIdentifier = "trace-operation-timeline-record";
+WebInspector.TraceOperationTimelineRecord.EventTypeCookieKey = "trace-operation-timeline-record-event-type";
diff --git a/Source/WebInspectorUI/UserInterface/Protocol/DOMTracingObserver.js b/Source/WebInspectorUI/UserInterface/Protocol/DOMTracingObserver.js
index abcd752..6b43b6d 100644
--- a/Source/WebInspectorUI/UserInterface/Protocol/DOMTracingObserver.js
+++ b/Source/WebInspectorUI/UserInterface/Protocol/DOMTracingObserver.js
@@ -18,21 +18,22 @@
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 WebInspector.DOMTracingObserver = function()
 {
-    WebInspector.Object.call(this);
+    // FIXME: Convert this to a WebInspector.Object subclass, and call super().
+    // WebInspector.Object.call(this);
 };
 
 WebInspector.DOMTracingObserver.prototype = {
     constructor: WebInspector.DOMTracingObserver,
     __proto__: WebInspector.Object.prototype,
 
     snapshotCreated: function(snapshotHeader)
     {
         WebInspector.domTracingManager.snapshotCreated(snapshotHeader);
     },
diff --git a/Source/WebInspectorUI/UserInterface/Views/ElementTrackingTimelineDataGridNode.js b/Source/WebInspectorUI/UserInterface/Views/ElementTrackingTimelineDataGridNode.js
index 1444a2e..485a206 100644
--- a/Source/WebInspectorUI/UserInterface/Views/ElementTrackingTimelineDataGridNode.js
+++ b/Source/WebInspectorUI/UserInterface/Views/ElementTrackingTimelineDataGridNode.js
@@ -29,21 +29,22 @@ WebInspector.ElementTrackingTimelineDataGridNode = function(timelineRecord, base
     // free-form data. The same data grid node class should be created for either of them.
     console.assert(timelineRecord instanceof WebInspector.TimelineRecord, timelineRecord);
     console.assert(timelineRecord.type === WebInspector.TimelineRecord.Type.ElementTracking, timelineRecord);
 
     WebInspector.TimelineDataGridNode.call(this, false, null);
 
     this._record = timelineRecord;
     this._baseStartTime = baseStartTime || 0;
 };
 
-WebInspector.Object.addConstructorFunctions(WebInspector.ElementTrackingTimelineDataGridNode);
+// FIXME: Move to a WebInspector.Object subclass and we can remove this.
+WebInspector.Object.deprecatedAddConstructorFunctions(WebInspector.ElementTrackingTimelineDataGridNode);
 
 WebInspector.ElementTrackingTimelineDataGridNode.IconStyleClassName = "icon";
 WebInspector.ElementTrackingTimelineDataGridNode.SubtitleStyleClassName = "subtitle";
 
 WebInspector.ElementTrackingTimelineDataGridNode.prototype = {
     constructor: WebInspector.ElementTrackingTimelineDataGridNode,
     __proto__: WebInspector.TimelineDataGridNode.prototype,
 
     // Public
 
diff --git a/Source/WebInspectorUI/UserInterface/Views/Resizer.js b/Source/WebInspectorUI/UserInterface/Views/Resizer.js
index 925ff6f..0acb08e 100644
--- a/Source/WebInspectorUI/UserInterface/Views/Resizer.js
+++ b/Source/WebInspectorUI/UserInterface/Views/Resizer.js
@@ -17,21 +17,22 @@
  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 WebInspector.Resizer = function(ruleOrientation, delegate) {
-    WebInspector.Object.call(this);
+    // FIXME: Convert this to a WebInspector.Object subclass, and call super().
+    // WebInspector.Object.call(this);
 
     console.assert(delegate);
 
     this._delegate = delegate;
     this._orientation = ruleOrientation;
     this._element = document.createElement("div");
     this._element.classList.add(WebInspector.Resizer.StyleClassName);
 
     if (this._orientation === WebInspector.Resizer.RuleOrientation.Horizontal)
         this._element.classList.add(WebInspector.Resizer.HorizontalRuleStyleClassName);
diff --git a/Source/WebInspectorUI/UserInterface/Views/TimelineRecordStack.js b/Source/WebInspectorUI/UserInterface/Views/TimelineRecordStack.js
index 9eb0283..febd3b7 100644
--- a/Source/WebInspectorUI/UserInterface/Views/TimelineRecordStack.js
+++ b/Source/WebInspectorUI/UserInterface/Views/TimelineRecordStack.js
@@ -19,37 +19,39 @@
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 WebInspector.TimelineRecordStack = function(records)
 {
-    WebInspector.Object.call(this);
+    // FIXME: Convert this to a WebInspector.Object subclass, and call super().
+    // WebInspector.Object.call(this);
 
     this._isSelected = false;
 
     this._element = document.createElement("div");
     this._element.classList.add(WebInspector.TimelineRecordStack.StyleClassName);
 
     this._counterElement = document.createElement("span");
     this._counterElement.classList.add(WebInspector.TimelineRecordStack.CounterStyleClassName);
 
     this._element.recordStack = this;
 
     // Set this last, since it triggers relayout using the above elements.
     this.records = records;
 };
 
-WebInspector.Object.addConstructorFunctions(WebInspector.TimelineRecordStack);
+// FIXME: Move to a WebInspector.Object subclass and we can remove this.
+WebInspector.Object.deprecatedAddConstructorFunctions(WebInspector.TimelineRecordStack);
 
 WebInspector.TimelineRecordStack.StyleClassName = "timeline-record-stack";
 WebInspector.TimelineRecordStack.CounterStyleClassName = "timeline-record-stack-counter";
 WebInspector.TimelineRecordStack.SelectedStyleClassName = "selected";
 WebInspector.TimelineRecordStack.PreviewImageStyleClassName = "preview-image";
 WebInspector.TimelineRecordStack.MinimumWidthPixels = 36;
 WebInspector.TimelineRecordStack.MaximumWidthPixels = 48;
 WebInspector.TimelineRecordStack.MinimumMarginPixels = 2;
 WebInspector.TimelineRecordStack.SelectionBorderWidthInPixels = 2;
 
-- 
2.3.2

