From 2a2d8253ace80307b95ac0d46757fb8f75155bef Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Thu, 2 Apr 2015 14:39:49 -0700
Subject: [PATCH] Include properties animated through CSS animations and
 transitions in style snapshots.

Add substantial comments to createEffectiveStyle() so it's clear what
stuff in the cascade simulator has been implemented or not implemented.
---
 .../inspector/protocol/DOMTracing.json             |  12 +-
 .../WebCore/inspector/InspectorDOMTracingAgent.cpp | 233 ++++++++++++++++-----
 .../Localizations/en.lproj/localizedStrings.js     | Bin 61568 -> 61698 bytes
 .../UserInterface/Models/DOMTreeSnapshot.js        |  57 +++--
 .../UserInterface/Models/EffectiveStyleSnapshot.js |  60 +++---
 .../Views/ElementSnapshotStyleContentView.js       |  18 +-
 6 files changed, 279 insertions(+), 101 deletions(-)

diff --git a/Source/JavaScriptCore/inspector/protocol/DOMTracing.json b/Source/JavaScriptCore/inspector/protocol/DOMTracing.json
index 9661971..07a9e6f 100644
--- a/Source/JavaScriptCore/inspector/protocol/DOMTracing.json
+++ b/Source/JavaScriptCore/inspector/protocol/DOMTracing.json
@@ -63,29 +63,39 @@
                 { "name": "effectiveStyles", "type": "array", "items": { "$ref": "EffectiveStyle" }, "description": "Effective styles for the target element and its descendants." },
                 { "name": "elements", "type": "array", "items" : { "$ref": "ElementEntry" }, "description": "Style data for elements that are ancestors or descendants of the target element."},
                 { "name": "rules", "type": "array", "items" : { "$ref": "CSS.CSSRule" }, "description": "Style data for rules that contribute to at least one effective style."}
             ]
         },
         {
             "id": "EffectiveStyle",
             "type": "object",
             "properties": [
                 { "name": "target", "$ref": "DOM.NodeId", "description": "The id for the element that was snapshotted."},
-                { "name": "properties", "type": "array", "items": { "$ref": "PropertyEntry" }, "description": "Effective properties for the target element." }
+                { "name": "properties", "type": "array", "items": { "$ref": "PropertyEntry" }, "description": "Effective style properties for the target element." }
             ],
             "description": "Describes the effective style properties for the target element, with cross-references to the elements that contributed properties via inline styles and matched rules"
         },
         {
+            "id": "PropertyEntryOrigin",
+            "type": "string",
+            "enum": [
+                "Rule",
+                "Animated",
+                "Inline"
+            ]
+        },
+        {
             "id": "PropertyEntry",
             "type": "object",
             "properties": [
                 { "name": "property", "$ref": "CSS.CSSProperty", "description": "A property that forms part of the effective element style." },
+                { "name": "origin", "$ref": "PropertyEntryOrigin", "description": "Where the property came from." },
                 { "name": "sourceRule", "$ref": "CSSRuleOrdinal", "optional": true, "description": "If property was contributed by a rule that matched the target or target's ancestor element, the rule's identifier at time of snapshot. This identifier cross-references to a MatchedRule's CSSRuleId for the element that matched the rule."},
                 { "name": "sourceElement", "$ref": "ElementOrdinal", "optional": true, "description": "If property was contributed by an element's inline style, the element's identifier at time of snapshot."}
             ],
             "description": "An style property contributed by a rule or inline style."
          },
         {
             "id": "ElementEntry",
             "type": "object",
             "properties": [
                 { "name": "nodeId", "$ref": "DOM.NodeId", "description": "Identifier for the element that this object describes."},
diff --git a/Source/WebCore/inspector/InspectorDOMTracingAgent.cpp b/Source/WebCore/inspector/InspectorDOMTracingAgent.cpp
index 2f66601..bfbb040 100644
--- a/Source/WebCore/inspector/InspectorDOMTracingAgent.cpp
+++ b/Source/WebCore/inspector/InspectorDOMTracingAgent.cpp
@@ -20,20 +20,21 @@
  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 
 #include "InspectorDOMTracingAgent.h"
 
+#include "CSSComputedStyleDeclaration.h"
 #include "Element.h"
 #include "ElementTraceOperations.h"
 #include "FrameSnapshotting.h"
 #include "FrameView.h"
 #include "ImageBuffer.h"
 #include "InspectorCSSAgent.h"
 #include "InspectorDOMAgent.h"
 #include "InspectorInlineStyleRuleSet.h"
 #include "InspectorPageAgent.h"
 #include "InspectorStyleDeclaration.h"
@@ -132,21 +133,24 @@ ElementSnapshot::ElementSnapshot(std::unique_ptr<ImageBuffer> data, const Layout
 
 bool operator==(const ElementSnapshot& a, const ElementSnapshot& b)
 {
     if (a.snapshotId == b.snapshotId)
         return true;
 
     // These are root frame view coordinates, so scrolling will not affect equality.
     if (a.boundingBox != b.boundingBox)
         return false;
 
-    ASSERT(a.imageData->logicalSize() == b.imageData->logicalSize());
+    // Animated elements can have the same bounding box (covering the entire animated extent)
+    // but different logical sizes when painted.
+    if (a.imageData->logicalSize() != b.imageData->logicalSize())
+        return false;
 
     float diffPercent = ImageBuffer::computeDifference(*a.imageData, *b.imageData);
     return diffPercent < 0.01f;
 }
 
 DOMTracingAgent::DOMTracingAgent(InstrumentingAgents* instrumentingAgents, InspectorDOMAgent* domAgent, InspectorCSSAgent* cssAgent)
     : InspectorAgentBase(ASCIILiteral("DOMTracing"), instrumentingAgents)
     , m_domAgent(domAgent)
     , m_cssAgent(cssAgent)
 {
@@ -164,162 +168,285 @@ std::unique_ptr<ElementSnapshot> DOMTracingAgent::createSnapshot(Element& elemen
         return std::make_unique<ElementSnapshot>();
 
     std::unique_ptr<ImageBuffer> imageData = snapshotNode(element.renderer()->frame().mainFrame(), element);
     IntRect bounds = element.boundsInRootViewSpace();
     return std::make_unique<ElementSnapshot>(std::move(imageData), bounds, m_nextSnapshotId++);
 }
 
 // This is duplicated from CSSAgent.cpp because that functor implementation explicitly tracks
 // active/inactive properties as it builds multiple objects, rather than precomputing status.
 // (Maybe StyleDeclaration::populateProperties should handle this and give such data to StyleProperty...)
-static RefPtr<Inspector::Protocol::CSS::CSSProperty> buildObjectForProperty(StyleDeclaration& declaration, CSSPropertyID propertyId)
+static RefPtr<Inspector::Protocol::CSS::CSSProperty> buildObjectForProperty(StyleProperty& property)
 {
-    RefPtr<Inspector::Protocol::CSS::CSSProperty> result;
-    declaration.withPropertyForId(propertyId, [&result] (StyleProperty& property) {
-        result = Inspector::Protocol::CSS::CSSProperty::create()
-            .setName(property.propertyName().lower())
-            .setValue(property.propertyValue())
-            .release();
+    RefPtr<Inspector::Protocol::CSS::CSSProperty> result = Inspector::Protocol::CSS::CSSProperty::create()
+        .setName(property.propertyName().lower())
+        .setValue(property.propertyValue())
+        .release();
 
-        result->setParsedOk(property.parsedOk());
-        result->setImplicit(property.isImplicit());
-        auto status = Inspector::Protocol::CSS::CSSPropertyStatus::Active;
-        if (!property.isFromSource())
-            status = Inspector::Protocol::CSS::CSSPropertyStatus::Style;
-        else {
-            result->setText(property.rawText());
-
-            TextPosition start, end;
-            property.getTextRange(start, end);
-            result->setRange(buildObjectForSourceRange(start, end));
-        }
-        result->setStatus(status);
-    });
+    result->setParsedOk(property.parsedOk());
+    result->setImplicit(property.isImplicit());
+    auto status = Inspector::Protocol::CSS::CSSPropertyStatus::Active;
+    if (!property.isFromSource())
+        status = Inspector::Protocol::CSS::CSSPropertyStatus::Style;
+    else {
+        result->setText(property.rawText());
+
+        TextPosition start, end;
+        property.getTextRange(start, end);
+        result->setRange(buildObjectForSourceRange(start, end));
+    }
+    result->setStatus(status);
 
     return WTF::move(result);
 }
 
 RefPtr<Inspector::Protocol::DOMTracing::EffectiveStyle> DOMTracingAgent::createEffectiveStyle(Element& targetElement, StyleSnapshotData& snapshotData)
 {
+    // NOTE: this method simulates the CSS cascade in order to find out where each property in the element's
+    // computed style came from. The cascade phases are specified at the link below, and equivalent code is noted.
+    // Not all parts of the cascade are implemented yet.
+    //
+    // http://www.w3.org/TR/2013/CR-css-cascade-3-20131003/#cascade-origin
+    //
+    // The computed style that we compute should match the actual computed style (i.e., CSSComputedStyleDeclaration).
+    // The latter converts an Element's renderer's RenderStyle into a JS-accessible object model.
+    // It also allows straightforward inspection of properties by using CSSPropertyID and CSSValue.
+
+    // FIXME: add debug code at the end to compare the effective style to the CSSComputedStyleDecaration.
+    // This should identify specific test cases where we don't do the cascade correctly.
+
     std::bitset<numCSSProperties> propertyIsClaimed;
     HashMap<CSSPropertyID, WebCore::StyleRule*> winningRuleMap;
     HashMap<CSSPropertyID, Element*> winningInlineStyleMap;
+    // Maps from an animated effective property to the element that contributed it (through its matched
+    // rules, inline styles). The frontend can figure out which animation property contributed it and where
+    // the animation property itself came from. Also save the property value to avoid recomputing it again.
+    HashMap<CSSPropertyID, std::pair<RefPtr<CSSValue>, Element*>> winningAnimationMap;
 
-    StyleResolver& styleResolver = targetElement.document().ensureStyleResolver();
     LOG(WebReplay, "\nCalculating effective style for element %p\n", &targetElement);
-    
+
+    snapshotData.addElement(targetElement);
+
+    // This loop implements style inheritance by claiming properties from self and closer ancestors first.
     for (Element* element = &targetElement; element; element = element->parentElement()) {
-        // First try to claim properties in the inline style, as it has highest specificity.
+        bool onlyConsiderInheritedProperties = (element != &targetElement);
+
+        if (!onlyConsiderInheritedProperties)
+            LOG(WebReplay, "\tFinding non-inherited properties that match element %p\n", element);
+        else
+            LOG(WebReplay, "\tFinding inherited properties from ancestor element %p\n", element);
+
+        StyleResolver& styleResolver = element->document().ensureStyleResolver();
+        ComputedStyleExtractor styleExtractor(element, true, NOPSEUDO);
+
+        if (RenderObject* renderer = element->renderer()) {
+            RenderStyle& renderStyle = renderer->style();
+
+            // 1. Transition Declarations
+            renderStyle.ensureTransitions();
+            if (!renderStyle.transitions()->isEmpty()) {
+                LOG(WebReplay, "\t\tChecking %zu transitions.\n", renderStyle.transitions()->size());
+
+                auto transitions = renderStyle.transitions();
+                for (size_t i = 0; i < transitions->size(); ++i) {
+                    const Animation& animation = transitions->animation(i);
+                    CSSPropertyID animatedPropertyId = animation.property();
+                    if (onlyConsiderInheritedProperties && !CSSProperty::isInheritedProperty(animatedPropertyId)) {
+                        LOG(WebReplay, "\t\t\tIgnoring non-inheritable property %s\n", getPropertyName(animatedPropertyId));
+                        continue;
+                    }
+                    if (propertyIsClaimed[animatedPropertyId]) {
+                        LOG(WebReplay, "\t\t\tIgnoring overridden property %s\n", getPropertyName(animatedPropertyId));
+                        continue;
+                    }
+
+                    RefPtr<CSSValue> animatedPropertyValue = styleExtractor.propertyValue(animatedPropertyId, DoNotUpdateLayout);
+                    if (!animatedPropertyValue || animatedPropertyValue->isImplicitInitialValue()) {
+                        LOG(WebReplay, "\t\t\tIgnoring implicit initial value for property %s\n", getPropertyName(animatedPropertyId));
+                        continue;
+                    }
+
+                    propertyIsClaimed.set(animatedPropertyId);
+                    auto addResult = winningAnimationMap.set(animatedPropertyId, std::make_pair(animatedPropertyValue, element));
+                    ASSERT_UNUSED(addResult, addResult.isNewEntry);
+                    LOG(WebReplay, "\t\t\tClaimed property  %s: %s\n", getPropertyName(animatedPropertyId), animatedPropertyValue->cssText().utf8().data());
+                }
+            }
+
+            // 2. Important User Agent Declarations
+            // 3. Important User Declarations
+            // 4. Important Override Declarations
+            // 5. Important Author Declarations
+
+            // FIXME: implement these, especially handling of '!important' author declarations.
+            // The others are less important, since they aren't likely to be the cause of a bug.
+
+            // 6. Animation Declarations
+            renderStyle.ensureAnimations();
+            if (!renderStyle.animations()->isEmpty()) {
+                LOG(WebReplay, "\t\tChecking %zu animations.\n", renderStyle.animations()->size());
+
+                auto animations = renderStyle.animations();
+                for (size_t i = 0; i < animations->size(); ++i) {
+                    const Animation& animation = animations->animation(i);
+                    CSSPropertyID animatedPropertyId = animation.property();
+                    if (onlyConsiderInheritedProperties && !CSSProperty::isInheritedProperty(animatedPropertyId)) {
+                        LOG(WebReplay, "\t\t\tIgnoring non-inheritable property %s\n", getPropertyName(animatedPropertyId));
+                        continue;
+                    }
+                    if (propertyIsClaimed[animatedPropertyId]) {
+                        LOG(WebReplay, "\t\t\tIgnoring overridden property %s\n", getPropertyName(animatedPropertyId));
+                        continue;
+                    }
+
+                    RefPtr<CSSValue> animatedPropertyValue = styleExtractor.propertyValue(animatedPropertyId, DoNotUpdateLayout);
+                    if (!animatedPropertyValue || animatedPropertyValue->isImplicitInitialValue()) {
+                        LOG(WebReplay, "\t\t\tIgnoring implicit initial value for property %s\n", getPropertyName(animatedPropertyId));
+                        continue;
+                    }
+
+                    propertyIsClaimed.set(animatedPropertyId);
+                    auto addResult = winningAnimationMap.set(animatedPropertyId, std::make_pair(animatedPropertyValue, element));
+                    ASSERT_UNUSED(addResult, addResult.isNewEntry);
+                    LOG(WebReplay, "\t\t\tClaimed property  %s: %s\n", getPropertyName(animatedPropertyId), animatedPropertyValue->cssText().utf8().data());
+                }
+            }
+        }
+
+        // 7. Normal Override Declarations
+
+        // 7a. Inline Styles
+
+        // NOTE: Setting CSS style properties in JavaScript through the CSSOM will be shown as
+        // changes to the element's inline style. So it suffices to claim properties from inline style.
         const StyleProperties* properties = nullptr;
         if (is<StyledElement>(element))
             properties = downcast<StyledElement>(element)->inlineStyle();
 
         unsigned size = properties ? properties->propertyCount() : 0;
-
-        if (element == &targetElement)
-            LOG(WebReplay, "\tFinding non-inherited properties that match element %p\n", element);
-        else
-            LOG(WebReplay, "\tFinding inherited properties from ancestor element %p\n", element);
-        
         if (size)
             LOG(WebReplay, "\t\tChecking inline style for element: %p\n", element);
 
-        bool claimedPropertyFromInlineStyle = false;
         for (unsigned i = 0; i < size; ++i) {
             auto property = properties->propertyAt(i);
             if (!propertyIsClaimed[property.id()]) {
                 propertyIsClaimed.set(property.id());
-                claimedPropertyFromInlineStyle = true;
+                snapshotData.addElement(*element);
                 auto addResult = winningInlineStyleMap.set(property.id(), element);
                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
                 LOG(WebReplay, "\t\t\tClaimed property  %s: %s\n", getPropertyName(property.id()), property.value()->cssText().utf8().data());
             }
         }
 
-        if (claimedPropertyFromInlineStyle)
-            snapshotData.addElement(*element);
+        // 7b. Attribute Styles
+
+        // FIXME: implement. These come from presentational attributes such as |width="40"|.
+        // Their order in the cascade seems to differ depending on the origin (HTML or SVG).
+
+        // 8. Normal Author Declarations
 
-        // Then try to claim properties from each rule that matches this element.
-        // Rules are already sorted by descending specificity, so higher specificity
+        // NOTE: Rules are already sorted by descending specificity, so higher specificity
         // rules and earlier rules will claim properties first.
-        auto matchedRules = styleResolver.styleRulesForElement(element, StyleResolver::AuthorCSSRules);
+
+        // FIXME: pseudo style rules are not matched here, but should be if a pseudo-state is active.
+        auto matchedRules = styleResolver.styleRulesForElement(element, StyleResolver::AuthorCSSRules | StyleResolver::CrossOriginCSSRules);
         for (RefPtr<WebCore::StyleRule> rule : matchedRules) {
             LOG(WebReplay, "\t\tChecking rule with selector: %s\n", rule->selectorList().selectorsText().utf8().data());
 
-            bool onlyConsiderInheritedProperties = (element != &targetElement);
             const StyleProperties& properties = rule->properties();
-            bool claimedPropertyFromRule = false;
             unsigned size = properties.propertyCount();
             for (unsigned i = 0; i < size; ++i) {
                 auto property = properties.propertyAt(i);
                 if (onlyConsiderInheritedProperties && !CSSProperty::isInheritedProperty(property.id())) {
                     LOG(WebReplay, "\t\t\tIgnoring non-inheritable property %s\n", getPropertyName(property.id()));
                     continue;
                 }
                 if (property.value()->isImplicitInitialValue()) {
                     LOG(WebReplay, "\t\t\tIgnoring implicit initial value for property %s\n", getPropertyName(property.id()));
                     continue;
                 }
                 if (propertyIsClaimed[property.id()]) {
-                    LOG(WebReplay, "\t\t\tIgnoring losing property %s\n", getPropertyName(property.id()));
+                    LOG(WebReplay, "\t\t\tIgnoring overridden property %s\n", getPropertyName(property.id()));
                     continue;
                 }
 
                 propertyIsClaimed.set(property.id());
-                claimedPropertyFromRule = true;
+                snapshotData.addRuleForElement(*rule, *element);
                 auto addResult = winningRuleMap.set(property.id(), rule.get());
                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
                 LOG(WebReplay, "\t\t\tClaimed property  %s: %s\n", getPropertyName(property.id()), property.value()->cssText().utf8().data());
             }
-            if (!claimedPropertyFromRule)
-                continue;
-
-            snapshotData.addRuleForElement(*rule, *element);
         }
-        // TODO: add matched pseudo style rules. See CSSAgent. It could be folded into above.
+        // 9. Normal User Declarations
+        // 10. Normal User Agent Declarations
+        // NOTE: these are not as important since they do not change much, except
     }
 
     auto propertiesArray = Inspector::Protocol::Array<Inspector::Protocol::DOMTracing::PropertyEntry>::create();
     for (auto entry : winningRuleMap) {
         RefPtr<Inspector::Protocol::DOMTracing::PropertyEntry> entryObject;
         m_cssAgent->withWrappedRule(*entry.value, targetElement.document(), [&] (Inspector::StyleRule& rule) {
             RefPtr<Inspector::Protocol::CSS::CSSProperty> propertyObject;
-            rule.withStyle([&] (Inspector::StyleDeclaration& style) {
-                CSSPropertyID propertyId = entry.key;
-                propertyObject = buildObjectForProperty(style, propertyId);
+            rule.withStyle([&] (Inspector::StyleDeclaration& declaration) {
+                declaration.withPropertyForId(entry.key, [&] (StyleProperty& property) {
+                    propertyObject = buildObjectForProperty(property);
+                });
             });
             entryObject = Inspector::Protocol::DOMTracing::PropertyEntry::create()
                 .setProperty(WTF::move(propertyObject))
+                .setOrigin(Inspector::Protocol::DOMTracing::PropertyEntryOrigin::Rule)
                 .release();
 
             entryObject->setSourceRule(snapshotData.ordinalForRule(*entry.value));
         });
         propertiesArray->addItem(WTF::move(entryObject));
     }
 
     for (auto entry : winningInlineStyleMap) {
         ASSERT(is<StyledElement>(entry.value));
         InlineStyleRuleSet& inlineStyle = m_cssAgent->ruleSetForInlineStyle(*entry.value);
         RefPtr<Inspector::Protocol::CSS::CSSProperty> propertyObject;
         RefPtr<Inspector::Protocol::DOMTracing::PropertyEntry> entryObject;
-        inlineStyle.withInlineStyle([&] (StyleDeclaration& style) {
-            CSSPropertyID propertyId = entry.key;
-            propertyObject = buildObjectForProperty(style, propertyId);
+        inlineStyle.withInlineStyle([&] (StyleDeclaration& declaration) {
+            declaration.withPropertyForId(entry.key, [&] (StyleProperty& property) {
+                propertyObject = buildObjectForProperty(property);
+            });
             entryObject = Inspector::Protocol::DOMTracing::PropertyEntry::create()
                 .setProperty(WTF::move(propertyObject))
+                .setOrigin(Inspector::Protocol::DOMTracing::PropertyEntryOrigin::Inline)
                 .release();
         });
 
         entryObject->setSourceElement(snapshotData.ordinalForElement(*entry.value));
         propertiesArray->addItem(WTF::move(entryObject));
     }
 
+    for (auto entry : winningAnimationMap) {
+        CSSPropertyID propertyID = entry.key;
+        RefPtr<CSSValue> propertyValue = entry.value.first;
+        Element* sourceElement = entry.value.second;
+
+        RefPtr<Inspector::Protocol::CSS::CSSProperty> propertyObject = Inspector::Protocol::CSS::CSSProperty::create()
+            .setName(String(getPropertyName(propertyID)).lower())
+            .setValue(propertyValue->cssText())
+            .release();
+        propertyObject->setParsedOk(true);
+        propertyObject->setImplicit(false);
+        propertyObject->setStatus(Inspector::Protocol::CSS::CSSPropertyStatus::Active);
+
+        RefPtr<Inspector::Protocol::DOMTracing::PropertyEntry> entryObject = Inspector::Protocol::DOMTracing::PropertyEntry::create()
+            .setProperty(WTF::move(propertyObject))
+            .setOrigin(Inspector::Protocol::DOMTracing::PropertyEntryOrigin::Animated)
+            .release();
+        entryObject->setSourceElement(snapshotData.ordinalForElement(*sourceElement));
+        propertiesArray->addItem(WTF::move(entryObject));
+    }
     return Inspector::Protocol::DOMTracing::EffectiveStyle::create()
         .setTarget(m_domAgent->pushNodePathToFrontend(&targetElement))
         .setProperties(WTF::move(propertiesArray))
         .release();
 }
 
 std::unique_ptr<StyleSnapshot> DOMTracingAgent::createStyleSnapshot(Element& targetElement, StyleSnapshotData& snapshotData)
 {
     auto effectiveStylesArray = Inspector::Protocol::Array<Inspector::Protocol::DOMTracing::EffectiveStyle>::create();
     for (Node* node = &targetElement; node; node = NodeTraversal::next(*node, &targetElement)) {
diff --git a/Source/WebInspectorUI/Localizations/en.lproj/localizedStrings.js b/Source/WebInspectorUI/Localizations/en.lproj/localizedStrings.js
index dbf3c9e66a601a75623c36ff971be26b647a152d..91616d984f839bb241376987b5b8deb44c344a34 100644
GIT binary patch
delta 58
zcmZp8$lUaZd4q!lb1Fm1WW%@0{EiHH44DkM42cXS3?Q+Ea~&rKh_FmPCm}O=f`riI
N4oR)e6C^%d2LLi_6cqpf

delta 18
acmZpA#N6<Zd4q$*WCbaa&DSJ!ZU6vB^#@u2

diff --git a/Source/WebInspectorUI/UserInterface/Models/DOMTreeSnapshot.js b/Source/WebInspectorUI/UserInterface/Models/DOMTreeSnapshot.js
index b588411..d3d6896 100644
--- a/Source/WebInspectorUI/UserInterface/Models/DOMTreeSnapshot.js
+++ b/Source/WebInspectorUI/UserInterface/Models/DOMTreeSnapshot.js
@@ -75,71 +75,90 @@ WebInspector.DOMTreeSnapshot = class DOMTreeSnapshot extends WebInspector.Object
                 if (!isValidOrdinal(match.rule, rules))
                     continue;
                 ruleMatches.push(rules[match.rule]);
             }
             nodeIdToElementOrdinal.set(entry.nodeId, elementData.length);
             elementData.push({node, ruleMatches, inlineStyle});
         }
 
         // Parse effective style properties.
         for (var entry of stylePayload.effectiveStyles) {
+            var animatedProperties = [];
             var matchedProperties = [];
             var inheritedProperties = [];
             var matchedRules = [];
             var inlineStyles = [];
             console.assert(nodeIdToElementOrdinal.has(entry.target), "Can't find element entry.");
             var targetOrdinal = nodeIdToElementOrdinal.get(entry.target);
             if (!isValidOrdinal(targetOrdinal, elementData))
                 continue;
-            var target = elementData[targetOrdinal];
+            var targetElementData = elementData[targetOrdinal];
 
             for (var i = 0; i < entry.properties.length; ++i) {
                 var propertyEntry = entry.properties[i];
-                var property = parsePropertyPayload(propertyEntry.property, i, null);
+                var cssProperty = parsePropertyPayload(propertyEntry.property, i, null);
                 var isInherited = false;
-                // If property came from a rule, find that rule based on its id.
-                if ("sourceRule" in propertyEntry) {
+
+                switch (propertyEntry.origin) {
+                case DOMTracingAgent.PropertyEntryOrigin.Rule: {
+                    if (!propertyEntry.hasOwnProperty("sourceRule"))
+                        continue;
+
                     var ruleOrdinal = propertyEntry.sourceRule;
                     if (!isValidOrdinal(ruleOrdinal, rules))
                         continue;
 
                     var originatingRule = rules[ruleOrdinal];
-                    property.ownerStyle = originatingRule.style;
+                    cssProperty.ownerStyle = originatingRule.style;
                     matchedRules.push(originatingRule);
-
-                    if (!target.ruleMatches.contains(originatingRule))
-                        isInherited = true;
+                    isInherited = !targetElementData.ruleMatches.contains(originatingRule);
+                    break;
                 }
-                // If property came from an element's inline style, find that.
-                else if ("sourceElement" in propertyEntry) {
+                case DOMTracingAgent.PropertyEntryOrigin.Inline: {
+                    if (!propertyEntry.hasOwnProperty("sourceElement"))
+                        continue;
+
                     var elementOrdinal = propertyEntry.sourceElement;
                     if (!isValidOrdinal(elementOrdinal, elementData))
                         continue;
 
                     var element = elementData[elementOrdinal];
                     console.assert(element.inlineStyle !== null, "Unable to find cross-referenced inline style for element", element);
-                    property.ownerStyle = element.inlineStyle;
+                    cssProperty.ownerStyle = element.inlineStyle;
                     inlineStyles.push(element.inlineStyle);
+                    isInherited = elementOrdinal !== targetOrdinal;
+                    break;
+                }
+                case DOMTracingAgent.PropertyEntryOrigin.Animated:
+                    if (!propertyEntry.hasOwnProperty("sourceElement"))
+                        continue;
 
-                    if (elementOrdinal !== targetOrdinal)
-                        isInherited = true;
-                } else
-                    console.assert("Unknown source for effective style property: ", property);
+                    var elementOrdinal = propertyEntry.sourceElement;
+                    if (!isValidOrdinal(elementOrdinal, elementData))
+                        continue;
 
-                if (isInherited)
-                    inheritedProperties.push(property);
+                    isInherited = elementOrdinal !== targetOrdinal;
+                    break;
+                default:
+                    console.error("Unknown property entry origin:", propertyEntry.origin);
+                    continue;
+                }
+                if (propertyEntry.origin === DOMTracingAgent.PropertyEntryOrigin.Animated)
+                    animatedProperties.push(cssProperty); // Could be inherited, but this is not common.
+                else if (isInherited)
+                    inheritedProperties.push(cssProperty);
                 else
-                    matchedProperties.push(property);
+                    matchedProperties.push(cssProperty);
             }
 
             var element = WebInspector.domTreeManager.nodeForId(entry.target);
-            var styleSnapshot = new WebInspector.EffectiveStyleSnapshot(element, matchedProperties, inheritedProperties, matchedRules, inlineStyles);
+            var styleSnapshot = new WebInspector.EffectiveStyleSnapshot(element, matchedProperties, inheritedProperties, animatedProperties, matchedRules, inlineStyles);
 
             // Associate effective style with node snapshot.
             console.assert(nodeMap.has(entry.target), "Couldn't find node snapshot for effective style snapshot", styleSnapshot);
             var nodeSnapshot = nodeMap.get(entry.target);
             nodeSnapshot.effectiveStyle = styleSnapshot;
         }
 
         return new WebInspector.DOMTreeSnapshot(nodeList[0], nodeMap);
 
         function isValidOrdinal(ordinal, vector) {
diff --git a/Source/WebInspectorUI/UserInterface/Models/EffectiveStyleSnapshot.js b/Source/WebInspectorUI/UserInterface/Models/EffectiveStyleSnapshot.js
index 916a38f..f5551d6 100644
--- a/Source/WebInspectorUI/UserInterface/Models/EffectiveStyleSnapshot.js
+++ b/Source/WebInspectorUI/UserInterface/Models/EffectiveStyleSnapshot.js
@@ -22,86 +22,96 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 // This class acts as a static data source for style data. It can be used in
 // place of WebInspector.DOMNodeStyles. It does not update style data as it
 // changes on the page, nor does it support editing.
 
 WebInspector.EffectiveStyleSnapshot = class EffectiveStyleSnapshot extends WebInspector.Object
 {
-    constructor(element, matchedProperties, inheritedProperties, matchedRules, inlineStyles)
+    constructor(element, matchedProperties, inheritedProperties, animatedProperties, matchedRules, inlineStyles)
     {
         super();
 
         this._element = element;
         this._matchedProperties = matchedProperties;
         this._inheritedProperties = inheritedProperties;
+        this._animatedProperties = animatedProperties;
         this._matchedRules = matchedRules;
         this._inlineStyles = inlineStyles;
     }
 
     // Public
 
     get element()
     {
         return this._element;
     }
 
     get matchedProperties()
     {
         return this._matchedProperties.slice();
     }
 
+    get inheritedProperties()
+    {
+        return this._inheritedProperties.slice();
+    }
+
+    get animatedProperties()
+    {
+        return this._animatedProperties.slice();
+    }
+
     get matchedPropertiesDeclaration()
     {
         if (!this._matchedProperties.length)
             return null;
 
-        if (this._matchedPropertiesDeclaration)
-            return this._matchedPropertiesDeclaration;
+        if (!this._matchedPropertiesDeclaration)
+            this._matchedPropertiesDeclaration = WebInspector.EffectiveStyleSnapshot._createDeclarationFromProperties(this._matchedProperties);
 
-        var args = [
-            null, // updateDelegate
-            null, // ownerStyleSheet
-            null, // id
-            WebInspector.CSSStyleDeclaration.Type.Effective, // type
-            // FIXME: is this actually used anywhere? Not sure where it is used. We could plug in the target element.
-            null, // node
-            false, // inherited
-            null, // text
-            this._matchedProperties, // properties
-            null, // styleSheetTextRange
-        ];
-        this._matchedPropertiesDeclaration = new WebInspector.CSSStyleDeclaration(...args);
         return this._matchedPropertiesDeclaration;
     }
 
-    get inheritedProperties()
+    get inheritedPropertiesDeclaration()
     {
-        return this._inheritedProperties.slice();
+        if (!this._inheritedProperties.length)
+            return null;
+
+        if (!this._inheritedPropertiesDeclaration)
+            this._inheritedPropertiesDeclaration = WebInspector.EffectiveStyleSnapshot._createDeclarationFromProperties(this._inheritedProperties);
+
+        return this._inheritedPropertiesDeclaration;
     }
 
-    get inheritedPropertiesDeclaration()
+    get animatedPropertiesDeclaration()
     {
-        if (!this._inheritedProperties.length)
+        if (!this._animatedProperties.length)
             return null;
 
-        if (this._inheritedPropertiesDeclaration)
-            return this._inheritedPropertiesDeclaration;
+        if (!this._animatedPropertiesDeclaration)
+            this._animatedPropertiesDeclaration = WebInspector.EffectiveStyleSnapshot._createDeclarationFromProperties(this._animatedProperties);
+
+        return this._animatedPropertiesDeclaration;
+    }
+
+    // Private
 
+    static _createDeclarationFromProperties(properties)
+    {
         var args = [
             null, // updateDelegate
             null, // ownerStyleSheet
             null, // id
             WebInspector.CSSStyleDeclaration.Type.Effective, // type
             // FIXME: is this actually used anywhere? Not sure where it is used. We could plug in the target element.
             null, // node
             false, // inherited
             null, // text
-            this._inheritedProperties, // properties
+            properties, // properties
             null, // styleSheetTextRange
         ];
-        this._inheritedPropertiesDeclaration = new WebInspector.CSSStyleDeclaration(...args);
-        return this._inheritedPropertiesDeclaration;
+        return new WebInspector.CSSStyleDeclaration(...args);
     }
 };
diff --git a/Source/WebInspectorUI/UserInterface/Views/ElementSnapshotStyleContentView.js b/Source/WebInspectorUI/UserInterface/Views/ElementSnapshotStyleContentView.js
index 50f7e39..5f65b20 100644
--- a/Source/WebInspectorUI/UserInterface/Views/ElementSnapshotStyleContentView.js
+++ b/Source/WebInspectorUI/UserInterface/Views/ElementSnapshotStyleContentView.js
@@ -31,29 +31,36 @@ WebInspector.ElementSnapshotStyleContentView = function(snapshot)
     this.element.classList.add(WebInspector.ElementSnapshotStyleContentView.StyleClassName);
 
     this._matchedPropertiesTextEditor = new WebInspector.CSSStyleDeclarationTextEditor(this, null);
     this._matchedPropertiesTextEditor.showsImplicitProperties = false;
     this._matchedPropertiesTextEditor.sortProperties = true;
 
     this._inheritedPropertiesTextEditor = new WebInspector.CSSStyleDeclarationTextEditor(this, null);
     this._inheritedPropertiesTextEditor.showsImplicitProperties = false;
     this._inheritedPropertiesTextEditor.sortProperties = true;
 
+    this._animatedPropertiesTextEditor = new WebInspector.CSSStyleDeclarationTextEditor(this, null);
+    this._animatedPropertiesTextEditor.showsImplicitProperties = false;
+    this._animatedPropertiesTextEditor.sortProperties = true;
+
     function createSingletonSection(rowContent, identifier, title) {
         var propertiesRow = new WebInspector.DetailsSectionRow;
         propertiesRow.element.appendChild(rowContent);
         var propertiesGroup = new WebInspector.DetailsSectionGroup([propertiesRow]);
         return new WebInspector.DetailsSection(identifier, title, [propertiesGroup]);
     }
 
     this._matchedPropertiesSection = createSingletonSection(this._matchedPropertiesTextEditor.element, "effective-style-matched-properties", WebInspector.UIString("Matched Properties"));
     this._inheritedPropertiesSection = createSingletonSection(this._inheritedPropertiesTextEditor.element, "effective-style-inherited-properties", WebInspector.UIString("Inherited Properties"));
+    this._animatedPropertiesSection = createSingletonSection(this._animatedPropertiesTextEditor.element, "effective-style-animated-properties", WebInspector.UIString("Animated Properties"));
+
+    this.element.appendChild(this._animatedPropertiesSection.element);
     this.element.appendChild(this._matchedPropertiesSection.element);
     this.element.appendChild(this._inheritedPropertiesSection.element);
 };
 
 WebInspector.ElementSnapshotStyleContentView.StyleClassName = "element-snapshot-style";
 
 WebInspector.ElementSnapshotStyleContentView.prototype = {
     constructor: WebInspector.ElementSnapshotStyleContentView,
     __proto__: WebInspector.ContentView.prototype,
 
@@ -61,33 +68,38 @@ WebInspector.ElementSnapshotStyleContentView.prototype = {
     {
         WebInspector.ContentView.prototype.shown.call(this);
 
         this.updateLayout();
     },
 
     updateLayout: function()
     {
         this._matchedPropertiesTextEditor.updateLayout();
         this._inheritedPropertiesTextEditor.updateLayout();
+        this._animatedPropertiesTextEditor.updateLayout();
     },
 
     showStyleForNode: function(nodeSnapshot)
     {
         var canShowStyle = nodeSnapshot && nodeSnapshot.effectiveStyle;
         if (canShowStyle) {
             this._matchedPropertiesTextEditor.style = nodeSnapshot.effectiveStyle.matchedPropertiesDeclaration;
             this._inheritedPropertiesTextEditor.style = nodeSnapshot.effectiveStyle.inheritedPropertiesDeclaration;
+            this._animatedPropertiesTextEditor.style = nodeSnapshot.effectiveStyle.animatedPropertiesDeclaration;
         } else {
             this._matchedPropertiesTextEditor.style = null;
             this._inheritedPropertiesTextEditor.style = null;
+            this._animatedPropertiesTextEditor.style = null;
         }
 
-        var hasMatchedProperties = this._matchedPropertiesTextEditor.style;
-        var hasInheritedProperties = this._inheritedPropertiesTextEditor.style;
+        var hasMatchedProperties = !!this._matchedPropertiesTextEditor.style;
+        var hasInheritedProperties = !!this._inheritedPropertiesTextEditor.style;
+        var hasAnimatedProperties = !!this._animatedPropertiesTextEditor.style;
 
         // Don't hide all property sections; we want "No Properties" to appear at least once for text nodes.
-        this._matchedPropertiesSection.element.classList.toggle("hidden", !hasMatchedProperties && hasInheritedProperties);
+        this._matchedPropertiesSection.element.classList.toggle("hidden", !hasMatchedProperties && (hasInheritedProperties || hasAnimatedProperties));
         this._inheritedPropertiesSection.element.classList.toggle("hidden", !hasInheritedProperties);
+        this._animatedPropertiesSection.element.classList.toggle("hidden", !hasAnimatedProperties);
 
         this.updateLayout();
     }
 };
-- 
2.3.2

